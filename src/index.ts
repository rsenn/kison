// @ts-ignore
import Utils from 'modulex-util';
import LLGrammar from './ll/LLGrammar';
import LLKGrammar from './llk/LLKGrammar';
import LALRGrammar from './lalr/LALRGrammar';
import fs from 'fs';
import type { WriteFileOptions } from 'fs';
import path from 'path';
import program from 'commander';
import pkg from '../package.json';
import { build } from 'esbuild';
import { options as KisonOptions } from './options';

var encoding: WriteFileOptions = 'utf-8';

const ConsMap: Record<string, any> = {
  ll: LLGrammar,
  lalr: LALRGrammar,
  llk: LLKGrammar,
};
const placehoder = '__KISON___GENERATED__CODE__';

program
  .option('-g, --grammar <grammar>', 'Set kison grammar file')
  .option('-o, --output [file]', 'output file path')
  .option('--library [library]', 'library name')
  .option(
    '--astNodeUserDataTypes [astNodeUserDataTypes]',
    'astNodeUserDataTypes file',
  )
  .option('--bnf [bnf]', 'bnf file')
  .option('--declaration [declaration]', 'declaration')
  .option('--declarationDir [declarationDir]', 'declarationDir')
  .option('-m, --mode [mode]', 'lalr or ll')
  .option('-b, --babel [babel]', 'use babel')
  .option('-v, --verbose [verbose]', 'verbose')
  .option('--es [es]', 'generate es module')
  // defaults bool true
  .option('--no-compressSymbol', 'Set compress symbol')
  .option('--no-compressLexerState', 'Set compress lexer state')
  .parse(process.argv);

var options = program.options;

var grammar = path.resolve(program.grammar);

options.forEach(function (o: any) {
  var name = o.name();
  if (o.required && !(name in program)) {
    program.optionMissingArgument(o);
  }
});

var kisonCfg = {
  compressLexerState: program.compressLexerState,
  compressSymbol: program.compressSymbol,
};

var outFile = program.output
  ? program.output
  : path.basename(grammar, '-grammar.js');

var grammarBaseName = program.library || '$parser';

const mode = program.mode || 'lalr';

if (!ConsMap[mode]) {
  throw new Error('Unsupported mode: ' + mode);
}

var modulePath = program.output
  ? path.resolve(outFile)
  : path.resolve(grammar, '../' + outFile + '.js');

var codeTemplate = `
/*
Generated By kison v${pkg.version}

Generate time: ${new Date() + ''}
*/
 var ${grammarBaseName} = ${placehoder};
`;

if (program.es) {
  codeTemplate += `
   export default ${grammarBaseName};
`;
} else {
  codeTemplate += `
 if(typeof module !== 'undefined') {
   module.exports = ${grammarBaseName};
 }
`;
}

function myBabel(str: string) {
  try {
    require('@babel/core');
    require('@babel/preset-env');
  } catch (e) {
    console.log(
      'Info: you need to install @babel/core@7.x and @babel/preset-env@7.x manually so kison will use it to trans generated code.\n',
    );
    return str;
  }
  const pkg = require('@babel/core/package.json');
  if (!pkg.version.startsWith('7.')) {
    return str;
  }
  var babel = require('@babel/core');
  let transformRet;
  try {
    transformRet = babel.transformSync(str, {
      presets: [
        [
          require.resolve('@babel/preset-env'),
          {
            loose: true,
          },
        ],
      ],
    }); // => { code, map, ast }
  } catch (e) {
    console.log(e);
    return str;
  }
  return transformRet.code;
}

function myJsBeautify(str: string) {
  let prettier;
  try {
    prettier = require('prettier');
  } catch (e) {
    console.log(
      'Info: you can install prettier manually so kison will use it to format generated code.\n',
    );
    return str;
  }
  try {
    return prettier.format(str, {
      parser: 'babel',
    });
  } catch (e) {
    console.log(e);
  }
  return str;
}

async function bundleConfigFile(fileName: string): Promise<string> {
  const result = await build({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    outfile: 'out.js',
    write: false,
    platform: 'node',
    bundle: true,
    format: 'cjs',
    sourcemap: 'inline',
    metafile: true,
    plugins: [
      {
        name: 'externalize-deps',
        setup(build) {
          build.onResolve({ filter: /.*/ }, (args) => {
            const id = args.path;
            if (id[0] !== '.' && !path.isAbsolute(id)) {
              return {
                external: true,
              };
            }
          });
        },
      },
      {
        name: 'replace-import-meta',
        setup(build) {
          build.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
            const contents = await fs.promises.readFile(args.path, 'utf8');
            return {
              loader: args.path.endsWith('.ts') ? 'ts' : 'js',
              contents: contents
                .replace(
                  /\bimport\.meta\.url\b/g,
                  JSON.stringify(`file://${args.path}`),
                )
                .replace(
                  /\b__dirname\b/g,
                  JSON.stringify(path.dirname(args.path)),
                )
                .replace(/\b__filename\b/g, JSON.stringify(args.path)),
            };
          });
        },
      },
    ],
  });
  const { text } = result.outputFiles[0];
  return text;
}

async function genParser() {
  var grammarObj;
  if (grammar.endsWith('.js')) {
    grammarObj = require(grammar);
  } else {
    const code = await bundleConfigFile(grammar);
    const newFile = grammar.replace(/\.\w+$/, '.js');
    fs.writeFileSync(newFile, code);
    grammarObj = require(newFile);
    grammarObj = grammarObj.default || grammarObj;
    fs.unlinkSync(newFile);
  }

  if (typeof grammarObj === 'function') {
    grammarObj = grammarObj(KisonOptions);
  }

  const Cons = ConsMap[mode];

  console.info('start generate grammar module: ' + modulePath + '\n');
  var start = Date.now();

  const instance = new Cons(grammarObj);

  if (program.declaration && instance.genDTs) {
    let output = program.declarationDir;
    output = typeof output === 'string' ? output : path.dirname(outFile);
    output = path.resolve(output);
    const file = path.join(
      output,
      path.basename(outFile, path.extname(outFile)) + '.d.ts',
    );
    const baseDts = fs.readFileSync(
      path.join(__dirname, './parser.d.ts'),
      'utf-8',
    );
    let astNodeUserDataTypesPath = program.astNodeUserDataTypes;
    let astNodeUserDataTypes;
    if (astNodeUserDataTypesPath) {
      astNodeUserDataTypesPath = path.resolve(
        astNodeUserDataTypesPath + '.d.ts',
      );
      astNodeUserDataTypes = fs.readFileSync(astNodeUserDataTypesPath, 'utf-8');
    }
    const dts = instance.genDTs(baseDts, astNodeUserDataTypes);
    if (dts) {
      fs.writeFileSync(file, dts);
    }
  }

  if (program.bnf && instance.toBNF) {
    const bnf = instance.toBNF();
    let output = program.bnf;
    if (typeof output === 'string') {
      output = path.resolve(output);
      fs.writeFileSync(output, bnf);
    } else {
      console.log('');
      console.log(bnf);
      console.log('');
    }
  }

  /*jshint evil:true*/

  var code = instance.genCode(kisonCfg);

  var moduleCode = codeTemplate.replace(placehoder, () => code);

  if (program.babel) {
    moduleCode = myBabel(moduleCode);
  }

  moduleCode = myJsBeautify(moduleCode);

  fs.writeFileSync(modulePath, moduleCode, encoding);

  console.info(
    'generate grammar module: ' +
      modulePath +
      ' at ' +
      new Date().toLocaleString(),
  );
  console.log();
  console.info('duration: ' + (Date.now() - start) + 'ms');
  if (program.verbose) {
    console.log();
    console.log();
    console.log();
    console.log('******************* table');
    console.log(instance.visualizeTable());
  }
}

genParser();
