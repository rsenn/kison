#!/usr/bin/env node

/**
 * Generate parser function using LALR algorithm.
 * @author yiminghe@gmail.com
 */

var Utils = require('modulex-util'),
  KISON = require('../lib/'),
  fs = require('fs'),
  path = require('path'),
  encoding = 'utf-8';

const ConsMap = {
  ll: KISON.LLGrammar,
  lalr: KISON.LALRGrammar,
  llk: KISON.LLKGrammar,
};
const placehoder = '__KISON___GENERATED__CODE__';

var program = require('commander');
program
  .option('-g, --grammar <grammar>', 'Set kison grammar file')
  .option('-o, --output [file]', 'output file path')
  .option('--library [library]', 'library name')
  .option('--bnf [bnf]', 'bnf file')
  .option('--declaration [declaration]', 'declaration')
  .option('--declarationDir [declarationDir]', 'declarationDir')
  .option('-m, --mode [mode]', 'lalr or ll')
  .option('-b, --babel [babel]', 'use babel')
  .option('-v, --verbose [verbose]', 'verbose')
  .option('-w, --watch [watch]', 'Watch grammar file change')
  .option('--es [es]', 'generate es module')
  // defaults bool true
  .option('--no-compressSymbol', 'Set compress symbol')
  .option('--no-compressLexerState', 'Set compress lexer state')
  .parse(process.argv);

var options = program.options;

var grammar = path.resolve(program.grammar);

options.forEach(function (o) {
  var name = o.name();
  if (o.required && !(name in program)) {
    program.optionMissingArgument(o);
  }
});

var kisonCfg = {
  compressLexerState: program.compressLexerState,
  compressSymbol: program.compressSymbol,
};

var outFile = program.output
  ? program.output
  : path.basename(grammar, '-grammar.js');

var grammarBaseName = program.library || '$parser';

const mode = program.mode || 'lalr';

if (!ConsMap[mode]) {
  throw new Error('Unsupported mode: ' + mode);
}

var modulePath = program.output
  ? path.resolve(outFile)
  : path.resolve(grammar, '../' + outFile + '.js');

const pkg = require('../package.json');

var codeTemplate = `
/*
Generated By kison v${pkg.version}

Generate time: ${new Date() + ''}
*/
  var ${grammarBaseName} = ${placehoder};
`;

if (program.es) {
  codeTemplate += `
    export default ${grammarBaseName};
`;
} else {
  codeTemplate += `
  if(typeof module !== 'undefined') {
    module.exports = ${grammarBaseName};
  }
`;
}

function myBabel(str) {
  try {
    require('@babel/core');
    require('@babel/preset-env');
  } catch (e) {
    console.log(
      'Info: you need to install @babel/core@7.x and @babel/preset-env@7.x manually so kison will use it to trans generated code.\n',
    );
    return str;
  }
  const pkg = require('@babel/core/package.json');
  if (!pkg.version.startsWith('7.')) {
    return str;
  }
  var babel = require('@babel/core');
  let transformRet;
  try {
    transformRet = babel.transformSync(str, {
      presets: [
        [
          require.resolve('@babel/preset-env'),
          {
            loose: true,
          },
        ],
      ],
    }); // => { code, map, ast }
  } catch (e) {
    console.log(e);
    return str;
  }
  return transformRet.code;
}

function myJsBeautify(str) {
  let prettier;
  try {
    prettier = require('prettier');
  } catch (e) {
    console.log(
      'Info: you can install prettier manually so kison will use it to format generated code.\n',
    );
    return str;
  }
  try {
    return prettier.format(str, {
      parser: 'babel',
    });
  } catch (e) {
    console.log(e);
  }
  return str;
}

function genParser() {
  var grammarObj = require(grammar);

  if (typeof grammarObj === 'function') {
    grammarObj = grammarObj();
  }

  const Cons = ConsMap[mode];

  console.info('start generate grammar module: ' + modulePath + '\n');
  var start = Date.now();

  const instance = new Cons(grammarObj);

  if (program.declaration && instance.genDTs) {
    let output = program.declarationDir;
    output = typeof output === 'string' ? output : path.dirname(outFile);
    output = path.resolve(output);
    const file = path.join(
      output,
      path.basename(outFile, path.extname(outFile)) + '.d.ts',
    );
    const baseDts = fs.readFileSync(
      path.join(__dirname, '../lib/ll/parser.d.ts'),
      'utf-8',
    );
    const dts = instance.genDTs(baseDts);
    if (dts) {
      fs.writeFileSync(file, dts);
    }
  }

  if (program.bnf && instance.toBNF) {
    const bnf = instance.toBNF();
    let output = program.bnf;
    if (typeof output === 'string') {
      output = path.resolve(output);
      fs.writeFileSync(output, bnf);
    } else {
      console.log('');
      console.log(bnf);
      console.log('');
    }
  }

  /*jshint evil:true*/

  var code = instance.genCode(kisonCfg);

  var moduleCode = codeTemplate.replace(placehoder, () => code);

  if (program.babel) {
    moduleCode = myBabel(moduleCode);
  }

  moduleCode = myJsBeautify(moduleCode);

  fs.writeFileSync(modulePath, moduleCode, encoding);

  console.info(
    'generate grammar module: ' +
      modulePath +
      ' at ' +
      new Date().toLocaleString(),
  );
  console.log();
  console.info('duration: ' + (Date.now() - start) + 'ms');
  if (program.verbose) {
    console.log();
    console.log();
    console.log();
    console.log('******************* table');
    console.log(instance.visualizeTable());
  }
}

var bufferCompile = Utils.buffer(genParser);

if (program.watch) {
  fs.watch(grammar, bufferCompile);
  genParser();
} else {
  genParser();
}
