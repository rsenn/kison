
/*
Generated By kison v0.4.10

Generate time: Thu Jul 22 2021 16:19:28 GMT+0800 (中国标准时间)
*/
  var index = (function(undefined){
  "use strict";

function _extends() {
  _extends =
    Object.assign ||
    function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
  return _extends.apply(this, arguments);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it =
    (typeof Symbol !== "undefined" && o[Symbol.iterator]) || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (
    Array.isArray(o) ||
    (it = _unsupportedIterableToArray(o)) ||
    (allowArrayLike && o && typeof o.length === "number")
  ) {
    if (it) o = it;
    var i = 0;
    return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError(
    "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
  );
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

var my = {
  c0: 48,
  c9: 57,
  createMatchString: function createMatchString(str, lexer) {
    var input = lexer.input;

    if (input.lastIndexOf(str, str.length) !== 0) {
      return false;
    }

    return [str];
  },
  createMatchCharRange: function createMatchCharRange(range, lexer) {
    var _char = lexer.input[0];

    var charCode = _char.charCodeAt(0);

    for (
      var _iterator = _createForOfIteratorHelperLoose(range), _step;
      !(_step = _iterator()).done;

    ) {
      var r = _step.value;

      if (r.length == 1) {
        if (r[0] === charCode) {
          return [_char];
        }
      } else if (charCode >= r[0] || charCode <= r[1]) {
        return [_char];
      }
    }

    return false;
  },
  matchBackreference: function matchBackreference(lexer) {
    var input = lexer.input;

    if (input[0] !== "\\") {
      return false;
    }

    var match = my.matchNumber({
      input: input.slice(1)
    });

    if (match === false) {
      return false;
    }

    match[0] = "\\" + match[0];
    return match;
  },
  matchNumber: function matchNumber(lexer) {
    var index = 0;
    var match = [];
    var input = lexer.input;
    var l = input.length;

    while (index < l) {
      var _char2 = input[index];
      var codeCode = input.charCodeAt(index);

      if (codeCode < my.c0 || codeCode > my.c9) {
        break;
      }

      match.push(_char2);
      index++;
    }

    return match.length ? [match.join("")] : false;
  }
};

function mix(to, from) {
  for (var f in from) {
    to[f] = from[f];
  }
}

function isArray(obj) {
  return "[object Array]" === Object.prototype.toString.call(obj);
}

function each(object, fn, context) {
  if (object) {
    var key,
      val,
      length,
      i = 0;
    context = context || null;

    if (!isArray(object)) {
      for (key in object) {
        // can not use hasOwnProperty
        if (fn.call(context, object[key], key, object) === false) {
          break;
        }
      }
    } else {
      length = object.length;

      for (val = object[0]; i < length; val = object[++i]) {
        if (fn.call(context, val, i, object) === false) {
          break;
        }
      }
    }
  }
}

function inArray(item, arr) {
  for (var i = 0, l = arr.length; i < l; i++) {
    if (arr[i] === item) {
      return true;
    }
  }

  return false;
}

var Lexer = function Lexer(cfg) {
  /*
     lex rules.
     @type {Object[]}
     @example
     [
     {
     regexp:'\\w+',
     state:['xx'],
     token:'c',
     // this => lex
     action:function(){}
     }
     ]
     */
  this.rules = [];
  this.tokensQueue = [];
  mix(this, cfg);
  this.rules = [].concat(this.rules);
  this.userData = {};
  var errorRule = (this.errorRule = {
    regexp: this.matchAny,
    token: Lexer.STATIC.UNKNOWN_TOKEN
  });
  var ruleIndexMap = (this.ruleIndexMap = {
    token: 0,
    regexp: 1,
    action: 2,
    filter: 3,
    state: 4
  });
  var errorRuleCompress = (this.errorRuleCompress = []);
  errorRuleCompress[ruleIndexMap.token] = errorRule.token;
  errorRuleCompress[ruleIndexMap.regexp] = errorRule.regexp;
  this.resetInput(this.input);
};

Lexer.prototype = {
  matchAny: function matchAny() {
    return this.input.length ? this.input[0] : false;
  },
  resetInput: function resetInput(input) {
    mix(this, {
      userData: {},
      input: input,
      matched: "",
      stateStack: [Lexer.STATIC.INITIAL_STATE],
      match: "",
      text: "",
      firstLine: 1,
      lineNumber: 1,
      lastLine: 1,
      start: 0,
      end: 0,
      firstColumn: 1,
      lastColumn: 1
    });
  },
  mapEndSymbol: function mapEndSymbol() {
    return this.mapSymbol(Lexer.STATIC.EOF_TOKEN);
  },
  mapHiddenSymbol: function mapHiddenSymbol() {
    return this.mapSymbol(Lexer.STATIC.HIDDEN_TOKEN);
  },
  getRuleItem: function getRuleItem(rule, itemType) {
    if (this.isCompress) {
      return rule[this.ruleIndexMap[itemType]];
    } else {
      return rule[itemType];
    }
  },
  getCurrentRules: function getCurrentRules() {
    var _this = this;

    var currentState = this.stateStack[this.stateStack.length - 1],
      rules = [];

    if (this.mapState) {
      currentState = this.mapState(currentState);
    }

    each(this.rules, function(r) {
      var filter = _this.getRuleItem(r, "filter");

      if (filter) {
        if (filter.call(_this)) {
          rules.push(r);
        }

        return;
      }

      var state = _this.getRuleItem(r, "state");

      if (!state) {
        if (currentState === Lexer.STATIC.INITIAL_STATE) {
          rules.push(r);
        }
      } else if (inArray(currentState, state)) {
        rules.push(r);
      }
    });

    if (this.isCompress) {
      rules.push(this.errorRuleCompress);
    } else {
      rules.push(this.errorRule);
    }

    return rules;
  },
  peekState: function peekState(n) {
    n = n || 1;
    return this.stateStack[this.stateStack.length - n];
  },
  pushState: function pushState(state) {
    this.stateStack.push(state);
  },
  popState: function popState(num) {
    num = num || 1;
    var ret;

    while (num--) {
      ret = this.stateStack.pop();
    }

    return ret;
  },
  showDebugInfo: function showDebugInfo() {
    var DEBUG_CONTEXT_LIMIT = Lexer.STATIC.DEBUG_CONTEXT_LIMIT;
    var matched = this.matched,
      match = this.match,
      input = this.input;
    matched = matched.slice(0, matched.length - match.length);
    var past =
        (matched.length > DEBUG_CONTEXT_LIMIT ? "..." : "") +
        matched
          .slice(0 - DEBUG_CONTEXT_LIMIT)
          .split("\n")
          .join(" "),
      next = match + input; //#JSCOVERAGE_ENDIF

    next =
      next
        .slice(0, DEBUG_CONTEXT_LIMIT)
        .split("\n")
        .join(" ") + (next.length > DEBUG_CONTEXT_LIMIT ? "..." : "");
    return past + next + "\n" + new Array(past.length + 1).join("-") + "^";
  },
  mapSymbol: function mapSymbol(t) {
    return this.symbolMap[t];
  },
  mapReverseSymbol: function mapReverseSymbol(rs) {
    var symbolMap = this.symbolMap,
      reverseSymbolMap = this.reverseSymbolMap;

    if (!reverseSymbolMap && symbolMap) {
      reverseSymbolMap = this.reverseSymbolMap = {};

      for (var i in symbolMap) {
        reverseSymbolMap[symbolMap[i]] = i;
      }
    }

    if (reverseSymbolMap) {
      return reverseSymbolMap[rs] || rs;
    } else {
      return rs;
    }
  },
  toJSON: function toJSON() {
    return {
      text: this.text,
      firstLine: this.firstLine,
      firstColumn: this.firstColumn,
      lastLine: this.lastLine,
      lastColumn: this.lastColumn,
      token: this.token,
      start: this.start,
      end: this.end
    };
  },
  peek: function peek(skipHidden) {
    var token = this.lex(skipHidden, true);

    if (this.tokensQueue.indexOf(token) === -1) {
      this.tokensQueue.push(token);
    }

    return token;
  },
  matchRegExp: function matchRegExp(regexp) {
    if (regexp.test) {
      return this.input.match(regexp);
    }

    return regexp.call(this, this);
  },
  lex: function lex(skipHidden, reserveQueue) {
    if (skipHidden === undefined) {
      skipHidden = true;
    }

    var tokensQueue = this.tokensQueue;

    if (reserveQueue) {
      for (var _i = 0; _i < tokensQueue.length; _i++) {
        var _token = tokensQueue[_i];

        if (skipHidden && _token.t === this.mapHiddenSymbol()) {
          continue;
        }

        return _token;
      }
    } else {
      while (tokensQueue.length) {
        var _token2 = tokensQueue.shift();

        if (skipHidden && _token2.t === this.mapHiddenSymbol()) {
          continue;
        }

        return _token2;
      }
    }

    var i,
      rule,
      m,
      ret,
      lines,
      rules = this.getCurrentRules();
    var _this$env = this.env,
      env = _this$env === void 0 ? this.defaultEnv : _this$env,
      input = this.input;
    this.match = this.text = "";

    if (!input) {
      return {
        t: this.mapEndSymbol(),
        token: Lexer.STATIC.EOF_TOKEN,
        start: this.end,
        end: this.end,
        firstLine: this.lastLine,
        firstColumn: this.lastColumn,
        lastLine: this.lastLine,
        lastColumn: this.lastColumn
      };
    }

    for (i = 0; i < rules.length; i++) {
      rule = rules[i];
      var regexp = this.getRuleItem(rule, "regexp"),
        token = this.getRuleItem(rule, "token"),
        action = this.getRuleItem(rule, "action");

      if (
        typeof regexp !== "function" &&
        regexp &&
        env &&
        typeof regexp.test !== "function"
      ) {
        regexp = regexp[env];
      }

      if (!regexp) {
        continue;
      } //#JSCOVERAGE_ENDIF

      if ((m = this.matchRegExp(regexp))) {
        this.start = this.end;
        this.end += m[0].length;
        lines = m[0].split("\n");
        lines.shift();
        this.lineNumber += lines.length;
        var position = {
          start: this.start,
          end: this.end,
          firstLine: this.lastLine,
          lastLine: this.lineNumber,
          firstColumn: this.lastColumn,
          lastColumn: lines.length
            ? lines[lines.length - 1].length
            : this.lastColumn + m[0].length
        };
        mix(this, position);
        var match; // for error report

        match = this.match = m[0]; // all matches

        this.matches = m; // may change by user

        this.text = match; // matched content utils now

        this.matched += match;
        ret = action && action.call(this);

        if (ret === undefined) {
          ret = token;
        } else {
          ret = this.mapSymbol(ret);
        }

        input = input.slice(match.length);
        this.input = input;

        if (ret) {
          this.token = this.mapReverseSymbol(ret);

          if (ret === this.mapHiddenSymbol() && skipHidden) {
            return this.lex();
          }

          return _extends(
            {
              text: this.text,
              token: this.token,
              t: ret
            },
            position
          );
        } else {
          // ignore
          return this.lex();
        }
      }
    }
  }
};
Lexer.STATIC = {
  INITIAL_STATE: "I",
  DEBUG_CONTEXT_LIMIT: 20,
  EOF_TOKEN: "$EOF",
  UNKNOWN_TOKEN: "$UNKNOWN",
  HIDDEN_TOKEN: "$HIDDEN"
};
var lexer = new Lexer({
  rules: [
    ["a", my.createMatchString.bind(undefined, "$")],
    ["b", my.createMatchString.bind(undefined, ",")],
    ["c", my.createMatchString.bind(undefined, "^")],
    ["d", my.createMatchString.bind(undefined, "?:")],
    ["e", my.createMatchString.bind(undefined, "?")],
    ["f", my.createMatchString.bind(undefined, "(")],
    ["g", my.createMatchString.bind(undefined, ")")],
    ["h", my.createMatchString.bind(undefined, "{")],
    ["i", my.createMatchString.bind(undefined, "}")],
    ["j", my.createMatchString.bind(undefined, "[")],
    ["k", my.createMatchString.bind(undefined, "]")],
    ["l", my.createMatchString.bind(undefined, "-")],
    ["m", my.createMatchString.bind(undefined, "|")],
    ["n", my.createMatchString.bind(undefined, "*")],
    ["o", my.createMatchString.bind(undefined, "+")],
    ["p", my.createMatchString.bind(undefined, ".")],
    ["q", my.createMatchString.bind(undefined, "\\w")],
    ["r", my.createMatchString.bind(undefined, "\\W")],
    ["s", my.createMatchString.bind(undefined, "\\d")],
    ["t", my.createMatchString.bind(undefined, "\\D")],
    ["u", my.matchBackreference],
    ["v", my.createMatchString.bind(undefined, "\\b")],
    ["w", my.createMatchString.bind(undefined, "\\B")],
    ["x", my.createMatchString.bind(undefined, "\\A")],
    ["y", my.createMatchString.bind(undefined, "\\z")],
    ["z", my.createMatchString.bind(undefined, "\\Z")],
    ["aa", my.createMatchString.bind(undefined, "\\G")],
    ["ab", my.matchNumber],
    [
      "ac",
      my.createMatchCharRange.bind(undefined, [
        [9],
        [10],
        [13],
        [32, 55295],
        [57344, 65533],
        [65536, 1114111]
      ])
    ]
  ],
  isCompress: 1,
  defaultEnv: undefined
});
var parser = {
  productions: [
    ["ad", ["c", "ae"]],
    ["ad", ["ae"]],
    ["af", ["m", "ag", "af"]],
    ["af", []],
    ["ae", ["ag", "af"]],
    ["ah", ["ai", "ah"]],
    ["ah", []],
    ["ag", ["ai", "ah"]],
    ["ai", ["aj"]],
    ["ai", ["ak"]],
    ["ai", ["al"]],
    ["ai", ["u"]],
    ["ak", ["f", "am"]],
    ["an", ["ao"]],
    ["an", []],
    ["am", ["ae", "g", "an"]],
    ["am", ["d", "ae", "g", "an"]],
    ["ap", []],
    ["ap", ["ao"]],
    ["aj", ["aq", "ap"]],
    ["aq", ["p"]],
    ["aq", ["ar"]],
    ["aq", ["ac"]],
    ["ar", ["as"]],
    ["ar", ["at"]],
    ["au", ["av", "au"]],
    ["au", []],
    ["aw", ["av", "au"]],
    ["ax", ["aw", "k"]],
    ["ax", ["c", "aw", "k"]],
    ["as", ["j", "ax"]],
    ["av", ["ay"]],
    ["az", []],
    ["av", ["at", "az"]],
    ["at", ["al"]],
    ["at", ["r"]],
    ["at", ["s"]],
    ["at", ["t"]],
    ["ba", ["l", "ac"]],
    ["ba", []],
    ["ay", ["ac", "ba"]],
    ["bb", []],
    ["bb", ["e"]],
    ["ao", ["bc", "bb"]],
    ["bc", ["n"]],
    ["bc", ["o"]],
    ["bc", ["e"]],
    ["bc", ["bd"]],
    ["be", ["b", "ab", "i"]],
    ["be", ["i"]],
    ["bc", ["h", "ab", "be"]],
    ["al", ["v"]],
    ["al", ["w"]],
    ["al", ["x"]],
    ["al", ["y"]],
    ["al", ["z"]],
    ["al", ["aa"]],
    ["al", ["a"]]
  ],
  productionIndexMap: {
    symbol: 0,
    rhs: 1,
    action: 2,
    label: 3
  },
  getProductionItemByType: function getProductionItemByType(p, itemType) {
    if (this.isCompress) {
      return p[this.productionIndexMap[itemType]];
    }

    return p[itemType];
  },
  getProductionSymbol: function getProductionSymbol(p) {
    return this.getProductionItemByType(p, "symbol");
  },
  getProductionRhs: function getProductionRhs(p) {
    return this.getProductionItemByType(p, "rhs");
  },
  getProductionAction: function getProductionAction(p) {
    return this.getProductionItemByType(p, "action");
  },
  getProductionLabel: function getProductionLabel(p) {
    return this.getProductionItemByType(p, "label");
  },
  isCompress: 1
};
parser.getProductionSymbol = parser.getProductionSymbol.bind(parser);
parser.getProductionRhs = parser.getProductionRhs.bind(parser);
parser.getProductionAction = parser.getProductionAction.bind(parser);
parser.getProductionLabel = parser.getProductionLabel.bind(parser);
parser.lexer = lexer;
lexer.symbolMap = {
  $UNKNOWN: "$UNKNOWN",
  $HIDDEN: "$HIDDEN",
  $EOF: "$EOF",
  $: "a",
  ",": "b",
  "^": "c",
  "?:": "d",
  "?": "e",
  "(": "f",
  ")": "g",
  "{": "h",
  "}": "i",
  "[": "j",
  "]": "k",
  "-": "l",
  "|": "m",
  "*": "n",
  "+": "o",
  ".": "p",
  characterClassAnyWord: "q",
  characterClassAnyWordInverted: "r",
  characterClassAnyDecimalDigit: "s",
  characterClassAnyDecimalDigitInverted: "t",
  backreference: "u",
  anchorWordBoundary: "v",
  anchorNonWordBoundary: "w",
  anchorStartOfStringOnly: "x",
  anchorEndOfStringOnlyNotNewline: "y",
  anchorEndOfStringOnly: "z",
  anchorPreviousMatchEnd: "aa",
  int: "ab",
  char: "ac",
  Regexp: "ad",
  Expression: "ae",
  Expression_: "af",
  SubExpression: "ag",
  SubExpression_: "ah",
  ExpressionItem: "ai",
  Match: "aj",
  Group: "ak",
  Anchor: "al",
  _Group: "am",
  __Group: "an",
  Quantifier: "ao",
  _Match: "ap",
  MatchItem: "aq",
  MatchCharacterClass: "ar",
  CharacterGroup: "as",
  CharacterClass: "at",
  CharacterGroupInner_: "au",
  CharacterGroupItem: "av",
  CharacterGroupInner: "aw",
  _CharacterGroup: "ax",
  CharacterRange: "ay",
  _CharacterGroupItem: "az",
  _CharacterRange: "ba",
  _Quantifier: "bb",
  QuantifierType: "bc",
  RangeQuantifier: "bd",
  _QuantifierType: "be"
};
var productionSkipEndSet = new Set([
  2,
  3,
  5,
  6,
  13,
  14,
  15,
  16,
  17,
  18,
  25,
  26,
  28,
  29,
  32,
  38,
  39,
  41,
  42,
  48,
  49
]);
var productionEndFlag = 2;
var productionReductionFlag = 1;

var isProductionEndFlag = function isProductionEndFlag(t) {
  return t === productionEndFlag;
};

var isProductionReductionFlag = function isProductionReductionFlag(t) {
  return t === productionReductionFlag;
};

parser.table = {
  ad: {
    c: 0,
    p: 1,
    j: 1,
    r: 1,
    s: 1,
    t: 1,
    ac: 1,
    f: 1,
    v: 1,
    w: 1,
    x: 1,
    y: 1,
    z: 1,
    aa: 1,
    a: 1,
    u: 1
  },
  af: {
    m: 2,
    $EOF: 3,
    g: 3
  },
  ae: {
    p: 4,
    j: 4,
    r: 4,
    s: 4,
    t: 4,
    ac: 4,
    f: 4,
    v: 4,
    w: 4,
    x: 4,
    y: 4,
    z: 4,
    aa: 4,
    a: 4,
    u: 4
  },
  ah: {
    p: 5,
    j: 5,
    r: 5,
    s: 5,
    t: 5,
    ac: 5,
    f: 5,
    v: 5,
    w: 5,
    x: 5,
    y: 5,
    z: 5,
    aa: 5,
    a: 5,
    u: 5,
    m: 6,
    $EOF: 6,
    g: 6
  },
  ag: {
    p: 7,
    j: 7,
    r: 7,
    s: 7,
    t: 7,
    ac: 7,
    f: 7,
    v: 7,
    w: 7,
    x: 7,
    y: 7,
    z: 7,
    aa: 7,
    a: 7,
    u: 7
  },
  ai: {
    p: 8,
    j: 8,
    v: 10,
    w: 10,
    x: 10,
    y: 10,
    z: 10,
    aa: 10,
    a: 10,
    r: 8,
    s: 8,
    t: 8,
    ac: 8,
    f: 9,
    u: 11
  },
  ak: {
    f: 12
  },
  an: {
    n: 13,
    o: 13,
    e: 13,
    h: 13,
    p: 14,
    j: 14,
    r: 14,
    s: 14,
    t: 14,
    ac: 14,
    f: 14,
    v: 14,
    w: 14,
    x: 14,
    y: 14,
    z: 14,
    aa: 14,
    a: 14,
    u: 14,
    m: 14,
    $EOF: 14,
    g: 14
  },
  am: {
    p: 15,
    j: 15,
    r: 15,
    s: 15,
    t: 15,
    ac: 15,
    f: 15,
    v: 15,
    w: 15,
    x: 15,
    y: 15,
    z: 15,
    aa: 15,
    a: 15,
    u: 15,
    d: 16
  },
  ap: {
    p: 17,
    j: 17,
    r: 17,
    s: 17,
    t: 17,
    ac: 17,
    f: 17,
    v: 17,
    w: 17,
    x: 17,
    y: 17,
    z: 17,
    aa: 17,
    a: 17,
    u: 17,
    m: 17,
    $EOF: 17,
    g: 17,
    n: 18,
    o: 18,
    e: 18,
    h: 18
  },
  aj: {
    p: 19,
    j: 19,
    v: 19,
    w: 19,
    x: 19,
    y: 19,
    z: 19,
    aa: 19,
    a: 19,
    r: 19,
    s: 19,
    t: 19,
    ac: 19
  },
  aq: {
    p: 20,
    j: 21,
    v: 21,
    w: 21,
    x: 21,
    y: 21,
    z: 21,
    aa: 21,
    a: 21,
    r: 21,
    s: 21,
    t: 21,
    ac: 22
  },
  ar: {
    j: 23,
    v: 24,
    w: 24,
    x: 24,
    y: 24,
    z: 24,
    aa: 24,
    a: 24,
    r: 24,
    s: 24,
    t: 24
  },
  au: {
    ac: 25,
    v: 25,
    w: 25,
    x: 25,
    y: 25,
    z: 25,
    aa: 25,
    a: 25,
    r: 25,
    s: 25,
    t: 25,
    k: 26
  },
  aw: {
    ac: 27,
    v: 27,
    w: 27,
    x: 27,
    y: 27,
    z: 27,
    aa: 27,
    a: 27,
    r: 27,
    s: 27,
    t: 27
  },
  ax: {
    ac: 28,
    v: 28,
    w: 28,
    x: 28,
    y: 28,
    z: 28,
    aa: 28,
    a: 28,
    r: 28,
    s: 28,
    t: 28,
    c: 29
  },
  as: {
    j: 30
  },
  av: {
    ac: 31,
    v: 33,
    w: 33,
    x: 33,
    y: 33,
    z: 33,
    aa: 33,
    a: 33,
    r: 33,
    s: 33,
    t: 33
  },
  az: {
    ac: 32,
    v: 32,
    w: 32,
    x: 32,
    y: 32,
    z: 32,
    aa: 32,
    a: 32,
    r: 32,
    s: 32,
    t: 32,
    k: 32
  },
  at: {
    v: 34,
    w: 34,
    x: 34,
    y: 34,
    z: 34,
    aa: 34,
    a: 34,
    r: 35,
    s: 36,
    t: 37
  },
  ba: {
    l: 38,
    ac: 39,
    v: 39,
    w: 39,
    x: 39,
    y: 39,
    z: 39,
    aa: 39,
    a: 39,
    r: 39,
    s: 39,
    t: 39,
    k: 39
  },
  ay: {
    ac: 40
  },
  bb: {
    p: 41,
    j: 41,
    r: 41,
    s: 41,
    t: 41,
    ac: 41,
    f: 41,
    v: 41,
    w: 41,
    x: 41,
    y: 41,
    z: 41,
    aa: 41,
    a: 41,
    u: 41,
    m: 41,
    $EOF: 41,
    g: 41,
    e: 42
  },
  ao: {
    n: 43,
    o: 43,
    e: 43,
    h: 43
  },
  bc: {
    n: 44,
    o: 45,
    e: 46,
    h: 50
  },
  be: {
    b: 48,
    i: 49
  },
  al: {
    v: 51,
    w: 52,
    x: 53,
    y: 54,
    z: 55,
    aa: 56,
    a: 57
  }
};

parser.parse = function parse(input, options) {
  var tokens = [];
  var recoveryTokens = [];
  var terminalNodes = [];

  var AstNode = /*#__PURE__*/ (function() {
    function AstNode(cfg) {
      Object.assign(this, cfg);

      if (cfg.children) {
        this.setChildren(cfg.children);
      }
    }

    var _proto = AstNode.prototype;

    _proto.addChild = function addChild(c) {
      this.addChildren([c]);
    };

    _proto.addChildren = function addChildren(cs) {
      var _this$children;

      (_this$children = this.children).push.apply(_this$children, cs);

      this.setChildren(this.children);
    };

    _proto.setChildren = function setChildren(cs) {
      if (!cs.length) {
        this.children = [];
        return;
      }

      var first = cs[0];
      var last = cs[cs.length - 1];
      this.start = first.start;
      this.end = last.end;
      this.firstLine = first.firstLine;
      this.lastLine = last.lastLine;
      this.firstColumn = first.firstColumn;
      this.lastColumn = last.lastColumn;
      this.children = cs;

      for (
        var _iterator2 = _createForOfIteratorHelperLoose(cs), _step2;
        !(_step2 = _iterator2()).done;

      ) {
        var c = _step2.value;
        c.parent = this;
      }
    };

    _proto.toJSON = function toJSON() {
      var ret = {};

      for (
        var _i2 = 0, _Object$keys = Object.keys(this);
        _i2 < _Object$keys.length;
        _i2++
      ) {
        var k = _Object$keys[_i2];

        if (k !== "parent" && k !== "t") {
          ret[k] = this[k];
        }
      }

      return ret;
    };

    return AstNode;
  })();

  function isExtraSymbol(ast) {
    return ast.children && !ast.children.length;
  }

  function peekStack(stack, n) {
    n = n || 1;
    return stack[stack.length - n];
  }

  function getTableVal(row, col) {
    return table[row] && table[row][col];
  }

  function noop() {}

  function getOriginalSymbol(s) {
    return lexer.mapReverseSymbol(s);
  }

  options = options || {};
  var error;
  var _options = options,
    onErrorRecovery = _options.onErrorRecovery,
    _options$onAction = _options.onAction,
    onAction = _options$onAction === void 0 ? noop : _options$onAction,
    lexerEnv = _options.lexerEnv;
  var lexer = this.lexer,
    table = this.table,
    productions = this.productions,
    getProductionSymbol = this.getProductionSymbol,
    getProductionRhs = this.getProductionRhs,
    getProductionLabel = this.getProductionLabel;
  lexer.env = lexerEnv;
  var symbolStack = [getProductionSymbol(productions[0])];
  var astStack = [
    new AstNode({
      children: []
    })
  ];
  lexer.resetInput(input);
  var token;
  var next;
  var currentToken;

  function getError() {
    var expected = getExpected();
    return (
      "syntax error at line " +
      lexer.lineNumber +
      ":\n" +
      lexer.showDebugInfo() +
      "\n" +
      (expected.length ? "expect " + expected.join(", ") : "") +
      "\n" +
      (currentToken ? "current token is " + currentToken.token : "")
    );
  }

  function cleanAst(ast) {
    if (ast.token || ast.error) {
      return ast;
    }

    if (ast.children) {
      var children = [];

      for (
        var _iterator3 = _createForOfIteratorHelperLoose(ast.children), _step3;
        !(_step3 = _iterator3()).done;

      ) {
        var c = _step3.value;

        if (cleanAst(c)) {
          children.push(c);
        }
      }

      ast.setChildren(children);
    }

    if (!ast.children || !ast.children.length) {
      return null;
    }

    if (ast.children.length === 1) {
      var child = ast.children[0];

      if (
        (ast.label && child.label && ast.label === child.label) ||
        (!ast.label && !child.label && ast.symbol === child.symbol)
      ) {
        ast.setChildren(child.children);
        ast.symbol = child.symbol;
      }
    }

    return ast;
  }

  function getAst(raw) {
    var ast = astStack[0] && astStack[0].children && astStack[0].children[0];

    if (ast) {
      astStack[0].children.forEach(function(a) {
        return delete a.parent;
      });
    }

    if (raw) {
      return ast;
    }

    return ast && cleanAst(ast);
  }

  var topSymbol;
  var errorNode;
  var lastSymbol;

  function popSymbolStack() {
    var last = symbolStack.pop();

    if (typeof last === "string") {
      lastSymbol = last;
    }
  }

  function getExpected() {
    var s = topSymbol || lastSymbol;
    var ret = (table[s] && Object.keys(table[s])) || [];
    return ret.map(function(r) {
      return lexer.mapReverseSymbol(r);
    });
  }

  function closeAstWhenError() {
    errorNode = new AstNode(
      _extends(
        {
          error: error
        },
        error.lexer
      )
    );
    peekStack(astStack).addChild(errorNode);

    while (astStack.length !== 1) {
      var _ast = astStack.pop();

      if (_ast.symbol && isExtraSymbol(_ast)) {
        var topAst = peekStack(astStack);
        topAst.children.pop();
        topAst.addChildren(_ast.children);
      }
    }
  }

  var production;

  while (1) {
    topSymbol = peekStack(symbolStack);

    if (!topSymbol) {
      break;
    }

    while (
      isProductionEndFlag(topSymbol) ||
      isProductionReductionFlag(topSymbol)
    ) {
      var _ast2 = astStack.pop();

      if (isProductionReductionFlag(topSymbol)) {
        var stackTop = peekStack(astStack);
        var wrap = new AstNode({
          symbol: _ast2.symbol,
          children: [_ast2],
          label: _ast2.label
        });
        stackTop.children.pop();
        stackTop.addChild(wrap);
        astStack.push(wrap);
      }

      popSymbolStack();
      topSymbol = peekStack(symbolStack);

      if (!topSymbol) {
        break;
      }
    }

    if (typeof topSymbol === "string") {
      if (!token) {
        token = lexer.lex();
        tokens.push(token);
        recoveryTokens.push(token);
      }

      currentToken = token;

      if (topSymbol === token.t) {
        symbolStack.pop();
        var terminalNode = new AstNode(token);
        terminalNodes.push(terminalNode);
        var parent = peekStack(astStack);
        parent.addChild(terminalNode);
        token = null;
      } else if ((next = getTableVal(topSymbol, token.t)) !== undefined) {
        popSymbolStack();
        production = productions[next];

        if (productionSkipEndSet.has(next)) {
          symbolStack.push.apply(
            symbolStack,
            getProductionRhs(production)
              .concat()
              .reverse()
          );
        } else {
          var newAst = new AstNode({
            symbol: getOriginalSymbol(topSymbol),
            label: getProductionLabel(production),
            children: []
          });
          peekStack(astStack).addChild(newAst);
          astStack.push(newAst);
          symbolStack.push.apply(
            symbolStack,
            getProductionRhs(production)
              .concat(productionEndFlag)
              .reverse()
          );
        }
      } else {
        error = {
          errorMessage: getError(),
          expected: getExpected(),
          symbol: lexer.mapReverseSymbol(topSymbol),
          lexer: token
        };

        if (onErrorRecovery) {
          var recommendedAction = {};
          var nextToken = lexer.peek(); // should delete

          if (
            topSymbol === nextToken.t ||
            getTableVal(topSymbol, nextToken.t) !== undefined
          ) {
            recommendedAction.action = "del";
          } else if (error.expected.length) {
            recommendedAction.action = "add";
          }

          var _errorNode = new AstNode(
            _extends(
              {
                error: error
              },
              error.lexer
            )
          );

          peekStack(astStack).addChild(_errorNode);
          var recovery =
            onErrorRecovery(
              {
                errorNode: _errorNode,
                ast: getAst(true)
              },
              recommendedAction
            ) || {};
          var action = recovery.action;
          peekStack(astStack).children.pop();

          if (!action) {
            closeAstWhenError();
            break;
          }

          if (action === "del") {
            error.recovery = true;
            recoveryTokens.pop();
            token = null;
          } else if (action === "add") {
            error.recovery = true;
            token = _extends({}, token, {
              token: recovery.token,
              text: recovery.text,
              t: lexer.mapSymbol(recovery.token)
            });
            recoveryTokens.push(token);
          }
        } else {
          closeAstWhenError();
          break;
        }
      }
    }

    topSymbol = peekStack(symbolStack);

    while (topSymbol && typeof topSymbol === "function") {
      onAction({
        lexer: currentToken,
        action: topSymbol
      });
      popSymbolStack();
      topSymbol = peekStack(symbolStack);
    }

    if (!symbolStack.length) {
      break;
    }
  }

  if (!error && currentToken.t !== lexer.mapEndSymbol()) {
    error = {
      errorMessage: getError(),
      expected: getExpected(),
      symbol: lexer.mapReverseSymbol(topSymbol || lastSymbol),
      lexer: currentToken
    };
    closeAstWhenError();
  }

  var ast = getAst();
  return {
    ast: ast,
    tokens: tokens,
    recoveryTokens: recoveryTokens,
    errorNode: errorNode,
    error: error,
    terminalNodes: terminalNodes
  };
};

  return parser;
  })();

  if(typeof module !== 'undefined') {
    module.exports = index;
  }
