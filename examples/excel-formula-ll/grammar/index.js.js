
/*
Generated By kison v0.4.23

Generate time: Fri Sep 10 2021 12:36:16 GMT+0800 (中国标准时间)
*/
  var index.js = (function(undefined){var my = {
'markType': function(self, type, enter = true) {
    const { userData } = self;
    userData[type] = userData[type] || 0;
    if (enter) {
      ++userData[type];
    } else if (userData.inArray) {
      --userData[type];
    }
  }
,'last': function(arr) {
    return arr && arr[arr.length - 1];
  }
};
function mix(to, from) {
    for (var f in from) {
      to[f] = from[f];
    }
  }
function isArray(obj) {
    return "[object Array]" === Object.prototype.toString.call(obj);
  }
function each(object, fn, context) {
    if (object) {
      var key,
        val,
        length,
        i = 0;

      context = context || null;

      if (!isArray(object)) {
        for (key in object) {
          // can not use hasOwnProperty
          if (fn.call(context, object[key], key, object) === false) {
            break;
          }
        }
      } else {
        length = object.length;
        for (val = object[0]; i < length; val = object[++i]) {
          if (fn.call(context, val, i, object) === false) {
            break;
          }
        }
      }
    }
  }
function inArray(item, arr) {
    for (var i = 0, l = arr.length; i < l; i++) {
      if (arr[i] === item) {
        return true;
      }
    }
    return false;
  }
var Lexer = function(cfg) {
    if (Lexer.supportSticky === undefined) {
      try {
        Lexer.supportSticky = typeof /(?:)/.sticky == "boolean";
      } catch (e) {
        Lexer.supportSticky = false;
      }
    }

    const ruleIndexMap = (this.ruleIndexMap = {
      token: 0,
      regexp: 1,
      action: 2,
      filter: 3,
      state: 4
    });

    this.rules = [];
    this.defaultEnv = undefined;
    mix(this, cfg);
    this.rules = this.rules.concat();
    this.transformRules();
    this.userData = {};
    const errorRule = (this.errorRule = {
      regexp: this.matchAny,
      token: Lexer.STATIC.UNKNOWN_TOKEN
    });
    const errorRuleCompress = (this.errorRuleCompress = []);
    errorRuleCompress[ruleIndexMap.token] = errorRule.token;
    errorRuleCompress[ruleIndexMap.regexp] = errorRule.regexp;
    this.resetInput(this.input);
    this.options = {};
  };
Lexer.prototype= {
'transformRegExp': function(obj, p, disableSticky) {
    const pattern = obj[p];
    if (pattern.test) {
      let source = pattern.source;
      if (source.startsWith("^")) {
        source = source.slice(1);
      }
      var flags = Lexer.supportSticky && !disableSticky ? "gy" : "g";
      if (pattern.multiline) flags += "m";
      if (pattern.ignoreCase) flags += "i";
      if (pattern.unicode) flags += "u";
      obj[p] = new RegExp(source, flags);
    } else if (typeof pattern === "object") {
      for (const k of Object.keys(pattern)) {
        this.transformRegExp(pattern, k);
      }
    }
  }
,'transformRules': function() {
    if (Lexer.supportSticky) {
      const regIndex = this.isCompress ? this.ruleIndexMap.regexp : "regexp";
      for (const r of this.rules) {
        this.transformRegExp(r, regIndex);
      }
    }
  }
,'matchAny': function() {
    return this.end < this.input.length ? this.input.charAt(this.end) : false;
  }
,'resetInput': function(input) {
    this.tokensQueue = [];
    this.tokens = [];
    this.userData = {};
    this.input = input;
    this.matched = "";
    this.stateStack = [Lexer.STATIC.INITIAL_STATE];
    this.match = "";
    this.text = "";
    this.firstLine = 1;
    this.lineNumber = 1;
    this.lastLine = 1;
    this.start = 0;
    this.end = 0;
    this.firstColumn = 1;
    this.lastColumn = 1;
  }
,'mapEndSymbol': function() {
    return this.mapSymbol(Lexer.STATIC.EOF_TOKEN);
  }
,'mapHiddenSymbol': function() {
    return this.mapSymbol(Lexer.STATIC.HIDDEN_TOKEN);
  }
,'getRuleItem': function(rule, itemType) {
    if (this.isCompress) {
      return rule[this.ruleIndexMap[itemType]];
    } else {
      return rule[itemType];
    }
  }
,'getCurrentRules': function() {
    var currentState = this.stateStack[this.stateStack.length - 1],
      rules = [];
    if (this.mapState) {
      currentState = this.mapState(currentState);
    }
    each(this.rules, r => {
      var filter = this.getRuleItem(r, "filter");
      if (filter) {
        if (filter.call(this)) {
          rules.push(r);
        }
        return;
      }
      var state = this.getRuleItem(r, "state");
      if (!state) {
        if (currentState === Lexer.STATIC.INITIAL_STATE) {
          rules.push(r);
        }
      } else if (inArray(currentState, state)) {
        rules.push(r);
      }
    });
    if (this.isCompress) {
      rules.push(this.errorRuleCompress);
    } else {
      rules.push(this.errorRule);
    }
    return rules;
  }
,'peekState': function(n) {
    n = n || 1;
    return this.stateStack[this.stateStack.length - n];
  }
,'pushState': function(state) {
    this.stateStack.push(state);
  }
,'popState': function(num) {
    num = num || 1;
    var ret;
    while (num--) {
      ret = this.stateStack.pop();
    }
    return ret;
  }
,'showDebugInfo': function() {
    var { DEBUG_CONTEXT_LIMIT } = Lexer.STATIC;
    var { matched, match, input } = this;

    matched = matched.slice(0, matched.length - match.length);
    var past =
        (matched.length > DEBUG_CONTEXT_LIMIT ? "..." : "") +
        matched
          .slice(0 - DEBUG_CONTEXT_LIMIT)
          .split("\n")
          .join(" "),
      next = match + input.slice(this.end);
    //#JSCOVERAGE_ENDIF
    next =
      next
        .slice(0, DEBUG_CONTEXT_LIMIT)
        .split("\n")
        .join(" ") + (next.length > DEBUG_CONTEXT_LIMIT ? "..." : "");
    return past + next + "\n" + new Array(past.length + 1).join("-") + "^";
  }
,'mapSymbol': function(t) {
  return this.symbolMap[t];
}
,'mapReverseSymbol': function(rs) {
    var { symbolMap, reverseSymbolMap } = this;
    if (!reverseSymbolMap && symbolMap) {
      reverseSymbolMap = this.reverseSymbolMap = {};
      for (var i in symbolMap) {
        reverseSymbolMap[symbolMap[i]] = i;
      }
    }
    if (reverseSymbolMap) {
      return reverseSymbolMap[rs] || rs;
    } else {
      return rs;
    }
  }
,'toJSON': function() {
    return {
      text: this.text,
      firstLine: this.firstLine,
      firstColumn: this.firstColumn,
      lastLine: this.lastLine,
      lastColumn: this.lastColumn,
      token: this.token,
      start: this.start,
      end: this.end
    };
  }
,'peek': function() {
    const token = this._lex(true);
    this.tokensQueue.push(token);
    if (token.token === Lexer.STATIC.HIDDEN_TOKEN) {
      return this.peek();
    }
    return token;
  }
,'matchRegExp': function(regexp) {
    if (regexp.test) {
      regexp.lastIndex = this.end;
      const ret = regexp.exec(this.input);
      if (ret && ret.index !== this.end) {
        return null;
      }
      return ret;
    }
    return regexp.call(this, this);
  }
,'lex': function() {
    const token = this._lex();
    this.tokens.push(token);
    if (token.token === Lexer.STATIC.HIDDEN_TOKEN) {
      return this.lex();
    }
    return token;
  }
,'nextChar': function(index = 0) {
    return this.getChar(this.end + index);
  }
,'nextCharCode': function(index = 0) {
    return this.getCharCode(this.end + index);
  }
,'nextStartsWith': function(search) {
    let { input, end } = this;
    const l = search.length;
    for (let i = 0; i < l; i++) {
      if (input.charAt(end++) !== search.charAt(i)) {
        return false;
      }
    }
    return true;
  }
,'nextCharAt': function(index) {
    return this.input.charAt(this.end + index);
  }
,'nextLength': function() {
    return this.input.length - this.end;
  }
,'getChar': function(index = 0) {
    if (this.options.unicode) {
      const code = this.input.codePointAt(index);
      if (code === undefined || isNaN(code)) {
        return "";
      }
      return String.fromCodePoint(code);
    }
    return this.input.charAt(index);
  }
,'getCharCode': function(index = 0) {
    if (this.options.unicode) {
      return this.input.codePointAt(index);
    }
    return this.input.charCodeAt(index);
  }
,'_lex': function(skipQueue) {
    if (!skipQueue) {
      const { tokensQueue } = this;
      while (tokensQueue.length) {
        const token = tokensQueue.shift();
        return token;
      }
    }
    var i,
      rule,
      m,
      ret,
      lines,
      rules = this.getCurrentRules();

    var { input } = this;

    var { env = this.defaultEnv } = this.options;

    this.match = this.text = "";

    if (this.end >= input.length) {
      return {
        t: this.mapEndSymbol(),
        token: Lexer.STATIC.EOF_TOKEN,
        start: this.end,
        end: this.end,
        firstLine: this.lastLine,
        firstColumn: this.lastColumn,
        lastLine: this.lastLine,
        lastColumn: this.lastColumn
      };
    }

    for (i = 0; i < rules.length; i++) {
      rule = rules[i];
      var regexp = this.getRuleItem(rule, "regexp"),
        token = this.getRuleItem(rule, "token"),
        action = this.getRuleItem(rule, "action");

      if (
        typeof regexp !== "function" &&
        regexp &&
        env &&
        typeof regexp.test !== "function"
      ) {
        regexp = regexp[env];
      }

      if (!regexp) {
        continue;
      }

      //#JSCOVERAGE_ENDIF
      if ((m = this.matchRegExp(regexp))) {
        this.start = this.end;
        this.end += m[0].length;
        lines = m[0].split("\n");
        lines.shift();
        this.lineNumber += lines.length;
        const position = {
          start: this.start,
          end: this.end,
          firstLine: this.lastLine,
          lastLine: this.lineNumber,
          firstColumn: this.lastColumn,
          lastColumn: lines.length
            ? lines[lines.length - 1].length + 1
            : this.lastColumn + m[0].length
        };

        mix(this, position);

        var match;
        // for error report
        match = this.match = m[0];

        // all matches
        this.matches = m;
        // may change by user
        this.text = match;
        // matched content utils now
        this.matched += match;
        ret = action && action.call(this);

        if (ret === undefined) {
          ret = token;
        } else {
          ret = this.mapSymbol(ret);
        }

        if (ret) {
          this.token = this.mapReverseSymbol(ret);
          return {
            text: this.text,
            token: this.token,
            t: ret,
            ...position
          };
        } else {
          // ignore
          return this._lex(skipQueue);
        }
      }
    }
  }
};
Lexer.STATIC= {
'INITIAL_STATE': 'I'
,'DEBUG_CONTEXT_LIMIT': 20
,'EOF_TOKEN': '$EOF'
,'UNKNOWN_TOKEN': '$UNKNOWN'
,'HIDDEN_TOKEN': '$HIDDEN'
};
var lexer = new Lexer({
'rules': [['$HIDDEN', /\s+/g, undefined, undefined, ['s', 'I']], ['a', /\(/g, function() {
          const { userData } = this;
          userData.markParen = userData.markParen || [];
          const lastItem = my.last(userData.markParen);
          if (lastItem && lastItem.index === this.start) {
            return;
          }
          userData.markParen.push({ index: this.end, func: false });
        }], ['b', /\)/g, function() {
          const { userData } = this;
          userData.markParen = userData.markParen || [];
          userData.markParen.pop();
        }], ['c', /\{/g, function() {
          // array constants
          my.markType(this, "a");
        }], ['d', /=/g], ['e', /<=/g], ['f', />=/g], ['g', /<>/g], ['h', />/g], ['i', /</g], ['j', /\+/g], ['k', /\-/g], ['l', /\*/g], ['m', /\//g], ['n', /\^/g], ['o', /&/g], ['p', /%/g], ['q', /\}/g, function() {
          my.markType(this, "a", false);
        }], ['r', /,/g, undefined, undefined, ['s']], ['s', /\[#('.|[^\]#])+\]/g, undefined, undefined, ['s', 'I']], ['t', /@/g, undefined, undefined, ['s']], ['u', /(?:(?:(?:\[(?:'.|[^\]'#])+\])(?:\:(?:\[(?:'.|[^\]'#])+\]))?)|(?:'.|[^\]#'])+)/g, undefined, undefined, ['s']], ['v', /\[/g, function() {
          this.pushState("s");
        }, undefined, ['s', 'I']], ['w', /@/g], ['x', /\]/g, function() {
          this.popState();
        }, undefined, ['s']], ['y', {
'en': /[,;]/g
,'de': /[\\;]/g
}, undefined, function() {
          return !!this.userData.a;
        }], ['z', /,/g, undefined, function() {
          const lastItem = my.last(this.userData.markParen);
          return !lastItem || !lastItem.func;
        }], ['aa', /:/g], ['ab', {
'en': /,/g
,'de': /;/g
}], ['ac', /"(?:""|[^"])*"/g, function() {
          this.text = this.text.slice(1, -1).replace(/""/g, '"');
        }], ['ad', /(?:(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*)(?:\.(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*))*)(?=[(])/g, function() {
          const { userData } = this;
          userData.markParen = userData.markParen || [];
          userData.markParen.push({ index: this.end, func: true });
        }], ['ae', /#[A-Z0-9\/]+(!|\?)? /g], ['af', /(?:(?:(?:'(?:''|[^'])*')|(?:(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*)(?:\:(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*))?))!)?(?:(?:(?:\$?[A-Za-z]+\$?[0-9]+)(?:\s*\:\s*(?:\$?[A-Za-z]+\$?[0-9]+))?#?)|(?:\d+\:\d+))/g], ['ag', /(TRUE|FALSE)(?=\b)/gi], ['ah', /(?:(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*)(?:\.(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*))*)(?=[\[])/g], ['ai', /(?:(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*)(?:\.(?:[_A-Za-z一-龥]+[_A-Za-z_0-9一-龥]*))*)/g], ['aj', {
'en': /(?:0|[1-9][0-9]*)?\.(?:[0-9][0-9]*)(?:[eE][+-]?[0-9]+)?/g
,'de': /(?:0|[1-9][0-9]*)?,(?:[0-9][0-9]*)(?:[eE][+-]?[0-9]+)?/g
}], ['aj', /(?:0|[1-9][0-9]*)(?:[eE][+-]?[0-9]+)?/g]]
,'isCompress': 1
,'defaultEnv': 'en'
});
function lex(input, options = {}) {
  lexer.options = options;
  lexer.resetInput(input);
  while (lexer.lex().token !== Lexer.STATIC.EOF_TOKEN);
  return {
    tokens: lexer.tokens
  };
}
var parser = {
'productions': [['ak', ['al']], ['al', ['am'], undefined, 'single-exp'], ['an', ['d', 'ao', 1, 'an']], ['an', ['e', 'ao', 1, 'an']], ['an', ['f', 'ao', 1, 'an']], ['an', ['g', 'ao', 1, 'an']], ['an', ['h', 'ao', 1, 'an']], ['an', ['i', 'ao', 1, 'an']], ['an', []], ['am', ['ao', 1, 'an'], undefined, 'single-exp'], ['ap', ['j', 'aq', 1, 'ap']], ['ap', ['k', 'aq', 1, 'ap']], ['ap', []], ['ao', ['aq', 1, 'ap'], undefined, 'single-exp'], ['ar', ['l', 'as', 1, 'ar']], ['ar', ['m', 'as', 1, 'ar']], ['ar', []], ['aq', ['as', 1, 'ar'], undefined, 'single-exp'], ['at', ['n', 'au', 1, 'at']], ['at', []], ['as', ['au', 1, 'at'], undefined, 'single-exp'], ['av', ['o', 'aw', 1, 'av']], ['av', []], ['au', ['aw', 1, 'av'], undefined, 'single-exp'], ['ax', ['p', 1, 'ax']], ['ax', []], ['aw', ['ay', 1, 'ax'], undefined, 'single-exp'], ['ay', ['k', 'ay'], undefined, 'single-exp'], ['ay', ['j', 'ay'], undefined, 'single-exp'], ['ay', ['w', 'ay'], undefined, 'single-exp'], ['ay', ['az'], undefined, 'single-exp'], ['az', ['a', 'am', 'b'], undefined, 'single-exp'], ['az', ['aj'], undefined, 'number-exp'], ['az', ['ac'], undefined, 'string-exp'], ['az', ['ag'], undefined, 'string-exp'], ['az', ['ae'], undefined, 'error-exp'], ['az', ['ba'], undefined, 'single-exp'], ['az', ['bb'], undefined, 'single-exp'], ['az', ['bc'], undefined, 'single-exp'], ['bd', ['af']], ['bd', ['ai']], ['bd', ['be']], ['ba', ['bf'], undefined, 'reference'], ['bg', ['z', 'bh', 1, 'bg']], ['bg', []], ['bf', ['bh', 1, 'bg'], undefined, 'reference'], ['bi', ['bj', 1, 'bi']], ['bi', []], ['bh', ['bj', 1, 'bi'], undefined, 'reference'], ['bk', ['aa', 'bd', 1, 'bk']], ['bk', []], ['bj', ['bd', 1, 'bk'], undefined, 'reference'], ['bl', ['ac']], ['bl', ['aj']], ['bl', ['ag']], ['bl', ['ae']], ['bm', ['y', 'bl', 'bm']], ['bm', []], ['bn', ['bl', 'bm']], ['bc', ['c', 'bn', 'q']], ['bb', ['ad', 'a', 'bo', 'b']], ['bp', [], undefined, 'single-exp'], ['bp', ['am'], undefined, 'single-exp'], ['bq', ['ab', 'bp', 'bq']], ['bq', []], ['bo', ['bp', 'bq']], ['be', ['ah', 'br']], ['be', ['br']], ['br', ['s']], ['br', ['v', 'bs', 'x']], ['bt', ['u']], ['bt', []], ['bu', ['t', 'bt']], ['bs', ['bu']], ['bs', ['bv']], ['bw', ['u']], ['bw', ['s']], ['bx', ['r', 'bw', 'bx']], ['bx', []], ['bv', ['bw', 'bx']]]
,'productionIndexMap': {
'symbol': 0
,'rhs': 1
,'action': 2
,'label': 3
}
,'getProductionItemByType': function(p, itemType) {
    if (this.isCompress) {
      return p[this.productionIndexMap[itemType]];
    }
    return p[itemType];
  }
,'getProductionSymbol': function(p) {
    return this.getProductionItemByType(p, "symbol");
  }
,'getProductionRhs': function(p) {
    return this.getProductionItemByType(p, "rhs");
  }
,'getProductionAction': function(p) {
    return this.getProductionItemByType(p, "action");
  }
,'getProductionLabel': function(p) {
    return this.getProductionItemByType(p, "label");
  }
,'isCompress': 1
};
parser.getProductionSymbol=parser.getProductionSymbol.bind(parser);
parser.getProductionRhs=parser.getProductionRhs.bind(parser);
parser.getProductionAction=parser.getProductionAction.bind(parser);
parser.getProductionLabel=parser.getProductionLabel.bind(parser);
parser.lexer = lexer;
parser.lex = lex;
lexer.symbolMap = {
'$UNKNOWN': '$UNKNOWN'
,'$HIDDEN': '$HIDDEN'
,'$EOF': '$EOF'
,'(': 'a'
,')': 'b'
,'{': 'c'
,'=': 'd'
,'<=': 'e'
,'>=': 'f'
,'<>': 'g'
,'>': 'h'
,'<': 'i'
,'+': 'j'
,'-': 'k'
,'*': 'l'
,'/': 'm'
,'^': 'n'
,'&': 'o'
,'%': 'p'
,'}': 'q'
,'SPECIFIER_SEPARATOR': 'r'
,'TABLE_ITEM_SPECIFIER': 's'
,'TABLE_@': 't'
,'TABLE_COLUMN_SPECIFIER': 'u'
,'[': 'v'
,'@': 'w'
,']': 'x'
,'ARRAY_SEPARATOR': 'y'
,'REF_UNION_OPERATOR': 'z'
,'REF_EXPAND_OPERATOR': 'aa'
,'ARGUMENT_SEPARATOR': 'ab'
,'STRING': 'ac'
,'FUNCTION': 'ad'
,'ERROR': 'ae'
,'CELL': 'af'
,'LOGIC': 'ag'
,'TABLE_NAME': 'ah'
,'NAME': 'ai'
,'NUMBER': 'aj'
,'formula': 'ak'
,'expression': 'al'
,'equalExp': 'am'
,'(equalExp)1_': 'an'
,'addExp': 'ao'
,'(addExp)1_': 'ap'
,'mulExp': 'aq'
,'(mulExp)1_': 'ar'
,'expoExp': 'as'
,'(expoExp)1_': 'at'
,'concatExp': 'au'
,'(concatExp)1_': 'av'
,'percentExp': 'aw'
,'(percentExp)1_': 'ax'
,'prefix-exp': 'ay'
,'atom-exp': 'az'
,'reference': 'ba'
,'function': 'bb'
,'array': 'bc'
,'reference-item': 'bd'
,'structure-reference': 'be'
,'union-reference': 'bf'
,'(union-reference)1_': 'bg'
,'intersect-reference': 'bh'
,'(intersect-reference)1_': 'bi'
,'expand-reference': 'bj'
,'(expand-reference)1_': 'bk'
,'array-element': 'bl'
,'(array-list)1_': 'bm'
,'array-list': 'bn'
,'arguments': 'bo'
,'argument': 'bp'
,'(arguments)1_': 'bq'
,'table-specifier': 'br'
,'table-specifier-inner': 'bs'
,'_1(table-this-row)': 'bt'
,'table-this-row': 'bu'
,'table-column-specifier': 'bv'
,'table-specifier-item': 'bw'
,'(table-column-specifier)1_': 'bx'
};
const productionSkipEndSet = new Set([2,3,4,5,6,7,8,10,11,12,14,15,16,18,19,21,22,24,25,43,44,46,47,49,50,56,57,63,64,70,71,77,78]);
const productionEndFlag = 2;
const productionReductionFlag = 1;
const isProductionEndFlag = function(t) {
  return t === productionEndFlag;
}
const isProductionReductionFlag = function(t) {
  return t === productionReductionFlag;
}
parser.table = {
'ak': {
'k': 0
,'j': 0
,'w': 0
,'a': 0
,'aj': 0
,'ac': 0
,'ag': 0
,'ae': 0
,'af': 0
,'ai': 0
,'ah': 0
,'s': 0
,'v': 0
,'ad': 0
,'c': 0
}
,'al': {
'k': 1
,'j': 1
,'w': 1
,'a': 1
,'aj': 1
,'ac': 1
,'ag': 1
,'ae': 1
,'af': 1
,'ai': 1
,'ah': 1
,'s': 1
,'v': 1
,'ad': 1
,'c': 1
}
,'an': {
'd': 2
,'e': 3
,'f': 4
,'g': 5
,'h': 6
,'i': 7
,'$EOF': 8
,'b': 8
,'ab': 8
}
,'am': {
'k': 9
,'j': 9
,'w': 9
,'a': 9
,'aj': 9
,'ac': 9
,'ag': 9
,'ae': 9
,'af': 9
,'ai': 9
,'ah': 9
,'s': 9
,'v': 9
,'ad': 9
,'c': 9
}
,'ap': {
'j': 10
,'k': 11
,'d': 12
,'e': 12
,'f': 12
,'g': 12
,'h': 12
,'i': 12
,'$EOF': 12
,'b': 12
,'ab': 12
}
,'ao': {
'k': 13
,'j': 13
,'w': 13
,'a': 13
,'aj': 13
,'ac': 13
,'ag': 13
,'ae': 13
,'af': 13
,'ai': 13
,'ah': 13
,'s': 13
,'v': 13
,'ad': 13
,'c': 13
}
,'ar': {
'l': 14
,'m': 15
,'j': 16
,'k': 16
,'d': 16
,'e': 16
,'f': 16
,'g': 16
,'h': 16
,'i': 16
,'$EOF': 16
,'b': 16
,'ab': 16
}
,'aq': {
'k': 17
,'j': 17
,'w': 17
,'a': 17
,'aj': 17
,'ac': 17
,'ag': 17
,'ae': 17
,'af': 17
,'ai': 17
,'ah': 17
,'s': 17
,'v': 17
,'ad': 17
,'c': 17
}
,'at': {
'n': 18
,'l': 19
,'m': 19
,'j': 19
,'k': 19
,'d': 19
,'e': 19
,'f': 19
,'g': 19
,'h': 19
,'i': 19
,'$EOF': 19
,'b': 19
,'ab': 19
}
,'as': {
'k': 20
,'j': 20
,'w': 20
,'a': 20
,'aj': 20
,'ac': 20
,'ag': 20
,'ae': 20
,'af': 20
,'ai': 20
,'ah': 20
,'s': 20
,'v': 20
,'ad': 20
,'c': 20
}
,'av': {
'o': 21
,'n': 22
,'l': 22
,'m': 22
,'j': 22
,'k': 22
,'d': 22
,'e': 22
,'f': 22
,'g': 22
,'h': 22
,'i': 22
,'$EOF': 22
,'b': 22
,'ab': 22
}
,'au': {
'k': 23
,'j': 23
,'w': 23
,'a': 23
,'aj': 23
,'ac': 23
,'ag': 23
,'ae': 23
,'af': 23
,'ai': 23
,'ah': 23
,'s': 23
,'v': 23
,'ad': 23
,'c': 23
}
,'ax': {
'p': 24
,'o': 25
,'n': 25
,'l': 25
,'m': 25
,'j': 25
,'k': 25
,'d': 25
,'e': 25
,'f': 25
,'g': 25
,'h': 25
,'i': 25
,'$EOF': 25
,'b': 25
,'ab': 25
}
,'aw': {
'k': 26
,'j': 26
,'w': 26
,'a': 26
,'aj': 26
,'ac': 26
,'ag': 26
,'ae': 26
,'af': 26
,'ai': 26
,'ah': 26
,'s': 26
,'v': 26
,'ad': 26
,'c': 26
}
,'ay': {
'k': 27
,'j': 28
,'w': 29
,'a': 30
,'aj': 30
,'ac': 30
,'ag': 30
,'ae': 30
,'af': 30
,'ai': 30
,'ah': 30
,'s': 30
,'v': 30
,'ad': 30
,'c': 30
}
,'az': {
'a': 31
,'aj': 32
,'ac': 33
,'ag': 34
,'ae': 35
,'af': 36
,'ai': 36
,'ah': 36
,'s': 36
,'v': 36
,'ad': 37
,'c': 38
}
,'bd': {
'af': 39
,'ai': 40
,'ah': 41
,'s': 41
,'v': 41
}
,'ba': {
'af': 42
,'ai': 42
,'ah': 42
,'s': 42
,'v': 42
}
,'bg': {
'z': 43
,'p': 44
,'o': 44
,'n': 44
,'l': 44
,'m': 44
,'j': 44
,'k': 44
,'d': 44
,'e': 44
,'f': 44
,'g': 44
,'h': 44
,'i': 44
,'$EOF': 44
,'b': 44
,'ab': 44
}
,'bf': {
'af': 45
,'ai': 45
,'ah': 45
,'s': 45
,'v': 45
}
,'bi': {
'af': 46
,'ai': 46
,'ah': 46
,'s': 46
,'v': 46
,'z': 47
,'p': 47
,'o': 47
,'n': 47
,'l': 47
,'m': 47
,'j': 47
,'k': 47
,'d': 47
,'e': 47
,'f': 47
,'g': 47
,'h': 47
,'i': 47
,'$EOF': 47
,'b': 47
,'ab': 47
}
,'bh': {
'af': 48
,'ai': 48
,'ah': 48
,'s': 48
,'v': 48
}
,'bk': {
'aa': 49
,'af': 50
,'ai': 50
,'ah': 50
,'s': 50
,'v': 50
,'z': 50
,'p': 50
,'o': 50
,'n': 50
,'l': 50
,'m': 50
,'j': 50
,'k': 50
,'d': 50
,'e': 50
,'f': 50
,'g': 50
,'h': 50
,'i': 50
,'$EOF': 50
,'b': 50
,'ab': 50
}
,'bj': {
'af': 51
,'ai': 51
,'ah': 51
,'s': 51
,'v': 51
}
,'bl': {
'ac': 52
,'aj': 53
,'ag': 54
,'ae': 55
}
,'bm': {
'y': 56
,'q': 57
}
,'bn': {
'ac': 58
,'aj': 58
,'ag': 58
,'ae': 58
}
,'bc': {
'c': 59
}
,'bb': {
'ad': 60
}
,'bp': {
'ab': 61
,'b': 61
,'k': 62
,'j': 62
,'w': 62
,'a': 62
,'aj': 62
,'ac': 62
,'ag': 62
,'ae': 62
,'af': 62
,'ai': 62
,'ah': 62
,'s': 62
,'v': 62
,'ad': 62
,'c': 62
}
,'bq': {
'ab': 63
,'b': 64
}
,'bo': {
'k': 65
,'j': 65
,'w': 65
,'a': 65
,'aj': 65
,'ac': 65
,'ag': 65
,'ae': 65
,'af': 65
,'ai': 65
,'ah': 65
,'s': 65
,'v': 65
,'ad': 65
,'c': 65
,'ab': 65
,'b': 65
}
,'be': {
'ah': 66
,'s': 67
,'v': 67
}
,'br': {
's': 68
,'v': 69
}
,'bt': {
'u': 70
,'x': 71
}
,'bu': {
't': 72
}
,'bs': {
't': 73
,'u': 74
,'s': 74
}
,'bw': {
'u': 75
,'s': 76
}
,'bx': {
'r': 77
,'x': 78
}
,'bv': {
'u': 79
,'s': 79
}
};

class AstNode {
  constructor(cfg) {
    Object.assign(this, cfg);
    if (cfg.children) {
      this.setChildren(cfg.children);
    }
  }

  addChild(c) {
    this.addChildren([c]);
  }

  addChildren(cs) {
    this.children.push(...cs);
    this.setChildren(this.children);
  }

  setChildren(cs) {
    if (!cs.length) {
      this.children = [];
      return;
    }
    const first = cs[0];
    const last = cs[cs.length - 1];
    this.start = first.start;
    this.end = last.end;
    this.firstLine = first.firstLine;
    this.lastLine = last.lastLine;
    this.firstColumn = first.firstColumn;
    this.lastColumn = last.lastColumn;
    this.children = cs;
    for (const c of cs) {
      c.parent = this;
    }
  }

  toJSON() {
    const ret = {};
    for (const k of Object.keys(this)) {
      if (k !== "parent" && k !== "t") {
        ret[k] = this[k];
      }
    }
    return ret;
  }
}

parser.parse = function parse(input, options) {
  const recoveryTokens = [];
  const terminalNodes = [];

  function isExtraSymbol(ast) {
    return ast.children && !ast.children.length;
  }

  function peekStack(stack, n) {
    n = n || 1;
    return stack[stack.length - n];
  }

  function getTableVal(row, col) {
    return table[row] && table[row][col];
  }

  function noop() {}

  function getOriginalSymbol(s) {
    return lexer.mapReverseSymbol(s);
  }

  options = options || {};
  let error;
  var { onErrorRecovery, onAction = noop, lexerOptions = {} } = options;

  var {
    lexer,
    table,
    productions,
    getProductionSymbol,
    getProductionRhs,
    getProductionLabel
  } = parser;

  lexer.options = lexerOptions;

  var symbolStack = [getProductionSymbol(productions[0])];
  const astStack = [
    new AstNode({
      children: []
    })
  ];
  lexer.resetInput(input);
  let token;
  let next;
  let currentToken;

  function getError() {
    const expected = getExpected();
    const tips = [];
    if (expected.length) {
      tips.push("'" + expected.join("', '") + "' expected.");
    }
    if (currentToken) {
      tips.push("current token: '" + currentToken.token + "'.");
    }
    const tip = tips.join("\n");
    return {
      errorMessage: [
        "syntax error at line " +
          lexer.lineNumber +
          ":\n" +
          lexer.showDebugInfo(),
        ...tips
      ].join("\n"),
      tip
    };
  }

  function cleanAst(ast) {
    if (ast.token || ast.error) {
      return ast;
    }
    if (ast.children) {
      let children = [];
      for (const c of ast.children) {
        if (cleanAst(c)) {
          children.push(c);
        }
      }
      ast.setChildren(children);
    }
    if (!ast.children || !ast.children.length) {
      return null;
    }
    if (ast.children.length === 1) {
      const child = ast.children[0];
      if (
        (ast.label && child.label && ast.label === child.label) ||
        (!ast.label && !child.label && ast.symbol === child.symbol)
      ) {
        ast.setChildren(child.children);
        ast.symbol = child.symbol;
      }
    }
    return ast;
  }

  function getAst(raw) {
    const ast = astStack[0] && astStack[0].children && astStack[0].children[0];
    if (ast) {
      astStack[0].children.forEach(a => delete a.parent);
    }
    if (raw) {
      return ast;
    }
    return ast && cleanAst(ast);
  }

  let topSymbol;

  let errorNode;

  let lastSymbol;

  function popSymbolStack() {
    const last = symbolStack.pop();
    if (typeof last === "string") {
      lastSymbol = last;
    }
  }

  function getExpected() {
    const s = topSymbol || lastSymbol;
    const ret = (table[s] && Object.keys(table[s])) || [];
    return ret.map(r => lexer.mapReverseSymbol(r));
  }

  function closeAstWhenError() {
    errorNode = new AstNode({
      error,
      ...error.lexer
    });
    peekStack(astStack).addChild(errorNode);
    while (astStack.length !== 1) {
      const ast = astStack.pop();
      if (ast.symbol && isExtraSymbol(ast)) {
        const topAst = peekStack(astStack);
        topAst.children.pop();
        topAst.addChildren(ast.children);
      }
    }
  }

  let production;

  while (1) {
    topSymbol = peekStack(symbolStack);

    if (!topSymbol) {
      break;
    }

    while (
      isProductionEndFlag(topSymbol) ||
      isProductionReductionFlag(topSymbol)
    ) {
      let ast = astStack.pop();
      if (isProductionReductionFlag(topSymbol)) {
        const stackTop = peekStack(astStack);
        const wrap = new AstNode({
          symbol: ast.symbol,
          children: [ast],
          label: ast.label
        });
        stackTop.children.pop();
        stackTop.addChild(wrap);
        astStack.push(wrap);
      }
      popSymbolStack();
      topSymbol = peekStack(symbolStack);
      if (!topSymbol) {
        break;
      }
    }

    if (typeof topSymbol === "string") {
      if (!token) {
        token = lexer.lex();
        recoveryTokens.push(token);
      }
      currentToken = token;
      if (topSymbol === token.t) {
        symbolStack.pop();
        const terminalNode = new AstNode(token);
        terminalNodes.push(terminalNode);
        const parent = peekStack(astStack);
        parent.addChild(terminalNode);
        token = null;
      } else if ((next = getTableVal(topSymbol, token.t)) !== undefined) {
        popSymbolStack();
        production = productions[next];

        if (productionSkipEndSet.has(next)) {
          symbolStack.push.apply(
            symbolStack,
            getProductionRhs(production)
              .concat()
              .reverse()
          );
        } else {
          const newAst = new AstNode({
            symbol: getOriginalSymbol(topSymbol),
            label: getProductionLabel(production),
            children: []
          });
          peekStack(astStack).addChild(newAst);
          astStack.push(newAst);
          symbolStack.push.apply(
            symbolStack,
            getProductionRhs(production)
              .concat(productionEndFlag)
              .reverse()
          );
        }
      } else {
        error = {
          recovery: false,
          ...getError(),
          expected: getExpected(),
          symbol: lexer.mapReverseSymbol(topSymbol),
          lexer: token
        };
        if (onErrorRecovery) {
          const recommendedAction = {};
          const nextToken = lexer.peek();

          // should delete
          if (
            topSymbol === nextToken.t ||
            getTableVal(topSymbol, nextToken.t) !== undefined
          ) {
            recommendedAction.action = "del";
          } else if (error.expected.length) {
            recommendedAction.action = "add";
          }

          const errorNode = new AstNode({
            error,
            ...error.lexer
          });

          peekStack(astStack).addChild(errorNode);

          const recovery =
            onErrorRecovery(
              {
                errorNode,
                ast: getAst(true)
              },
              recommendedAction
            ) || {};
          const { action } = recovery;

          peekStack(astStack).children.pop();

          if (!action) {
            closeAstWhenError();
            break;
          }

          if (action === "del") {
            error.recovery = true;
            recoveryTokens.pop();
            token = null;
          } else if (action === "add") {
            error.recovery = true;
            token = {
              ...token,
              token: recovery.token,
              text: recovery.text,
              t: lexer.mapSymbol(recovery.token)
            };
            recoveryTokens.push(token);
          }
        } else {
          closeAstWhenError();
          break;
        }
      }
    }

    topSymbol = peekStack(symbolStack);

    while (topSymbol && typeof topSymbol === "function") {
      onAction({
        lexer: currentToken,
        action: topSymbol
      });
      popSymbolStack();
      topSymbol = peekStack(symbolStack);
    }

    if (!symbolStack.length) {
      break;
    }
  }

  if (!error && currentToken.t !== lexer.mapEndSymbol()) {
    error = {
      ...getError(),
      expected: getExpected(),
      symbol: lexer.mapReverseSymbol(topSymbol || lastSymbol),
      lexer: currentToken
    };
    closeAstWhenError();
  }

  const ast = getAst();

  return {
    ast,
    tokens: lexer.tokens,
    recoveryTokens,
    errorNode,
    error,
    terminalNodes
  };
};
 return parser; 
})();

  if(typeof module !== 'undefined') {
    module.exports = index.js;
  }
