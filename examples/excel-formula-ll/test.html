<h1>excel formula parser</h1>

<h2>tool</h2>

<div>
    <a href="./formula-grammar.js">excel formula grammar definition</a>
</div>

<div>
    <p>run</p>
    <pre>
    npm i kison@alpha -g

    kison --no-compressSymbol -m ll --es -g formula-grammar.js
</pre>
</div>

<h2>open devtools console</h2>

<div>
    <input style="width:200px" id='input' value="sum(a1:a2, b2)" />
    &nbsp; <button id='parse'>parse</button>
    &nbsp; <button id='evaluate'>evaluate</button>
</div>

<script type="module">
    import formula from './formula.js';
    (function () {
        let currentText;
        let currentAst;

        function getAst(value) {
            if (currentText === value) {
                return currentAst;
            }
            console.log('***********************', value);
            currentText = value;
            currentAst = formula.parse(value, {
                lexerEnv: 'en'
            });
            console.log(currentAst);
            if (currentAst.error) {
                console.error(currentAst.error.errorMessage);
            }
            console.log('***********************');
            return currentAst;
        }

        function $(id) {
            return document.getElementById(id);
        }

        const input = $('input');
        const parse = $('parse');
        const evaluate = $('evaluate');
        const ARGUMENT_SEPARATOR = 'ARGUMENT_SEPARATOR';

        evaluate.addEventListener('click', () => {
            const { ast, errorNode } = getAst(input.value);
            console.log('TODO');
        });

        parse.addEventListener('click', () => {
            currentText = undefined;
            getAst(input.value);
        }, false);

        function detectCursor(e) {
            const { selectionStart } = input;
            // console.log('cursor position:', selectionStart)
            const { terminalNodes, errorNode } = getAst(input.value);
            let cursorNode;
            for (const n of terminalNodes) {
                if (n.start <= selectionStart && n.end > selectionStart) {
                    cursorNode = n;
                    break;
                }
                if (n.start > selectionStart) {
                    cursorNode = n;
                    break;
                }
            }
            cursorNode = cursorNode || errorNode;
            console.log('cursor node', cursorNode);

            if (cursorNode) {
                let func = isTopCursorFunction(cursorNode, selectionStart);
                if (func) {
                    console.log(`at function ${func.children[0].text}`)
                    return;
                }
                func = cursorNode.parent;
                while (func && func.symbol !== 'function') {
                    func = func.parent;
                }
                if (func) {
                    let args = cursorNode.parent;
                    if (cursorNode === errorNode && cursorNode.parent === func) {
                        console.log(`at argument index ${1} of function ${func.children[0].text}`);
                        return;
                    } else {
                        if (cursorNode.token === ')') {
                            args = func.children[2];
                        } else {
                            while (args && args.symbol !== 'arguments') {
                                args = args.parent;
                            }
                        }
                    }
                    if (args && args !== errorNode) {
                        let argsLength = getArgumentsLength(args) || 1;
                        if (cursorNode.token === ARGUMENT_SEPARATOR) {
                            argsLength--;
                        }
                        if (cursorNode === errorNode && prevSibling(cursorNode).token === ARGUMENT_SEPARATOR) {
                            argsLength++;
                        }
                        func = args.parent;
                        while (func && func.symbol !== 'function') {
                            func = func.parent;
                        }
                        console.log(`at argument index ${argsLength} of function ${func.children[0].text}`)
                    }
                }
            }
        }

        function debounce(fn, ms) {
            let timer
            return (...args) => {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(() => {
                    fn(...args);
                }, ms);
            };
        }

        input.addEventListener('click', detectCursor);
        input.addEventListener('keydown', debounce(detectCursor, 100));

        function prevSibling(node) {
            const index = node.parent.children.indexOf(node);
            return node.parent.children[index - 1];
        }

        function isTopCursorFunction(node, selectionStart) {
            if (!node) {
                return false;
            }

            if (node.token === 'FUNCTION') {
                if (selectionStart === node.start) {
                    return false;
                }
                return returnIfTopFn(node.parent);
            }

            if (node.symbol !== 'function') {
                const parent = node.parent;
                if (parent.symbol === 'function') {
                    const prev = prevSibling(node);
                    if (parent.children.indexOf(prev) === 0) {
                        return returnIfTopFn(parent);
                    }
                }
                return false;
            }

            function returnIfTopFn(n) {
                let topFn = n.parent;
                while (topFn && topFn.symbol !== 'function') {
                    topFn = topFn.parent;
                }
                return !topFn && n;
            }

            return returnIfTopFn(node);
        }

        function getArgumentsLength(args) {
            let c = 0;
            const { children = [] } = args;
            if (children[0] && children[0].symbol === 'arguments') {
                if (children[2] && !children[2].error) {
                    c = 1;
                }
                return c + getArgumentsLength(children[0]);
            } else if (children[0] && !children[0].error) {
                c = 1;
            }
            return c;
        }
    })();
</script>