<h1>excel formula parser</h1>

<h2>tool</h2>

<div>
    <a href="./formula-grammar.js">excel formula grammar definition</a>
</div>

<div>
    <p>build</p>
    <pre>
    npx kison -m ll --es -g formula-grammar.js
</pre>
</div>

<div>
    <p>install prebuild verison</p>
    <pre>
        npm install @yiminghe/excel-formula-parser
    </pre>
</div>

<div>
    <a href="./README.md">excel formula parser readme</a>
</div>

<h2>open devtools console</h2>
<p>error recovery example: &nbsp;&nbsp; <b>sum(1,sum(2,</b> &nbsp; &nbsp;=> &nbsp;&nbsp;<b>sum(1,sum(2,))</b></p>
<div>
    <input style="width:200px" id='input' value="sum(a1:a2, b2)" />
    &nbsp; <button id='parse'>parse</button>
    &nbsp; <button id='fix'>error recovery</button>
    &nbsp; <button id='evaluate'>evaluate</button>
</div>

<script type="module">
    import formula from './formula.js';
    (function () {
        let currentText;
        let currentAst;

        function getAst(value, onErrorRecovery) {
            if (currentText === value) {
                return currentAst;
            }
            console.log('***********************', value);
            currentText = value;
            currentAst = formula.parse(value, {
                // lexerEnv: 'en',
                onErrorRecovery,
            });
            console.log(currentAst);
            if (currentAst.error) {
                console.error(currentAst.error.errorMessage);
            }
            console.log('***********************');
            return currentAst;
        }

        function $(id) {
            return document.getElementById(id);
        }

        const input = $('input');
        const fix = $('fix');
        const parse = $('parse');
        const evaluate = $('evaluate');
        const ARGUMENT_SEPARATOR = 'ARGUMENT_SEPARATOR';

        evaluate.addEventListener('click', () => {
            const { ast, errorNode } = getAst(input.value);
            console.log('TODO');
        });

        fix.addEventListener('click', () => {
            currentText = undefined;
            let fixed = false;
            const { ast, error, recoveryTokens, tokens } = getAst(input.value, ({ errorNode }, { action }) => {
                if (action === 'add') {
                    let token = ')';
                    const { parent: { symbol }, error: { expected } } = errorNode;
                    const hasToken = expected.indexOf(token) !== -1;
                    if (
                        (symbol === 'arguments' || symbol === 'function')
                        &&
                        hasToken
                    ) {
                        fixed = true;
                        return {
                            action,
                            token,
                            text: token,
                        };
                    }
                }
            });
            if (fixed) {
                const val = recoveryTokens.map(t => t.text).join('');
                console.log('`' + input.value.trim() + '` will fixed to `' + val + '`');
                input.value = val;
            }
        }, false);

        parse.addEventListener('click', () => {
            currentText = undefined;
            getAst(input.value);
        }, false);

        function detectCursor(e) {
            const { selectionStart } = input;
            // console.log('cursor position:', selectionStart)
            const { terminalNodes, errorNode } = getAst(input.value);
            let cursorNode;
            for (const n of terminalNodes) {
                if (n.start <= selectionStart && n.end > selectionStart) {
                    cursorNode = n;
                    break;
                }
                if (n.start > selectionStart) {
                    cursorNode = n;
                    break;
                }
            }
            cursorNode = cursorNode || errorNode;
            console.log('cursor node', cursorNode);

            if (cursorNode) {
                let func = isTopCursorFunction(cursorNode, selectionStart);
                if (func) {
                    console.log(`at function ${func.children[0].text}`)
                    return;
                }
                func = cursorNode.parent;
                while (func && func.symbol !== 'function') {
                    func = func.parent;
                }
                if (func) {
                    let args = cursorNode.parent;
                    if (cursorNode === errorNode && cursorNode.parent === func) {
                        console.log(`at argument index ${1} of function ${func.children[0].text}`);
                        return;
                    } else {
                        if (cursorNode.token === ')') {
                            args = func.children[2];
                        } else {
                            while (args && args.symbol !== 'arguments') {
                                args = args.parent;
                            }
                        }
                    }
                    if (args && args !== errorNode) {
                        func = args.parent;
                        while (func && func.symbol !== 'function') {
                            func = func.parent;
                        }
                        let argumentIndex = getArgumentIndex(args, selectionStart) || 1;
                        console.log(`at argument index ${argumentIndex} of function ${func.children[0].text}`)
                    }
                }
            }
        }

        function debounce(fn, ms) {
            let timer
            return (...args) => {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(() => {
                    fn(...args);
                }, ms);
            };
        }

        input.addEventListener('click', detectCursor);
        input.addEventListener('keydown', debounce(detectCursor, 100));

        function prevSibling(node) {
            const index = node.parent.children.indexOf(node);
            return node.parent.children[index - 1];
        }

        function isTopCursorFunction(node, selectionStart) {
            if (!node) {
                return false;
            }

            if (node.token === 'FUNCTION') {
                if (selectionStart === node.start) {
                    return false;
                }
                return returnIfTopFn(node.parent);
            }

            if (node.symbol !== 'function') {
                const parent = node.parent;
                if (parent && parent.symbol === 'function') {
                    const prev = prevSibling(node);
                    if (parent.children.indexOf(prev) === 0) {
                        return returnIfTopFn(parent);
                    }
                }
                return false;
            }

            function returnIfTopFn(n) {
                let topFn = n.parent;
                while (topFn && topFn.symbol !== 'function') {
                    topFn = topFn.parent;
                }
                return !topFn && n;
            }

            return returnIfTopFn(node);
        }

        function getArgumentIndex(args, selectionStart) {
            let c = 0;
            const { children = [] } = args;
            if (children[0] && children[0].symbol === 'arguments') {
                if (children[1] && children[1].token === 'ARGUMENT_SEPARATOR') {
                    if (children[1].end <= selectionStart) {
                        c = 1;
                    }
                }
                return c + getArgumentIndex(children[0], selectionStart);
            } else if (children[0] && !children[0].error) {
                if (children.length === 1 && children[0].token === 'ARGUMENT_SEPARATOR') {
                    if (children[0].end <= selectionStart) {
                        c = 2;
                    } else {
                        c = 1;
                    }
                } else {
                    if (children[0].start <= selectionStart) {
                        c = 1;
                    }
                }
            }
            return c;
        }

        function lastChild(c) {
            c = c.children || [];
            return c[c.length - 1];
        }
    })();
</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />

<a class="github-fork-ribbon" href="https://github.com/yiminghe/kison" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
