progam ::= moduleDeclarations? endOfLine* moduleBody? endOfLine* '$EOF'
endOfLine ::= 'NEWLINE' | 'COMMENT' | 'REMCOMMENT'
endOfStatement ::= ( endOfLine | 'COLON' )*
moduleDeclarations ::= moduleDeclarationsElement ( endOfLine+ moduleDeclarationsElement )* endOfLine*
moduleDeclarationsElement ::= 'COMMENT' | variableStmt | moduleOption
moduleOption ::= 'OPTION_BASE' 'INTEGERLITERAL' | 'OPTION_COMPARE' 'IDENTIFIER' | 'OPTION_EXPLICIT' | 'OPTION_PRIVATE_MODULE'
moduleBody ::= moduleBodyElement ( endOfLine+ moduleBodyElement )* endOfLine*
moduleBodyElement ::= functionStmt | propertyGetStmt | propertySetStmt | propertyLetStmt | subStmt
visibility ::= 'PRIVATE' | 'PUBLIC' | 'FRIEND' | 'GLOBAL'
subStmt ::= visibility? 'STATIC'? 'SUB' ambiguousIdentifier argList? endOfStatement block? 'END_SUB'
propertyGetStmt ::= visibility? 'STATIC'? 'PROPERTY_GET' ambiguousIdentifier typeHint? 'LPAREN' 'RPAREN' asTypeClause? endOfStatement block? 'END_PROPERTY'
propertySetStmt ::= visibility? 'STATIC'? 'PROPERTY_SET' ambiguousIdentifier argList? endOfStatement block? 'END_PROPERTY'
propertyLetStmt ::= visibility? 'STATIC'? 'PROPERTY_LET' ambiguousIdentifier argList? endOfStatement block? 'END_PROPERTY'
functionStmt ::= visibility? 'STATIC'? 'FUNCTION' ambiguousIdentifier typeHint? argList? asTypeClause? endOfStatement block? 'END_FUNCTION'
block ::= blockStmt ( endOfStatement blockStmt )* endOfStatement
blockStmt ::= lineLabel | goToStmt | ifThenElseStmt | selectCaseStmt | forNextStmt | forEachStmt | doLoopStmt | whileWendStmt | onErrorStmt | withStmt | eraseStmt | exitStmt | explicitCallStmt | setStmt | redimStmt | letStmt | variableStmt | implicitCallStmt_InBlock
whileWendStmt ::= 'WHILE' valueStmt endOfStatement block 'WEND'
doLoopStmt ::= 'DO' endOfStatement block 'LOOP'
doLoopStmt ::= 'DO' ( 'WHILE' | 'UNTIL' ) valueStmt endOfStatement block 'LOOP'
doLoopStmt ::= 'DO' endOfStatement block 'LOOP' ( 'WHILE' | 'UNTIL' ) valueStmt
forNextStmt ::= 'FOR' ambiguousIdentifier typeHint? asTypeClause? 'EQ' valueStmt 'TO' valueStmt ( 'STEP' valueStmt )? endOfStatement block? 'NEXT' ambiguousIdentifier?
forEachStmt ::= 'FOR' 'EACH' ambiguousIdentifier typeHint? 'IN' valueStmt endOfStatement block? 'NEXT' ambiguousIdentifier?
selectCaseStmt ::= 'SELECT' 'CASE' valueStmt endOfStatement sC_Case* 'END_SELECT'
sC_Selection ::= 'IS' comparisonOperator valueStmt
sC_Selection ::= valueStmt 'TO' valueStmt
sC_Selection ::= valueStmt
sC_Case ::= 'CASE' sC_Cond endOfStatement block?
sC_Cond ::= 'ELSE'
sC_Cond ::= sC_Selection ( ',' sC_Selection )*
comparisonOperator ::= 'LT' | 'LEQ' | 'GT' | 'GEQ' | 'EQ' | 'NEQ' | 'IS' |
ifThenElseStmt ::= 'IF' valueStmt 'THEN' blockStmt ( 'ELSE' blockStmt )?
ifThenElseStmt ::= ifBlockStmt ifElseIfBlockStmt* ifElseBlockStmt? 'END_IF'
ifBlockStmt ::= 'IF' valueStmt 'THEN' endOfStatement block?
ifElseIfBlockStmt ::= 'ELSEIF' valueStmt 'THEN' endOfStatement block?
ifElseBlockStmt ::= 'ELSE' endOfStatement block?
onErrorStmt ::= 'ON_ERROR' 'GOTO' ( ambiguousIdentifier | 'MINUS' 'INTEGERLITERAL' )
lineLabel ::= ambiguousIdentifier 'COLON'
goToStmt ::= 'GOTO' ambiguousIdentifier
eraseStmt ::= 'ERASE' valueStmt ( ',' valueStmt )*
redimStmt ::= 'REDIM' 'PRESERVE'? redimSubStmt ( ',' redimSubStmt )*
redimSubStmt ::= implicitCallStmt_InStmt 'LPAREN' subscripts 'RPAREN' asTypeClause?
exitStmt ::= 'EXIT_DO' | 'EXIT_FOR' | 'EXIT_FUNCTION' | 'EXIT_PROPERTY' | 'EXIT_SUB' | 'END'
letStmt ::= 'LET'? implicitCallStmt_InStmt ( 'EQ' | 'PLUS_EQ' | 'MINUS_EQ' ) valueStmt
setStmt ::= 'SET' implicitCallStmt_InStmt 'EQ' valueStmt
explicitCallStmt ::= eCS_MemberProcedureCall | eCS_ProcedureCall
eCS_MemberProcedureCall ::= 'CALL' ( implicitCallStmt_InStmt? '.' | 'SPACE_DOT' ) ambiguousIdentifier typeHint? ( 'LPAREN' argsCall 'RPAREN' )? ( 'LPAREN' indexes 'RPAREN' )*
eCS_ProcedureCall ::= 'CALL' ambiguousIdentifier typeHint? ( 'LPAREN' argsCall 'RPAREN' )? ( 'LPAREN' indexes 'RPAREN' )*
implicitCallStmt_InBlock ::= iCS_B_MemberProcedureCall | iCS_B_ProcedureCall
iCS_B_MemberProcedureCall ::= implicitCallStmt_InStmt '.' ambiguousIdentifier typeHint? argsCall? dictionaryCallStmt? ( 'LPAREN' indexes 'RPAREN' )*
iCS_B_ProcedureCall ::= certainIdentifier argsCall? ( 'LPAREN' indexes 'RPAREN' )?
argsCall ::= ','* argCall ( ',' argCall? )*
argCall ::= valueStmt
variableStmt ::= ( 'DIM' | 'STATIC' | visibility ) 'WITHEVENTS'? variableListStmt
withStmt ::= 'WITH' ( implicitCallStmt_InStmt | 'NEW' type_ ) endOfStatement block? 'END_WITH'
variableListStmt ::= variableSubStmt ( ',' variableSubStmt )*
variableSubStmt ::= ambiguousIdentifier ( 'LPAREN' subscripts? 'RPAREN' )? typeHint? asTypeClause?
indexes ::= valueStmt ( ',' valueStmt )*
subscript_ ::= ( valueStmt 'TO' )? valueStmt
subscripts ::= subscript_ ( ',' subscript_ )*
subscript_ ::= ( valueStmt 'TO' )? valueStmt
argList ::= 'LPAREN' ( arg ( ',' arg )* )? 'RPAREN'
valueStmt ::= literal | implicitCallStmt_InStmt | ambiguousIdentifier 'ASSIGN' valueStmt | 'NEW' valueStmt
valueStmt ::= 'LPAREN' valueStmt 'RPAREN'
valueStmt ::= valueStmt 'IS' valueStmt
valueStmt ::= valueStmt 'ISNOT' valueStmt
valueStmt ::= valueStmt 'GEQ' valueStmt
valueStmt ::= valueStmt 'LEQ' valueStmt
valueStmt ::= valueStmt 'GT' valueStmt
valueStmt ::= valueStmt 'LT' valueStmt
valueStmt ::= valueStmt 'NEQ' valueStmt
valueStmt ::= valueStmt 'EQ' valueStmt
valueStmt ::= valueStmt 'XOR' valueStmt
valueStmt ::= valueStmt 'OR' valueStmt
valueStmt ::= valueStmt 'AND' valueStmt
valueStmt ::= valueStmt 'PLUS' valueStmt
valueStmt ::= valueStmt 'MINUS' valueStmt
valueStmt ::= valueStmt 'AMPERSAND' valueStmt
valueStmt ::= valueStmt 'MULT' valueStmt
valueStmt ::= valueStmt 'DIV' valueStmt
valueStmt ::= valueStmt 'IDIV' valueStmt
valueStmt ::= valueStmt 'MOD' valueStmt
valueStmt ::= valueStmt 'POW' valueStmt
valueStmt ::= 'MINUS' valueStmt
valueStmt ::= 'PLUS' valueStmt
valueStmt ::= 'NOT' valueStmt
implicitCallStmt_InStmt ::= iCS_S_MembersCall | iCS_S_VariableOrProcedureCall | iCS_S_ProcedureOrArrayCall
iCS_S_MembersCall ::= ( ( iCS_S_VariableOrProcedureCall | iCS_S_ProcedureOrArrayCall ) iCS_S_MemberCall | iCS_S_SpaceMemberCall ) iCS_S_MemberCall* dictionaryCallStmt? ( 'LPAREN' indexes 'RPAREN' )*
iCS_S_MemberCall ::= '.' ( iCS_S_VariableOrProcedureCall | iCS_S_ProcedureOrArrayCall )
iCS_S_SpaceMemberCall ::= 'SPACE_DOT' ( iCS_S_VariableOrProcedureCall | iCS_S_ProcedureOrArrayCall )
iCS_S_ProcedureOrArrayCall ::= ambiguousIdentifier typeHint? 'LPAREN' argsCall? 'RPAREN' dictionaryCallStmt? ( 'LPAREN' indexes 'RPAREN' )*
iCS_S_VariableOrProcedureCall ::= ambiguousIdentifier typeHint? dictionaryCallStmt? ( 'LPAREN' indexes 'RPAREN' )*
dictionaryCallStmt ::= '!' ambiguousIdentifier typeHint?
literal ::= 'DOUBLELITERAL' | 'INTEGERLITERAL' | 'STRINGLITERAL' | 'NOTHING' | 'NULL' | 'TRUE' | 'FALSE' | 'DATELITERAL'
typeHint ::= '&' | '%' | '#' | '!' | '@' | '$'
arg ::= 'OPTIONAL'? ( 'BYVAL' | 'BYREF' )? 'PARAMARRAY'? ambiguousIdentifier typeHint? ( 'LPAREN' 'RPAREN' )? asTypeClause? argDefaultValue?
argDefaultValue ::= 'EQ' valueStmt
asTypeClause ::= 'AS' 'NEW'? type_ fieldLength?
type_ ::= ( baseType | complexType ) ( 'LPAREN' 'RPAREN' )?
complexType ::= ambiguousIdentifier ( ( '.' | '!' ) ambiguousIdentifier )*
baseType ::= 'BOOLEAN' | 'BYTE' | 'DOUBLE' | 'INTEGER' | 'LONG' | 'SINGLE' | 'VARIANT' | 'STRING' | 'DATE'
fieldLength ::= 'MULT' 'INTEGERLITERAL' | 'MULT' ambiguousIdentifier
ambiguousIdentifier ::= 'ALIAS'
ambiguousIdentifier ::= 'AND'
ambiguousIdentifier ::= 'ATTRIBUTE'
ambiguousIdentifier ::= 'AS'
ambiguousIdentifier ::= 'BEGIN'
ambiguousIdentifier ::= 'BOOLEAN'
ambiguousIdentifier ::= 'BYVAL'
ambiguousIdentifier ::= 'BYREF'
ambiguousIdentifier ::= 'BYTE'
ambiguousIdentifier ::= 'CALL'
ambiguousIdentifier ::= 'CASE'
ambiguousIdentifier ::= 'CONST'
ambiguousIdentifier ::= 'DATE'
ambiguousIdentifier ::= 'DECLARE'
ambiguousIdentifier ::= 'DEFBOOL'
ambiguousIdentifier ::= 'DEFBYTE'
ambiguousIdentifier ::= 'DEFDATE'
ambiguousIdentifier ::= 'DEFDBL'
ambiguousIdentifier ::= 'DEFDEC'
ambiguousIdentifier ::= 'DEFCUR'
ambiguousIdentifier ::= 'DEFINT'
ambiguousIdentifier ::= 'DEFLNG'
ambiguousIdentifier ::= 'DEFOBJ'
ambiguousIdentifier ::= 'DEFSNG'
ambiguousIdentifier ::= 'DEFSTR'
ambiguousIdentifier ::= 'DEFVAR'
ambiguousIdentifier ::= 'DIM'
ambiguousIdentifier ::= 'DO'
ambiguousIdentifier ::= 'DOUBLE'
ambiguousIdentifier ::= 'EACH'
ambiguousIdentifier ::= 'ELSE'
ambiguousIdentifier ::= 'ELSEIF'
ambiguousIdentifier ::= 'END_ENUM'
ambiguousIdentifier ::= 'END_FUNCTION'
ambiguousIdentifier ::= 'END_IF'
ambiguousIdentifier ::= 'END_PROPERTY'
ambiguousIdentifier ::= 'END_SELECT'
ambiguousIdentifier ::= 'END_SUB'
ambiguousIdentifier ::= 'END_TYPE'
ambiguousIdentifier ::= 'END_WITH'
ambiguousIdentifier ::= 'END'
ambiguousIdentifier ::= 'ENUM'
ambiguousIdentifier ::= 'EQV'
ambiguousIdentifier ::= 'ERASE'
ambiguousIdentifier ::= 'EVENT'
ambiguousIdentifier ::= 'EXIT_DO'
ambiguousIdentifier ::= 'EXIT_FOR'
ambiguousIdentifier ::= 'EXIT_FUNCTION'
ambiguousIdentifier ::= 'EXIT_PROPERTY'
ambiguousIdentifier ::= 'EXIT_SUB'
ambiguousIdentifier ::= 'FALSE'
ambiguousIdentifier ::= 'FRIEND'
ambiguousIdentifier ::= 'FOR'
ambiguousIdentifier ::= 'FUNCTION'
ambiguousIdentifier ::= 'GET'
ambiguousIdentifier ::= 'GLOBAL'
ambiguousIdentifier ::= 'GOSUB'
ambiguousIdentifier ::= 'GOTO'
ambiguousIdentifier ::= 'IF'
ambiguousIdentifier ::= 'IMPLEMENTS'
ambiguousIdentifier ::= 'IN'
ambiguousIdentifier ::= 'ISNOT'
ambiguousIdentifier ::= 'IS'
ambiguousIdentifier ::= 'INTEGER'
ambiguousIdentifier ::= 'LONG'
ambiguousIdentifier ::= 'LOOP'
ambiguousIdentifier ::= 'LEN'
ambiguousIdentifier ::= 'LET'
ambiguousIdentifier ::= 'LIB'
ambiguousIdentifier ::= 'LIKE'
ambiguousIdentifier ::= 'LSET'
ambiguousIdentifier ::= 'MACRO_CONST'
ambiguousIdentifier ::= 'MACRO_IF'
ambiguousIdentifier ::= 'MACRO_ELSEIF'
ambiguousIdentifier ::= 'MACRO_ELSE'
ambiguousIdentifier ::= 'MACRO_END_IF'
ambiguousIdentifier ::= 'MOD'
ambiguousIdentifier ::= 'NEXT'
ambiguousIdentifier ::= 'NEW'
ambiguousIdentifier ::= 'NOT'
ambiguousIdentifier ::= 'NOTHING'
ambiguousIdentifier ::= 'NULL'
ambiguousIdentifier ::= 'ON_ERROR'
ambiguousIdentifier ::= 'ON_LOCAL_ERROR'
ambiguousIdentifier ::= 'ON'
ambiguousIdentifier ::= 'OPTIONAL'
ambiguousIdentifier ::= 'OPTION_BASE'
ambiguousIdentifier ::= 'OPTION_EXPLICIT'
ambiguousIdentifier ::= 'OPTION_COMPARE'
ambiguousIdentifier ::= 'OPTION_PRIVATE_MODULE'
ambiguousIdentifier ::= 'OR'
ambiguousIdentifier ::= 'PARAMARRAY'
ambiguousIdentifier ::= 'PRESERVE'
ambiguousIdentifier ::= 'PRIVATE'
ambiguousIdentifier ::= 'PROPERTY_GET'
ambiguousIdentifier ::= 'PROPERTY_LET'
ambiguousIdentifier ::= 'PROPERTY_SET'
ambiguousIdentifier ::= 'PTRSAFE'
ambiguousIdentifier ::= 'PUBLIC'
ambiguousIdentifier ::= 'RAISEEVENT'
ambiguousIdentifier ::= 'REDIM'
ambiguousIdentifier ::= 'RESET'
ambiguousIdentifier ::= 'RESUME'
ambiguousIdentifier ::= 'RETURN'
ambiguousIdentifier ::= 'SELECT'
ambiguousIdentifier ::= 'SET'
ambiguousIdentifier ::= 'SINGLE'
ambiguousIdentifier ::= 'STATIC'
ambiguousIdentifier ::= 'STEP'
ambiguousIdentifier ::= 'STOP'
ambiguousIdentifier ::= 'STRING'
ambiguousIdentifier ::= 'SUB'
ambiguousIdentifier ::= 'THEN'
ambiguousIdentifier ::= 'TO'
ambiguousIdentifier ::= 'TRUE'
ambiguousIdentifier ::= 'TYPEOF'
ambiguousIdentifier ::= 'UNTIL'
ambiguousIdentifier ::= 'VARIANT'
ambiguousIdentifier ::= 'WEND'
ambiguousIdentifier ::= 'WHILE'
ambiguousIdentifier ::= 'WITH'
ambiguousIdentifier ::= 'WITHEVENTS'
ambiguousIdentifier ::= 'XOR'
ambiguousIdentifier ::= 'IMP'
certainIdentifier ::= 'IDENTIFIER'
ambiguousIdentifier ::= 'IDENTIFIER'