/*
Generated By kison v0.5.30

Generate time: Tue Nov 16 2021 19:11:38 GMT+0800 (中国标准时间)
*/
var vbaParser = (function (undefined) {
  var BaseAstNode = class BaseAstNode {
    start = 0;
    end = 0;
    firstLine = 0;
    lastLine = 0;
    firstColumn = 0;
    lastColumn = 0;

    toJSON() {
      const ret = {};

      for (const k of Object.keys(this)) {
        if (k !== "parent" && k !== "t") {
          const v = this[k];

          if (v !== undefined) {
            ret[k] = v;
          }
        }
      }

      return ret;
    }
  };
  var AstSymbolNode = class AstSymbolNode extends BaseAstNode {
    symbol = "";
    type = "symbol";
    children = [];
    ruleIndex = -1;
    internalRuleIndex = -1;

    constructor(params) {
      super();
      Object.assign(this, params);

      if (params.children) {
        this.setChildren(params.children);
      }

      if (params.internalRuleIndex !== undefined) {
        this.ruleIndex = productionRuleIndexMap[this.internalRuleIndex];
      }
    }

    addChild(c) {
      this.addChildren([c]);
    }

    addChildren(cs) {
      this.children = this.children || [];
      this.children.push(...cs);
      this.setChildren(this.children);
    }

    done() {
      if (this.isWrap && this.children.length === 1) {
        const c = this.children[0];

        if (c.type === "symbol" && c.symbol === this.symbol) {
          this.label = c.label;
          this.setChildren(c.children);
          return false;
        }
      }

      this.setChildren(this.children);
      return true;
    }

    setChildren(cs) {
      if (!cs.length) {
        this.children = [];
        return;
      }

      const first = cs[0];
      const last = cs[cs.length - 1];
      this.start = first.start;
      this.end = last.end;
      this.firstLine = first.firstLine;
      this.lastLine = last.lastLine;
      this.firstColumn = first.firstColumn;
      this.lastColumn = last.lastColumn;
      this.children = cs;

      for (const c of cs) {
        c.parent = this;
      }
    }
  };
  var AstTokenNode = class AstTokenNode extends BaseAstNode {
    token = "";
    t = "";
    type = "token";
    text = "";

    constructor(params) {
      super();
      Object.assign(this, params);
    }
  };
  var AstErrorNode = class AstErrorNode extends AstTokenNode {
    constructor(ErrorTokenParams) {
      super(ErrorTokenParams);
      Object.assign(ErrorTokenParams);
    }
  };
  var getLabeledRhsForAddNodeFlag = function (production, extraRhs) {
    let rhs = extraRhs || parser.getProductionRhs(production);
    const label = parser.getProductionLabel(production);

    if (label) {
      let newRhs = [];

      for (const r of rhs) {
        if (isAddAstNodeFlag(r)) {
          newRhs.push(() => {
            astStack[astStack.length - 1].label = getOriginalSymbol(label);
          });
        }

        newRhs.push(r);
      }

      rhs = newRhs;
    } else if (!extraRhs) {
      rhs = [...rhs];
    }

    return rhs;
  };
  var checkLLEndError = function (parseTree, getExpected, ret) {
    const { EOF_TOKEN } = Lexer.STATIC;

    if (!ret.error && lexer.getCurrentToken().token !== EOF_TOKEN) {
      var _peekStack;

      // reduction done but still has input
      if (!symbolStack.length) {
        getExpected = () => [EOF_TOKEN];

        lexer.lex();
      }

      ret.error = {
        ...getParseError(getExpected),
        expected: getExpected(),
        symbol:
          (_peekStack = peekStack(astStack)) === null || _peekStack === void 0
            ? void 0
            : _peekStack.symbol,
        lexer: lexer.toJSON(),
      };
      ret.errorNode = closeAstWhenError(parseTree, ret.error, astStack);
    }

    return ret;
  };
  var takeCareLLError = function (
    parseTree,
    getExpected,
    onErrorRecovery,
    topSymbol,
    shouldDelete,
    transformNode,
    recoveryTokens,
    ret
  ) {
    ret.error = {
      recovery: false,
      ...getParseError(getExpected),
      expected: getExpected(),
      symbol: peekStack(astStack).symbol,
      lexer: lexer.toJSON(),
    };

    if (onErrorRecovery) {
      const recommendedAction = {};
      lexer.stash();
      const nextToken = lexer.lex();
      lexer.stashPop(); // should delete

      if (topSymbol === nextToken.t || shouldDelete(nextToken)) {
        recommendedAction.action = "del";
      } else if (ret.error.expected.length) {
        recommendedAction.action = "add";
      }

      const localErrorNode = new AstErrorNode({
        error: ret.error,
        ...ret.error.lexer,
      });

      if (parseTree) {
        peekStack(astStack).addChild(localErrorNode);
      }

      const recovery =
        onErrorRecovery(
          {
            errorNode: localErrorNode,
            parseTree: getAstRootNode(astStack, transformNode, true),
          },
          recommendedAction
        ) || {};
      const { action } = recovery;
      peekStack(astStack).children.pop();

      if (!action) {
        ret.errorNode = closeAstWhenError(parseTree, ret.error, astStack);
        ret.breakToEnd = true;
        return ret;
      }

      if (action === "del") {
        ret.error.recovery = true;
        const deleteToken = recoveryTokens.pop();
        deleteToken.recovery = "del";
        ret.token = undefined;
      } else if (action === "add") {
        ret.error.recovery = true;
        ret.token = {
          ...ret.token,
          token: recovery.token,
          text: recovery.text,
          t: lexer.mapSymbol(recovery.token),
          recovery: "add",
        };
        lexer.pushToken(ret.token);
        pushRecoveryTokens(recoveryTokens, ret.token);
      }
    } else {
      ret.errorNode = closeAstWhenError(parseTree, ret.error, astStack);
      ret.breakToEnd = true;
    }

    return ret;
  };
  var takeCareLLAction = function (popSymbolStack, peekSymbolStack) {
    let topSymbol = peekSymbolStack();

    while (topSymbol && typeof topSymbol === "function") {
      topSymbol.call(parser);
      popSymbolStack();
      topSymbol = peekSymbolStack();
    }

    return topSymbol;
  };
  var reduceLLAction = function (
    parseTree,
    topSymbol,
    popSymbolStack,
    peekSymbolStack
  ) {
    while (isProductionEndFlag(topSymbol) || isAddAstNodeFlag(topSymbol)) {
      if (parseTree) {
        let ast = astStack.pop();
        const needAction = ast.done();

        if (needAction) {
          const ruleIndex = ast.internalRuleIndex;
          const production = parser.productions[ruleIndex];
          const action = parser.getProductionAction(production);

          if (action) {
            action.call(parser);
          }
        }

        if (isAddAstNodeFlag(topSymbol)) {
          const stackTop = peekStack(astStack);
          const wrap = new AstSymbolNode({
            id: ++globalSymbolNodeId,
            isWrap: true,
            symbol: ast.symbol,
            label: ast.label,
            children: [ast],
            internalRuleIndex: ast.internalRuleIndex,
          });
          stackTop.children.pop();
          stackTop.addChild(wrap);
          astStack.push(wrap);
        }
      }

      popSymbolStack();
      topSymbol = peekSymbolStack();

      if (!topSymbol) {
        break;
      }
    }

    return topSymbol;
  };
  var prepareLLParse = function () {
    globalSymbolNodeId = 0;
    parser.userData = {};
    symbolStack = [];
    astStack = [
      new AstSymbolNode({
        id: 0,
        children: [],
      }),
    ];
  };
  var endLLParse = function () {
    globalSymbolNodeId = 0;
    parser.userData = {};
    symbolStack = [];
    astStack = [];
  };
  var filterRhs = function (rhs) {
    const ret = [];

    for (const r of rhs) {
      if (typeof r === "string") {
        ret.push(r);
      }
    }

    return ret;
  };
  var isExtraAstNode = function (ast) {
    return ast.children && !ast.children.length;
  };
  var peekStack = function (stack, n = 1) {
    return stack[stack.length - n];
  };
  var getOriginalSymbol = function (s) {
    let uncompressed = lexer.mapReverseSymbol(s); // return uncompressed;

    return parser.prioritySymbolMap[uncompressed] || uncompressed;
  };
  var closeAstWhenError = function (parseTree, error, astStack) {
    const errorNode = new AstErrorNode({
      error,
      ...error.lexer,
    });

    if (parseTree) {
      const top = peekStack(astStack);

      if (top.type === "symbol") {
        top.addChild(errorNode);
      }

      while (astStack.length > 1) {
        const ast = astStack.pop();

        if (ast && ast.type === "symbol" && isExtraAstNode(ast)) {
          const topAst = peekStack(astStack);

          if (topAst.type === "symbol") {
            topAst.children.pop();
            topAst.addChildren(ast.children);
          }
        }
      }
    }

    return errorNode;
  };
  var pushRecoveryTokens = function (recoveryTokens, token) {
    var _recoveryTokens;

    const { EOF_TOKEN } = Lexer.STATIC;
    let eof;

    if (
      ((_recoveryTokens = recoveryTokens[recoveryTokens.length - 1]) === null ||
      _recoveryTokens === void 0
        ? void 0
        : _recoveryTokens.token) === EOF_TOKEN
    ) {
      eof = recoveryTokens.pop();
    }

    recoveryTokens.push(token);

    if (eof && token.token !== EOF_TOKEN) {
      recoveryTokens.push(eof);
    }
  };
  var getParseError = function (getExpected) {
    const expected = getExpected();
    const tips = [];

    if (expected.length) {
      tips.push("'" + expected.join("', '") + "' expected.");
    }

    tips.push("current token: '" + lexer.getCurrentToken().token + "'.");
    const tip = tips.join("\n");
    return {
      errorMessage: [
        "syntax error at line " +
          lexer.lineNumber +
          ":\n" +
          lexer.showDebugInfo(),
        ...tips,
      ].join("\n"),
      tip,
    };
  };
  var cleanAst = function (ast, transformNode) {
    if (!transformNode) {
      return ast;
    }

    if (ast.children) {
      let children;
      let childrenChanged;

      while (true) {
        let changed = false;
        let index = 0;
        children = [];

        for (const c of ast.children) {
          const node = transformNode({
            node: c,
            index,
            parent: ast,
            defaultTransformNode: defaultTransformAstNode,
          });

          if (Array.isArray(node)) {
            children.push(...node);
          } else if (node) {
            children.push(node);
          }

          changed = changed || node !== c;
          index++;
        }

        if (!changed) {
          break;
        } else {
          ast.setChildren(children);
          childrenChanged = true;
        }
      }

      if (childrenChanged && ast.parent) {
        cleanAst(ast.parent, transformNode);
      } else {
        for (const c of children) {
          if (c.type === "symbol") {
            cleanAst(c, transformNode);
          }
        }
      }
    }

    return ast;
  };
  var getAstRootNode = function (astStack, transformNode, raw) {
    var _ast, _ast$children;

    let ast = astStack[0];

    if (!ast) {
      return ast;
    }

    if (ast.type !== "symbol") {
      return ast;
    }

    ast =
      (_ast = ast) === null || _ast === void 0
        ? void 0
        : (_ast$children = _ast.children) === null || _ast$children === void 0
        ? void 0
        : _ast$children[0];

    if (ast && ast.type === "symbol" && ast.symbol === START_TAG) {
      var _ast2, _ast2$children;

      ast =
        (_ast2 = ast) === null || _ast2 === void 0
          ? void 0
          : (_ast2$children = _ast2.children) === null ||
            _ast2$children === void 0
          ? void 0
          : _ast2$children[0];
    }

    if (ast) {
      ast.parent = undefined;
    }

    if (raw) {
      return ast;
    }

    if (ast && ast.type === "token") {
      return ast;
    }

    return ast && cleanAst(ast, transformNode);
  };
  var defaultTransformAstNode = function ({ node, parent }) {
    if (node.type === "token" || node.symbol !== parent.symbol) {
      return node;
    }

    if (node.label || parent.label) {
      if (node.label !== parent.label) {
        return node;
      }
    }

    if (parent.children.length === 1) {
      return node.children;
    }

    return node;
  };
  var isAddAstNodeFlag = function (t) {
    return t === productionAddAstNodeFlag;
  };
  var isProductionEndFlag = function (t) {
    return t === productionEndFlag;
  };
  var isZeroOrMoreSymbol = function (s) {
    return (
      typeof s === "string" && s !== "*?" && s.length > 1 && !!s.match(/\*\??$/)
    );
  };
  var isOneOrMoreSymbol = function (s) {
    return (
      typeof s === "string" && s !== "+?" && s.length > 1 && !!s.match(/\+\??$/)
    );
  };
  var isLazySymbol = function (s) {
    const match = typeof s === "string" && s.match(/(\*|\+|\?)\?$/);
    return match && s.length !== 2;
  };
  var isOptionalSymbol = function (s) {
    return typeof s === "string" && s.length > 1 && !!s.match(/\??\?/);
  };
  var normalizeSymbol = function (s) {
    const ret =
      isOptionalSymbol(s) || isZeroOrMoreSymbol(s) || isOneOrMoreSymbol(s)
        ? s.replace(/(\*|\+|\?)?\??$/, "")
        : s; // ??

    return ret || (s && s.slice(0, -1));
  };
  var VIRTUAL_OPTIONAL_RULE_INDEX = -100;
  var START_TAG = "$START";
  var smUnitBySymbol = {};
  var productionSkipAstNodeSet = undefined;
  var symbolStack = [{}];
  var astStack = [];
  var productionsBySymbol = {};
  var productionAddAstNodeFlag = 1;
  var productionEndFlag = 2;
  var globalSymbolNodeId = 0;
  var Lexer = function (cfg) {
    this.nextTokens = [];

    if (Lexer.supportSticky === undefined) {
      try {
        Lexer.supportSticky = typeof /(?:)/.sticky == "boolean";
      } catch (e) {
        Lexer.supportSticky = false;
      }
    }

    const lexerRuleIndexMap = (this.lexerRuleIndexMap = {
      token: 0,
      regexp: 1,
      action: 2,
      predict: 3,
      state: 4,
      channel: 5,
      more: 6,
    });
    const STATIC = Lexer.STATIC;
    this.tokenSet = new Set([STATIC.EOF_TOKEN, STATIC.UNKNOWN_TOKEN]);
    this.rules = [];
    this.defaultEnv = undefined;
    Object.assign(this, cfg);
    this.rules = this.rules.concat();
    this.regexpIndex = this.isCompress
      ? this.lexerRuleIndexMap.regexp
      : "regexp";
    this.getRuleItem = this.isCompress
      ? this.getRuleItemCompress
      : this.getRuleItemNoCompress;
    this.transformRules();
    this.userData = {};
    const errorRule = (this.errorRule = {
      regexp: this.matchAny,
      token: Lexer.STATIC.UNKNOWN_TOKEN,
    });

    for (const rule of this.rules) {
      const token = this.getRuleItem(rule, "token");

      if (token) {
        this.tokenSet.add(token);
      }
    }

    if (this.isCompress) {
      const errorRuleCompress = (this.errorRule = []);
      errorRuleCompress[lexerRuleIndexMap.token] = errorRule.token;
      errorRuleCompress[lexerRuleIndexMap.regexp] = errorRule.regexp;
    }

    this.resetInput(this.input);
    this.options = {};
  };
  Lexer.prototype = {
    transformRegExp: function (obj, p, disableSticky) {
      const pattern = obj[p];

      if (pattern.test) {
        let source = pattern.source;

        if (source.startsWith("^")) {
          source = source.slice(1);
        }

        var flags = Lexer.supportSticky && !disableSticky ? "gy" : "g";
        if (pattern.multiline) flags += "m";
        if (pattern.ignoreCase) flags += "i";
        if (pattern.unicode) flags += "u";
        obj[p] = new RegExp(source, flags);
      } else if (typeof pattern === "object") {
        for (const k of Object.keys(pattern)) {
          this.transformRegExp(pattern, k);
        }
      }
    },
    hasToken: function (t) {
      return this.tokenSet.has(t);
    },
    transformRules: function () {
      if (Lexer.supportSticky) {
        const { regexpIndex } = this;

        for (const r of this.rules) {
          this.transformRegExp(r, regexpIndex);
        }
      }
    },
    matchAny: function () {
      return this.end < this.input.length ? this.input.charAt(this.end) : false;
    },
    addRule: function (rule) {
      this.rules.push(rule);
      const token = this.getRuleItem(rule, "token");

      if (token) {
        this.tokenSet.add(token);
      }
    },
    resetInput: function (input) {
      this.token = "";
      this.nextTokens = [];
      this.tokens = [];
      this.userData = {};
      this.input = input;
      this.matched = "";
      this.stateStack = [Lexer.STATIC.INITIAL_STATE];
      this.match = "";
      this.text = "";
      this.firstLine = 1;
      this.lineNumber = 1;
      this.lastLine = 1;
      this.start = 0;
      this.end = 0;
      this.firstColumn = 1;
      this.lastColumn = 1;
    },
    getRuleItemNoCompress: function (rule, itemType) {
      return rule[itemType];
    },
    getRuleItemCompress: function (rule, itemType) {
      return rule[this.lexerRuleIndexMap[itemType]];
    },
    getCurrentRules: function () {
      var currentState = this.stateStack[this.stateStack.length - 1],
        rules = [];

      for (const r of this.rules) {
        var state = this.getRuleItem(r, "state");

        if (!state) {
          if (currentState === Lexer.STATIC.INITIAL_STATE) {
            rules.push(r);
          }
        } else if (state.indexOf(currentState) !== -1) {
          rules.push(r);
        }
      }

      rules.push(this.errorRule);
      return rules;
    },
    peekState: function (n = 1) {
      return this.mapReverseState(this.stateStack[this.stateStack.length - n]);
    },
    pushState: function (state) {
      this.stateStack.push(this.mapState(state));
    },
    popState: function (num = 1) {
      var ret;

      while (num--) {
        ret = this.stateStack.pop();
      }

      return ret && this.mapReverseState(ret);
    },
    showDebugInfo: function () {
      var { DEBUG_CONTEXT_LIMIT } = Lexer.STATIC;
      var { matched, match, input } = this;
      matched = matched.slice(0, matched.length - match.length);
      var past =
          (matched.length > DEBUG_CONTEXT_LIMIT ? "..." : "") +
          matched
            .slice(0 - DEBUG_CONTEXT_LIMIT)
            .split("\n")
            .join(" "),
        next = match + input.slice(this.end); //#JSCOVERAGE_ENDIF

      next =
        next.slice(0, DEBUG_CONTEXT_LIMIT).split("\n").join(" ") +
        (next.length > DEBUG_CONTEXT_LIMIT ? "..." : "");
      return past + next + "\n" + new Array(past.length + 1).join("-") + "^";
    },
    mapSymbol: function (n) {
      return n;
    },
    mapReverseSymbol: function (n) {
      return n;
    },
    mapState: function (n) {
      return n;
    },
    mapReverseState: function (n) {
      return n;
    },
    toJSON: function () {
      const currentToken = this.getCurrentToken();
      return {
        t: currentToken.t,
        text: currentToken.text,
        firstLine: currentToken.firstLine,
        firstColumn: currentToken.firstColumn,
        lastLine: currentToken.lastLine,
        lastColumn: currentToken.lastColumn,
        token: currentToken.token,
        start: currentToken.start,
        end: currentToken.end,
      };
    },
    stash: function () {
      this.stashIndex = this.tokens.length;
    },
    stashPop: function () {
      this.nextTokens = [
        ...this.tokens.slice(this.stashIndex),
        ...this.nextTokens,
      ];
      this.tokens.length = this.stashIndex;
    },
    matchRegExp: function (predict, regexp) {
      let ret;

      if (typeof regexp !== "function") {
        regexp.lastIndex = this.end;
        ret = regexp.exec(this.input);

        if (ret && ret.index !== this.end) {
          return null;
        }
      } else {
        ret = regexp.call(this, this);
      }

      if (
        ret &&
        (predict === null || predict === void 0
          ? void 0
          : predict.call(this, ret)) === false
      ) {
        return null;
      }

      return ret;
    },
    pushToken: function (token) {
      var _tokens;

      const tokens = this.tokens;

      if (
        ((_tokens = tokens[tokens.length - 1]) === null || _tokens === void 0
          ? void 0
          : _tokens.token) === Lexer.STATIC.EOF_TOKEN
      ) {
        tokens.pop();
      }

      tokens.push(token);
    },
    lex: function () {
      const { EOF_TOKEN } = Lexer.STATIC;
      let token = this.nextToken();

      while (token.more) {
        const nextToken = this.nextToken();
        nextToken.start = token.start;
        nextToken.firstLine = token.firstLine;
        nextToken.firstColumn = token.firstColumn;
        nextToken.text = token.text + nextToken.text;
        token = nextToken;
      }

      const tokens = this.tokens;
      const lastToken = tokens[tokens.length - 1];

      if (
        lastToken &&
        token.token === EOF_TOKEN &&
        lastToken.token === EOF_TOKEN
      ) {
        return token;
      }

      this.tokens.push(token);

      if (token.channel || !token.token) {
        return this.lex();
      }

      return token;
    },
    getCurrentToken: function () {
      const { tokens } = this;
      return tokens[tokens.length - 1] || this.lex();
    },
    getLastToken: function (filter) {
      const { tokens } = this;
      let index = tokens.length - 2;

      if (filter) {
        while (index >= 0 && filter(tokens[index]) === false) {
          index--;
        }
      }

      return tokens[index] || this.getCurrentToken();
    },
    nextChar: function (index = 0) {
      return this.getChar(this.end + index);
    },
    nextCharCode: function (index = 0) {
      return this.getCharCode(this.end + index);
    },
    nextStartsWith: function (search) {
      let { input, end } = this;
      const l = search.length;

      for (let i = 0; i < l; i++) {
        if (input.charAt(end++) !== search.charAt(i)) {
          return false;
        }
      }

      return true;
    },
    nextCharAt: function (index) {
      return this.input.charAt(this.end + index);
    },
    nextLength: function () {
      return this.input.length - this.end;
    },
    getChar: function (index = 0) {
      if (this.options.unicode) {
        const code = this.input.codePointAt(index);

        if (code === undefined || isNaN(code)) {
          return "";
        }

        return String.fromCodePoint(code);
      }

      return this.input.charAt(index);
    },
    getCharCode: function (index = 0) {
      if (this.options.unicode) {
        return this.input.codePointAt(index);
      }

      return this.input.charCodeAt(index);
    },
    getTokensLength: function () {
      return this.tokens.length;
    },
    nextToken: function () {
      if (this.nextTokens.length) {
        return this.nextTokens.shift();
      }

      var i,
        rule,
        m,
        ret,
        lines,
        rules = this.getCurrentRules();
      var { input } = this;
      var { env = this.defaultEnv } = this.options;
      this.match = this.text = "";

      if (this.end >= input.length) {
        this.token = Lexer.STATIC.EOF_TOKEN;
        this.start = this.end;
        this.firstLine = this.lastLine;
        this.firstColumn = this.lastColumn;
        return {
          text: "",
          t: this.mapSymbol(this.token),
          token: this.token,
          start: this.start,
          end: this.end,
          firstLine: this.firstLine,
          firstColumn: this.firstColumn,
          lastLine: this.lastLine,
          lastColumn: this.lastColumn,
        };
      }

      for (i = 0; i < rules.length; i++) {
        rule = rules[i];
        let regexp = this.getRuleItem(rule, "regexp");
        let token = this.getRuleItem(rule, "token");
        let channel = this.getRuleItem(rule, "channel");
        let action = this.getRuleItem(rule, "action");
        let more = this.getRuleItem(rule, "more");
        let predict = this.getRuleItem(rule, "predict");

        if (
          typeof regexp !== "function" &&
          regexp &&
          env &&
          typeof regexp.test !== "function"
        ) {
          regexp = regexp[env];
        }

        if (!regexp) {
          continue;
        } //#JSCOVERAGE_ENDIF

        if ((m = this.matchRegExp(predict, regexp))) {
          const start = this.end;
          const end = this.end + m[0].length;
          lines = m[0].split("\n");
          lines.shift();
          this.lineNumber += lines.length;
          const position = {
            start: start,
            end: end,
            firstLine: this.lastLine,
            lastLine: this.lineNumber,
            firstColumn: this.lastColumn,
            lastColumn: lines.length
              ? lines[lines.length - 1].length + 1
              : this.lastColumn + m[0].length,
          };

          if (more) {
            position.more = more;
          }

          Object.assign(this, position);
          var match; // for error report

          match = this.match = m[0]; // all matches

          this.matches = m; // may change by user

          this.text = match; // matched content utils now

          this.matched += match;
          ret = action && action.call(this);

          if (ret === undefined) {
            ret = token;
          } else {
            ret = this.mapSymbol(ret);
          }

          if (ret) {
            this.token = this.mapReverseSymbol(ret);
            return {
              text: this.text,
              channel,
              token: this.token,
              t: ret,
              ...position,
            };
          } else {
            // ignore
            return this.nextToken();
          }
        }
      }

      throw new Error("no match lexer");
    },
  };
  Lexer.STATIC = {
    INITIAL_STATE: "I",
    DEBUG_CONTEXT_LIMIT: 20,
    EOF_TOKEN: "$EOF",
    UNKNOWN_TOKEN: "$UNKNOWN",
  };
  var lexer = new Lexer({
    rules: [
      ["ACCESS", /ACCESS\b/gi],
      ["ADDRESSOF", /ADDRESSOF\b/gi],
      ["ALIAS", /ALIAS\b/gi],
      ["AND", /AND\b/gi],
      ["ATTRIBUTE", /ATTRIBUTE\b/gi],
      ["APPACTIVATE", /APPACTIVATE\b/gi],
      ["APPEND", /APPEND\b/gi],
      ["AS", /AS\b/gi],
      ["BEGIN", /BEGIN\b/gi],
      ["BEEP", /BEEP\b/gi],
      ["BINARY", /BINARY\b/gi],
      ["BOOLEAN", /BOOLEAN\b/gi],
      ["BYVAL", /BYVAL\b/gi],
      ["BYREF", /BYREF\b/gi],
      ["BYTE", /BYTE\b/gi],
      ["CALL", /CALL\b/gi],
      ["CASE", /CASE\b/gi],
      ["CHDIR", /CHDIR\b/gi],
      ["CHDRIVE", /CHDRIVE\b/gi],
      ["CLASS", /CLASS\b/gi],
      ["CLOSE", /CLOSE\b/gi],
      ["COLLECTION", /COLLECTION\b/gi],
      ["CONST", /CONST\b/gi],
      ["DATABASE", /DATABASE\b/gi],
      ["DECLARE", /DECLARE\b/gi],
      ["DEFBOOL", /DEFBOOL\b/gi],
      ["DEFBYTE", /DEFBYTE\b/gi],
      ["DEFDATE", /DEFDATE\b/gi],
      ["DEFDBL", /DEFDBL\b/gi],
      ["DEFDEC", /DEFDEC\b/gi],
      ["DEFCUR", /DEFCUR\b/gi],
      ["DEFINT", /DEFINT\b/gi],
      ["DEFLNG", /DEFLNG\b/gi],
      ["DEFOBJ", /DEFOBJ\b/gi],
      ["DEFSNG", /DEFSNG\b/gi],
      ["DEFSTR", /DEFSTR\b/gi],
      ["DEFVAR", /DEFVAR\b/gi],
      ["DELETESETTING", /DELETESETTING\b/gi],
      ["DIM", /DIM\b/gi],
      ["DO", /DO\b/gi],
      ["DOUBLE", /DOUBLE\b/gi],
      ["EACH", /EACH\b/gi],
      ["ELSE", /ELSE\b/gi],
      ["ELSEIF", /ELSEIF\b/gi],
      ["END_ENUM", /END ENUM\b/gi],
      ["END_FUNCTION", /END FUNCTION\b/gi],
      ["END_IF", /END IF\b/gi],
      ["END_PROPERTY", /END PROPERTY\b/gi],
      ["END_SELECT", /END SELECT\b/gi],
      ["END_SUB", /END SUB\b/gi],
      ["END_TYPE", /END TYPE\b/gi],
      ["END_WITH", /END WITH\b/gi],
      ["END", /END\b/gi],
      ["ENUM", /ENUM\b/gi],
      ["EQV", /EQV\b/gi],
      ["ERASE", /ERASE\b/gi],
      ["ERROR", /ERROR\b/gi],
      ["EVENT", /EVENT\b/gi],
      ["EXIT_DO", /EXIT DO\b/gi],
      ["EXIT_FOR", /EXIT FOR\b/gi],
      ["EXIT_FUNCTION", /EXIT FUNCTION\b/gi],
      ["EXIT_PROPERTY", /EXIT PROPERTY\b/gi],
      ["EXIT_SUB", /EXIT SUB\b/gi],
      ["FALSE", /FALSE\b/gi],
      ["FILECOPY", /FILECOPY\b/gi],
      ["FRIEND", /FRIEND\b/gi],
      ["FOR", /FOR\b/gi],
      ["FUNCTION", /FUNCTION\b/gi],
      ["GET", /GET\b/gi],
      ["GLOBAL", /GLOBAL\b/gi],
      ["GOSUB", /GOSUB\b/gi],
      ["GOTO", /GOTO\b/gi],
      ["IF", /IF\b/gi],
      ["IMP", /IMP\b/gi],
      ["IMPLEMENTS", /IMPLEMENTS\b/gi],
      ["IN", /IN\b/gi],
      ["INPUT", /INPUT\b/gi],
      ["IS", /IS\b/gi],
      ["INTEGER", /INTEGER\b/gi],
      ["KILL", /KILL\b/gi],
      ["LOAD", /LOAD\b/gi],
      ["LOCK", /LOCK\b/gi],
      ["LONG", /LONG\b/gi],
      ["LOOP", /LOOP\b/gi],
      ["LEN", /LEN\b/gi],
      ["LET", /LET\b/gi],
      ["LIB", /LIB\b/gi],
      ["LIKE", /LIKE\b/gi],
      ["LINE_INPUT", /LINE INPUT\b/gi],
      ["LOCK_READ", /LOCK READ\b/gi],
      ["LOCK_WRITE", /LOCK WRITE\b/gi],
      ["LOCK_READ_WRITE", /LOCK READ WRITE\b/gi],
      ["LSET", /LSET\b/gi],
      ["MACRO_CONST", /#CONST\b/gi],
      ["MACRO_IF", /#IF\b/gi],
      ["MACRO_ELSEIF", /#ELSEIF\b/gi],
      ["MACRO_ELSE", /#ELSE\b/gi],
      ["MACRO_END_IF", /#END IF\b/gi],
      ["ME", /ME\b/gi],
      ["MID", /MID\b/gi],
      ["MKDIR", /MKDIR\b/gi],
      ["MOD", /MOD\b/gi],
      ["NAME", /NAME\b/gi],
      ["NEXT", /NEXT\b/gi],
      ["NEW", /NEW\b/gi],
      ["NOT", /NOT\b/gi],
      ["NOTHING", /NOTHING\b/gi],
      ["NULL", /NULL\b/gi],
      ["ON", /ON\b/gi],
      ["ON_ERROR", /ON ERROR\b/gi],
      ["ON_LOCAL_ERROR", /ON LOCAL ERROR\b/gi],
      ["OPEN", /OPEN\b/gi],
      ["OPTIONAL", /OPTIONAL\b/gi],
      ["OPTION_BASE", /OPTION BASE\b/gi],
      ["OPTION_EXPLICIT", /OPTION EXPLICIT\b/gi],
      ["OPTION_COMPARE", /OPTION COMPARE\b/gi],
      ["OPTION_PRIVATE_MODULE", /OPTION PRIVATE MODULE\b/gi],
      ["OR", /OR\b/gi],
      ["OUTPUT", /OUTPUT\b/gi],
      ["PARAMARRAY", /PARAMARRAY\b/gi],
      ["PRESERVE", /PRESERVE\b/gi],
      ["PRIVATE", /PRIVATE\b/gi],
      ["PROPERTY_GET", /PROPERTY GET\b/gi],
      ["PROPERTY_LET", /PROPERTY LET\b/gi],
      ["PROPERTY_SET", /PROPERTY SET\b/gi],
      ["PTRSAFE", /PTRSAFE\b/gi],
      ["PUBLIC", /PUBLIC\b/gi],
      ["PUT", /PUT\b/gi],
      ["RANDOM", /RANDOM\b/gi],
      ["RANDOMIZE", /RANDOMIZE\b/gi],
      ["RAISEEVENT", /RAISEEVENT\b/gi],
      ["READ", /READ\b/gi],
      ["READ_WRITE", /READ WRITE\b/gi],
      ["REDIM", /REDIM\b/gi],
      ["RESET", /RESET\b/gi],
      ["RESUME", /RESUME\b/gi],
      ["RETURN", /RETURN\b/gi],
      ["RMDIR", /RMDIR\b/gi],
      ["RSET", /RSET\b/gi],
      ["SAVEPICTURE", /SAVEPICTURE\b/gi],
      ["SAVESETTING", /SAVESETTING\b/gi],
      ["SEEK", /SEEK\b/gi],
      ["SELECT", /SELECT\b/gi],
      ["SENDKEYS", /SENDKEYS\b/gi],
      ["SET", /SET\b/gi],
      ["SETATTR", /SETATTR\b/gi],
      ["SHARED", /SHARED\b/gi],
      ["SINGLE", /SINGLE\b/gi],
      ["SPC", /SPC\b/gi],
      ["STATIC", /STATIC\b/gi],
      ["STEP", /STEP\b/gi],
      ["STOP", /STOP\b/gi],
      ["STRING", /STRING\b/gi],
      ["SUB", /SUB\b/gi],
      ["TAB", /TAB\b/gi],
      ["TEXT", /TEXT\b/gi],
      ["THEN", /THEN\b/gi],
      ["TIME", /TIME\b/gi],
      ["TO", /TO\b/gi],
      ["TRUE", /TRUE\b/gi],
      ["TYPE", /TYPE\b/gi],
      ["TYPEOF", /TYPEOF\b/gi],
      ["UNLOAD", /UNLOAD\b/gi],
      ["UNLOCK", /UNLOCK\b/gi],
      ["UNTIL", /UNTIL\b/gi],
      ["VARIANT", /VARIANT\b/gi],
      ["VERSION", /VERSION\b/gi],
      ["WEND", /WEND\b/gi],
      ["WHILE", /WHILE\b/gi],
      ["WIDTH", /WIDTH\b/gi],
      ["WITH", /WITH\b/gi],
      ["WITHEVENTS", /WITHEVENTS\b/gi],
      ["WRITE", /WRITE\b/gi],
      ["XOR", /XOR\b/gi],
      ["COLON", /:/g],
      ["AMPERSAND", /&/g],
      ["ASSIGN", /:=/g],
      ["DIV", /\//g],
      ["EQ", /=/g],
      ["GEQ", />=/g],
      ["GT", />/g],
      ["LEQ", /<=/g],
      ["LPAREN", /\(/g],
      ["LT", /</g],
      ["MINUS", /\-/g],
      ["MINUS_EQ", /\-=/g],
      ["MULT", /\*/g],
      ["NEQ", /<>/g],
      ["PLUS", /\+/g],
      ["PLUS_EQ", /\+=/g],
      ["POW", /\^/g],
      ["RPAREN", /\)/g],
      ["L_SQUARE_BRACKET", /\[/g],
      ["R_SQUARE_BRACKET", /\]/g],
      ["NEWLINE", /([\r\n]+)/g],
      [
        "REMCOMMENT",
        /(\:?rem((([\u0020\t]+_\r?\n)|[\u0020\t])+)(([\u0020\t]+_\r?\n)|[^\r\n])*)/g,
      ],
      ["COMMENT", /('(([\u0020\t]+_\r?\n)|[^\r\n])*)/g],
      [
        "HIDDEN",
        /((([\u0020\t]+_\r?\n)|[\u0020\t])+)|(\s+)/gi,
        undefined,
        undefined,
        undefined,
        "HIDDEN",
      ],
      ["STRINGLITERAL", /"[^"\r\n]*"/g],
      ["INTEGERLITERAL", /(\+|-)?[0-9]+/g],
      [
        "IDENTIFIER",
        /\w[\w\d]*/g,
        function () {
          this.text = (this.text || "").toLowerCase();
        },
      ],
      ["'|'", /'\|'/g],
      ["'('", /'\('/g],
      ["')'", /'\)'/g],
      ["endOfLine+", /endOfLine\+/g],
      [",", /,/g],
      [".", /\./g],
      ["iCS_S_MemberCall+", /iCS_S_MemberCall\+/g],
      ["!", /!/g],
      ["&", /&/g],
      ["%", /%/g],
      ["#", /#/g],
      ["@", /@/g],
      ["$", /\$/g],
    ],
    isCompress: 1,
    defaultEnv: undefined,
  });
  function lex(input, options = {}) {
    lexer.options = options;
    lexer.resetInput(input);
    const { state } = options;

    if (state) {
      if (state.userData) {
        lexer.userData = state.userData;
      }

      if (state.stateStack) {
        lexer.stateStack = state.stateStack;
      }
    }

    while (lexer.lex().token !== Lexer.STATIC.EOF_TOKEN);

    return {
      state: {
        userData: lexer.userData,
        stateStack: lexer.stateStack,
      },
      tokens: lexer.tokens,
    };
  }
  var parser = {
    productions: [
      ["$START", ["progam"]],
      [
        "progam",
        [
          "moduleDeclarations?",
          "endOfLine*",
          "moduleBody?",
          "endOfLine*",
          "$EOF",
        ],
      ],
      ["endOfLine", ["NEWLINE"]],
      ["endOfLine", ["COMMENT"]],
      ["endOfLine", ["REMCOMMENT"]],
      ["endOfStatement_group_def_2", ["endOfLine"]],
      ["endOfStatement_group_1", ["endOfStatement_group_def_2"]],
      ["endOfStatement_group_def_3", ["COLON"]],
      ["endOfStatement_group_1", ["endOfStatement_group_def_3"]],
      ["endOfStatement", ["endOfStatement_group_1*"]],
      [
        "moduleDeclarations_group_def_5",
        ["endOfLine", "endOfLine*", "moduleDeclarationsElement"],
      ],
      [
        "moduleDeclarations",
        [
          "moduleDeclarationsElement",
          "moduleDeclarations_group_def_5*",
          "endOfLine*",
        ],
      ],
      ["moduleDeclarationsElement", ["variableStmt"]],
      [
        "moduleBody_group_def_7",
        ["endOfLine", "endOfLine*", "moduleBodyElement"],
      ],
      [
        "moduleBody",
        ["moduleBodyElement", "moduleBody_group_def_7*", "endOfLine*"],
      ],
      ["moduleBodyElement", ["functionStmt"]],
      ["moduleBodyElement", ["propertyGetStmt"]],
      ["moduleBodyElement", ["propertySetStmt"]],
      ["moduleBodyElement", ["propertyLetStmt"]],
      ["moduleBodyElement", ["subStmt"]],
      ["visibility", ["PRIVATE"]],
      ["visibility", ["PUBLIC"]],
      ["visibility", ["FRIEND"]],
      ["visibility", ["GLOBAL"]],
      [
        "subStmt",
        [
          "visibility?",
          "STATIC?",
          "SUB",
          "ambiguousIdentifier",
          "argList?",
          "endOfStatement",
          "block?",
          "END_SUB",
        ],
      ],
      [
        "propertyGetStmt",
        [
          "visibility?",
          "STATIC?",
          "PROPERTY_GET",
          "ambiguousIdentifier",
          "typeHint?",
          "LPAREN",
          "RPAREN",
          "asTypeClause?",
          "endOfStatement",
          "block?",
          "END_PROPERTY",
        ],
      ],
      [
        "propertySetStmt",
        [
          "visibility?",
          "STATIC?",
          "PROPERTY_SET",
          "ambiguousIdentifier",
          "argList?",
          "endOfStatement",
          "block?",
          "END_PROPERTY",
        ],
      ],
      [
        "propertyLetStmt",
        [
          "visibility?",
          "STATIC?",
          "PROPERTY_LET",
          "ambiguousIdentifier",
          "argList?",
          "endOfStatement",
          "block?",
          "END_PROPERTY",
        ],
      ],
      [
        "functionStmt",
        [
          "visibility?",
          "STATIC?",
          "FUNCTION",
          "ambiguousIdentifier",
          "typeHint?",
          "argList?",
          "asTypeClause?",
          "endOfStatement",
          "block?",
          "END_FUNCTION",
        ],
      ],
      ["block_group_def_9", ["endOfStatement", "blockStmt"]],
      ["block", ["blockStmt", "block_group_def_9*", "endOfStatement"]],
      ["blockStmt", ["eraseStmt"]],
      ["blockStmt", ["exitStmt"]],
      ["blockStmt", ["explicitCallStmt"]],
      ["blockStmt", ["setStmt"]],
      ["blockStmt", ["redimStmt"]],
      ["blockStmt", ["letStmt"]],
      ["blockStmt", ["variableStmt"]],
      ["blockStmt", ["implicitCallStmt_InBlock"]],
      ["eraseStmt_group_def_11", [",", "valueStmt"]],
      ["eraseStmt", ["ERASE", "valueStmt", "eraseStmt_group_def_11*"]],
      ["redimStmt_group_def_13", [",", "redimSubStmt"]],
      [
        "redimStmt",
        ["REDIM", "PRESERVE?", "redimSubStmt", "redimStmt_group_def_13*"],
      ],
      [
        "redimSubStmt",
        [
          "implicitCallStmt_InStmt",
          "LPAREN",
          "subscripts",
          "RPAREN",
          "asTypeClause?",
        ],
      ],
      ["exitStmt", ["EXIT_DO"]],
      ["exitStmt", ["EXIT_FOR"]],
      ["exitStmt", ["EXIT_FUNCTION"]],
      ["exitStmt", ["EXIT_PROPERTY"]],
      ["exitStmt", ["EXIT_SUB"]],
      ["exitStmt", ["END"]],
      ["letStmt_group_def_15", ["EQ"]],
      ["letStmt_group_14", ["letStmt_group_def_15"]],
      ["letStmt_group_def_16", ["PLUS_EQ"]],
      ["letStmt_group_14", ["letStmt_group_def_16"]],
      ["letStmt_group_def_17", ["MINUS_EQ"]],
      ["letStmt_group_14", ["letStmt_group_def_17"]],
      [
        "letStmt",
        ["LET?", "implicitCallStmt_InStmt", "letStmt_group_14", "valueStmt"],
      ],
      ["setStmt", ["SET", "implicitCallStmt_InStmt", "EQ", "valueStmt"]],
      ["explicitCallStmt", ["eCS_MemberProcedureCall"]],
      ["explicitCallStmt", ["eCS_ProcedureCall"]],
      [
        "eCS_MemberProcedureCall_group_def_19",
        ["LPAREN", "argsCall", "RPAREN"],
      ],
      ["eCS_MemberProcedureCall_group_def_21", ["LPAREN", "indexes", "RPAREN"]],
      [
        "eCS_MemberProcedureCall",
        [
          "CALL",
          "implicitCallStmt_InStmt?",
          ".",
          "ambiguousIdentifier",
          "typeHint?",
          "eCS_MemberProcedureCall_group_def_19?",
          "eCS_MemberProcedureCall_group_def_21?",
        ],
      ],
      [
        "eCS_ProcedureCall",
        [
          "CALL",
          "ambiguousIdentifier",
          "typeHint?",
          "eCS_MemberProcedureCall_group_def_19?",
          "eCS_MemberProcedureCall_group_def_21?",
        ],
      ],
      ["implicitCallStmt_InBlock", ["iCS_B_MemberProcedureCall"]],
      ["implicitCallStmt_InBlock", ["iCS_B_ProcedureCall"]],
      [
        "iCS_B_MemberProcedureCall",
        [
          "implicitCallStmt_InStmt",
          ".",
          "ambiguousIdentifier",
          "typeHint?",
          "argsCall?",
          "dictionaryCallStmt?",
          "eCS_MemberProcedureCall_group_def_21?",
        ],
      ],
      ["iCS_B_ProcedureCall_group_def_26", ["LPAREN", "subscripts", "RPAREN"]],
      [
        "iCS_B_ProcedureCall",
        [
          "ambiguousIdentifier",
          "argsCall?",
          "iCS_B_ProcedureCall_group_def_26?",
        ],
      ],
      ["argsCall_group_def_28", [",", "argCall?"]],
      ["argsCall", ["argCall?", "argsCall_group_def_28*"]],
      ["argCall_group_def_30", ["BYREF"]],
      ["argCall_group_29", ["argCall_group_def_30"]],
      ["argCall_group_def_31", ["BYVAL"]],
      ["argCall_group_29", ["argCall_group_def_31"]],
      ["argCall_group_def_32", ["PARAMARRAY"]],
      ["argCall_group_29", ["argCall_group_def_32"]],
      ["argCall", ["LPAREN?", "argCall_group_29?", "RPAREN?", "valueStmt"]],
      ["variableStmt_group_def_34", ["DIM"]],
      ["variableStmt_group_33", ["variableStmt_group_def_34"]],
      ["variableStmt_group_def_35", ["STATIC"]],
      ["variableStmt_group_33", ["variableStmt_group_def_35"]],
      ["variableStmt_group_def_36", ["visibility"]],
      ["variableStmt_group_33", ["variableStmt_group_def_36"]],
      [
        "variableStmt",
        ["variableStmt_group_33", "WITHEVENTS?", "variableListStmt"],
      ],
      ["variableListStmt_group_def_38", [",", "variableSubStmt"]],
      [
        "variableListStmt",
        ["variableSubStmt", "variableListStmt_group_def_38*"],
      ],
      ["variableSubStmt_group_def_40", ["LPAREN", "subscripts?", "RPAREN"]],
      [
        "variableSubStmt",
        [
          "ambiguousIdentifier",
          "variableSubStmt_group_def_40?",
          "typeHint?",
          "asTypeClause?",
        ],
      ],
      ["indexes", ["valueStmt", "eraseStmt_group_def_11*"]],
      ["subscript__group_def_43", ["valueStmt", "TO"]],
      ["subscript_", ["subscript__group_def_43?", "valueStmt"]],
      ["subscripts_group_def_45", [",", "subscript_"]],
      ["subscripts", ["subscript_", "subscripts_group_def_45*"]],
      ["subscript_", ["subscript__group_def_43?", "valueStmt"]],
      ["argList_group_def_49", [",", "arg"]],
      ["argList_group_def_50", ["arg", "argList_group_def_49*"]],
      ["argList", ["LPAREN", "argList_group_def_50?", "RPAREN"]],
      ["valueStmt", ["literal"]],
      ["valueStmt", ["implicitCallStmt_InStmt"]],
      ["implicitCallStmt_InStmt", ["iCS_S_MembersCall"]],
      ["implicitCallStmt_InStmt", ["iCS_S_VariableOrProcedureCall"]],
      ["implicitCallStmt_InStmt", ["iCS_S_ProcedureOrArrayCall"]],
      ["iCS_S_MembersCall_group_def_52", ["iCS_S_VariableOrProcedureCall"]],
      ["iCS_S_MembersCall_group_51", ["iCS_S_MembersCall_group_def_52"]],
      ["iCS_S_MembersCall_group_def_53", ["iCS_S_ProcedureOrArrayCall"]],
      ["iCS_S_MembersCall_group_51", ["iCS_S_MembersCall_group_def_53"]],
      [
        "iCS_S_MembersCall",
        [
          "iCS_S_MembersCall_group_51?",
          "iCS_S_MemberCall",
          "iCS_S_MemberCall*",
          "dictionaryCallStmt?",
          "eCS_MemberProcedureCall_group_def_21?",
        ],
      ],
      ["iCS_S_MemberCall_group_def_56", ["."]],
      ["iCS_S_MemberCall_group_55", ["iCS_S_MemberCall_group_def_56"]],
      ["iCS_S_MemberCall_group_def_57", ["!"]],
      ["iCS_S_MemberCall_group_55", ["iCS_S_MemberCall_group_def_57"]],
      ["iCS_S_MemberCall_group_58", ["iCS_S_MembersCall_group_def_52"]],
      ["iCS_S_MemberCall_group_58", ["iCS_S_MembersCall_group_def_53"]],
      [
        "iCS_S_MemberCall",
        ["iCS_S_MemberCall_group_55", "iCS_S_MemberCall_group_58"],
      ],
      [
        "iCS_S_ProcedureOrArrayCall",
        [
          "ambiguousIdentifier",
          "typeHint?",
          "LPAREN",
          "argsCall?",
          "RPAREN",
          "dictionaryCallStmt?",
          "eCS_MemberProcedureCall_group_def_21?",
        ],
      ],
      [
        "iCS_S_VariableOrProcedureCall",
        [
          "ambiguousIdentifier",
          "typeHint?",
          "dictionaryCallStmt?",
          "eCS_MemberProcedureCall_group_def_21?",
        ],
      ],
      ["dictionaryCallStmt", ["!", "ambiguousIdentifier", "typeHint?"]],
      ["literal", ["INTEGERLITERAL"]],
      ["literal", ["STRINGLITERAL"]],
      ["typeHint", ["&"]],
      ["typeHint", ["%"]],
      ["typeHint", ["#"]],
      ["typeHint", ["!"]],
      ["typeHint", ["@"]],
      ["typeHint", ["$"]],
      ["arg_group_61", ["argCall_group_def_31"]],
      ["arg_group_61", ["argCall_group_def_30"]],
      ["arg_group_def_63", ["LPAREN", "RPAREN"]],
      [
        "arg",
        [
          "OPTIONAL?",
          "arg_group_61?",
          "PARAMARRAY?",
          "ambiguousIdentifier",
          "typeHint?",
          "arg_group_def_63?",
          "asTypeClause?",
          "argDefaultValue?",
        ],
      ],
      ["argDefaultValue", ["EQ", "valueStmt"]],
      ["asTypeClause", ["AS", "NEW?", "type_", "fieldLength?"]],
      ["type__group_def_65", ["baseType"]],
      ["type__group_64", ["type__group_def_65"]],
      ["type__group_def_66", ["complexType"]],
      ["type__group_64", ["type__group_def_66"]],
      ["type_", ["type__group_64", "arg_group_def_63?"]],
      ["complexType_group_69", ["iCS_S_MemberCall_group_def_56"]],
      ["complexType_group_69", ["iCS_S_MemberCall_group_def_57"]],
      [
        "complexType_group_def_70",
        ["complexType_group_69", "ambiguousIdentifier"],
      ],
      ["complexType", ["ambiguousIdentifier", "complexType_group_def_70*"]],
      ["baseType", ["BOOLEAN"]],
      ["baseType", ["BYTE"]],
      ["baseType", ["COLLECTION"]],
      ["baseType", ["DOUBLE"]],
      ["baseType", ["INTEGER"]],
      ["baseType", ["LONG"]],
      ["baseType", ["SINGLE"]],
      ["baseType", ["VARIANT"]],
      ["baseType_group_def_72", ["MULT", "valueStmt"]],
      ["baseType", ["STRING", "baseType_group_def_72?"]],
      ["fieldLength", ["MULT", "INTEGERLITERAL"]],
      ["fieldLength", ["MULT", "ambiguousIdentifier"]],
      ["ambiguousIdentifier", ["IDENTIFIER"]],
    ],
    productionIndexMap: {
      symbol: 0,
      rhs: 1,
      action: 2,
      label: 3,
      predict: 4,
      isWrap: 5,
    },
    isCompress: 1,
    getProductionItemByType: function (p, itemType) {
      if (this.isCompress) {
        return p && p[this.productionIndexMap[itemType]];
      }

      return p && p[itemType];
    },
    getProductionSymbol: function (p) {
      return this.getProductionItemByType(p, "symbol");
    },
    getProductionRhs: function (p) {
      return this.getProductionItemByType(p, "rhs");
    },
    getProductionAction: function (p) {
      return this.getProductionItemByType(p, "action");
    },
    getProductionPredict: function (p) {
      return this.getProductionItemByType(p, "predict");
    },
    getProductionIsWrap: function (p) {
      return this.getProductionItemByType(p, "isWrap");
    },
    getProductionLabel: function (p) {
      return this.getProductionItemByType(p, "label");
    },
    getCurrentSymbolNode: function () {
      return astStack[astStack.length - 1];
    },
  };
  parser.getProductionItemByType = parser.getProductionItemByType.bind(parser);
  parser.getProductionSymbol = parser.getProductionSymbol.bind(parser);
  parser.getProductionRhs = parser.getProductionRhs.bind(parser);
  parser.getProductionAction = parser.getProductionAction.bind(parser);
  parser.getProductionPredict = parser.getProductionPredict.bind(parser);
  parser.getProductionIsWrap = parser.getProductionIsWrap.bind(parser);
  parser.getProductionLabel = parser.getProductionLabel.bind(parser);
  parser.getCurrentSymbolNode = parser.getCurrentSymbolNode.bind(parser);
  parser.lexer = lexer;
  parser.lex = lex;
  parser.prioritySymbolMap = {};
  productionSkipAstNodeSet = new Set([
    5, 6, 7, 8, 10, 13, 29, 39, 41, 50, 51, 52, 53, 54, 55, 60, 61, 67, 69, 71,
    72, 73, 74, 75, 76, 78, 79, 80, 81, 82, 83, 85, 87, 90, 92, 95, 96, 103,
    104, 105, 106, 108, 109, 110, 111, 112, 113, 126, 127, 128, 132, 133, 134,
    135, 137, 138, 139, 149,
  ]);
  var parse = function (input, options = {}) {
    prepareLLParse();
    let recoveryTokens = [];
    const terminalNodes = [];
    let error;
    var {
      getProductionIsWrap,
      productions,
      getProductionSymbol,
      getProductionRhs,
      getProductionLabel,
    } = parser;
    var {
      globalMatch = true,
      onErrorRecovery,
      lexerOptions = {},
      transformNode,
      parseTree = true,
      startSymbol = getProductionSymbol(productions[0]),
    } = options;
    startSymbol = lexer.mapSymbol(startSymbol);

    if (transformNode !== false && !transformNode) {
      transformNode = defaultTransformAstNode;
    }

    lexer.options = lexerOptions;
    symbolStack = [startSymbol];
    lexer.resetInput(input);
    let token = undefined;
    let next = null;
    let topSymbol;
    let errorNode;

    function peekSymbolStack(n = 1) {
      let index = symbolStack.length - n;
      let currentSymbolItem = symbolStack[index];

      while (
        currentSymbolItem &&
        typeof currentSymbolItem === "object" &&
        currentSymbolItem.type === "rule"
      ) {
        index--;
        currentSymbolItem = symbolStack[index];
      }

      return symbolStack[index];
    }

    function popSymbolStack() {
      while (true) {
        const t = symbolStack.pop();

        if (!t || typeof t !== "object" || t.type !== "rule") {
          break;
        }
      }

      let l = symbolStack.length - 1;
      let current = symbolStack[l];

      while (
        current &&
        typeof current === "object" &&
        current.type === "rule"
      ) {
        symbolStack.pop();
        current = symbolStack[--l];
      }
    }

    let getExpected = function () {
      const s = topSymbol;

      if (typeof s === "string" && !isSymbol(s)) {
        return [lexer.mapReverseSymbol(s)];
      } // get expected tokens from state machine

      return findExpectedTokenFromStateMachine(findSymbolIndex()).map((s) =>
        lexer.mapReverseSymbol(s)
      );
    };

    function makeRuleIndexFlag(ruleIndex, ruleUnit) {
      return {
        type: "rule",
        ruleUnit,
        tokensLength: lexer.getTokensLength(),
        ruleIndex,
      };
    }

    function findSymbolIndex() {
      let i = -1;
      let top = symbolStack.length - 1;
      let ruleIndex = -1;

      while (top >= 0 && symbolStack[top] !== topSymbol) {
        top--;
      }

      let current = symbolStack[top];

      while (
        current &&
        (typeof current !== "object" || current.type !== "rule")
      ) {
        if (typeof current === "string") {
          i++;
        }

        top--;
        current = symbolStack[top];
      }

      if (current && typeof current === "object" && current.type === "rule") {
        ruleIndex = current.ruleIndex;
      }

      return {
        childReverseIndex: i,
        ruleIndex,
        topSymbol,
      };
    }

    let production;

    while (1) {
      topSymbol = peekSymbolStack();

      if (!topSymbol) {
        break;
      }

      topSymbol = reduceLLAction(
        parseTree,
        topSymbol,
        popSymbolStack,
        peekSymbolStack
      );

      if (typeof topSymbol === "string") {
        if (!token) {
          token = lexer.lex();
          pushRecoveryTokens(recoveryTokens, token);
        }

        const normalizedSymbol = normalizeSymbol(topSymbol);
        next = null;

        if (isSymbol(normalizedSymbol)) {
          next = predictProductionIndexLLK(globalMatch, findSymbolIndex());
        } else if (
          normalizedSymbol === token.t ||
          normalizedSymbol === `$ANY`
        ) {
          if (!isZeroOrMoreSymbol(topSymbol)) {
            popSymbolStack();
          }

          const terminalNode = new AstTokenNode(token);
          terminalNodes.push(terminalNode);
          const parent = peekStack(astStack);
          parent.addChild(terminalNode);
          token = lexer.lex();
          pushRecoveryTokens(recoveryTokens, token);
          continue;
        }

        if (next) {
          if (!isZeroOrMoreSymbol(topSymbol)) {
            popSymbolStack();
          }

          const { ruleIndex, unit } = next;
          production = productions[ruleIndex];

          if (
            productionSkipAstNodeSet !== null &&
            productionSkipAstNodeSet !== void 0 &&
            productionSkipAstNodeSet.has(ruleIndex)
          ) {
            const newRhs = getLabeledRhsForAddNodeFlag(production, [
              ...getProductionRhs(production),
              makeRuleIndexFlag(ruleIndex, unit),
            ]);
            symbolStack.push.apply(symbolStack, newRhs.reverse());
          } else {
            const label = getOriginalSymbol(getProductionLabel(production));
            const isWrap = getProductionIsWrap(production);

            if (parseTree) {
              const newAst = new AstSymbolNode({
                internalRuleIndex: ruleIndex,
                id: ++globalSymbolNodeId,
                symbol: getOriginalSymbol(normalizeSymbol(topSymbol)),
                label,
                isWrap,
                children: [],
              });
              peekStack(astStack).addChild(newAst);
              astStack.push(newAst);
            }

            const newRhs = [
              ...getProductionRhs(production),
              makeRuleIndexFlag(ruleIndex, unit),
              productionEndFlag,
            ].reverse();
            symbolStack.push(...newRhs);
          }
        } else if (
          isZeroOrMoreSymbol(topSymbol) ||
          isOptionalSymbol(topSymbol)
        ) {
          popSymbolStack();
        } else {
          let breakToEnd;
          ({ error, errorNode, token, breakToEnd } = takeCareLLError(
            parseTree,
            getExpected,
            onErrorRecovery,
            topSymbol,
            () =>
              !!predictProductionIndexNextLLK(globalMatch, findSymbolIndex()),
            transformNode,
            recoveryTokens,
            {
              error,
              errorNode,
              token,
            }
          ));

          if (breakToEnd) {
            break;
          }
        }
      }

      topSymbol = takeCareLLAction(popSymbolStack, peekSymbolStack);

      if (!symbolStack.length) {
        break;
      }
    }

    ({ error, errorNode } = checkLLEndError(parseTree, getExpected, {
      error,
      errorNode,
    }));
    const ast = parseTree ? getAstRootNode(astStack, transformNode) : null;
    endLLParse();
    return {
      ast,
      tokens: lexer.tokens,
      recoveryTokens,
      errorNode,
      error,
      terminalNodes,
    };
  };
  var predictProductionIndexLLK = function (
    // expensive
    globalMatch,
    { childReverseIndex, ruleIndex, topSymbol },
    fn
  ) {
    let unit;
    let lastUnit;
    let endState;

    if (ruleIndex === -1) {
      lastUnit = unit = getUnitBySymbol(topSymbol);
    } else {
      let parentSymbolItem = getParentSymbolItem();

      if (!parentSymbolItem) {
        throw new Error("no parent symbol");
      }

      const parentUnit = parentSymbolItem.ruleUnit;
      const { units } = parentUnit;
      unit = units[units.length - 1 - childReverseIndex];
      lastUnit = units[units.length - 1];
    }

    const childSymbol = unit.type;

    if (!isSymbol(unit.type)) {
      return null;
    }

    const { unitType } = unit;

    function getSkipCheckStates(unit) {
      const u = unit;
      let states = u.checkStates;

      if (!states) {
        u.checkStates = states = [];
        const skipStartState = new State(
          "startOfSkip$" + childSymbol,
          null,
          VIRTUAL_OPTIONAL_RULE_INDEX
        );
        skipStartState.pushTransition(unit.end);
        const symbolUnit = new SymbolStateUnit(childSymbol, -2);
        symbolUnit.end.pushTransition(unit.end);
        states.push(
          skipStartState,
          ...symbolUnit.start.getAlternativeStartStates()
        );
      }

      return states;
    }

    let nextUnits;
    let startState;

    function returnNext(ruleIndex) {
      const nextUnit = nextUnits[ruleIndex];
      return {
        ruleIndex,
        unit: nextUnit,
      };
    }

    if (unit.lazy) {
      lexer.stash();

      if (fn) {
        fn();
      }

      let states = getSkipCheckStates(unit);
      endState = lastUnit.end;
      const ruleIndexes = findBestAlternation(
        childSymbol,
        states,
        globalMatch ? null : endState
      );
      lexer.stashPop();

      if (
        ruleIndexes[0] === VIRTUAL_OPTIONAL_RULE_INDEX ||
        ruleIndexes.length === 0
      ) {
        // skip this symbol first
        return null;
      } else {
        startState = unit.start.transitions[0].to;

        if (startState.classType !== "SymbolState") {
          throw new Error("expect SymbolState!");
        }

        nextUnits = startState.getUnits();
        return returnNext(Array.from(ruleIndexes.values())[0]);
      }
    }

    const canSkipped = unitType === "zeroOrMore" || unitType === "optional";
    let startStates = [];

    if (canSkipped) {
      startState = unit.start.transitions[0].to;

      if (startState.classType !== "SymbolState") {
        throw new Error("expect SymbolState!");
      }

      nextUnits = startState.getUnits();
      startStates = getSkipCheckStates(unit);
      endState = lastUnit.end;
    } else {
      const alternatives = productionsBySymbol[childSymbol];
      startState = unit.start;

      if (startState.classType !== "SymbolState") {
        throw new Error("expect SymbolState!");
      }

      nextUnits = startState.getUnits();

      if (alternatives.ruleIndexes.length <= 1) {
        const ruleIndex = alternatives.ruleIndexes[0];

        if (ruleIndex === undefined) {
          throw new Error("no predict!");
        }

        return returnNext(ruleIndex);
      }

      startStates = startState.getAlternativeStartStates();
      endState = lastUnit.end;
    }

    lexer.stash();

    if (fn) {
      fn();
    }

    const ruleIndexes = findBestAlternation(
      childSymbol,
      startStates,
      globalMatch ? null : endState
    );
    lexer.stashPop();

    if (ruleIndexes[0] === VIRTUAL_OPTIONAL_RULE_INDEX) {
      ruleIndexes.shift();
    }

    if (ruleIndexes.length) {
      return returnNext(ruleIndexes[0]);
    }

    return null;
  };
  var predictProductionIndexNextLLK = function (globalMatch, arg) {
    return predictProductionIndexLLK(globalMatch, arg, () => lexer.lex());
  };
  var RootSymbolUnit = class RootSymbolUnit {
    units = [];
    start = null;
    end = null;
    lazy = false;
    unitType = "rootSymbol";

    constructor(type, ruleIndex) {
      this.type = type;
      this.ruleIndex = ruleIndex;
    }
  };
  var State = class State {
    classType = "State";
    transitions = [];

    constructor(type, unit, ruleIndex) {
      this.type = type;
      this.unit = unit;
      this.ruleIndex = ruleIndex;
      this.transitions = [];
    }

    pushTransition(endState, condition) {
      this.transitions.push(new Transition(endState, condition));
    }
  };
  var StateUnit = class StateUnit {
    units = undefined;
    unitType = "token";
    lazy = false;

    constructor(type, ruleIndex) {
      this.type = type;
      this.ruleIndex = ruleIndex;
      this.start = new State(`startOf${type}`, this, ruleIndex);
      this.end = new State(`endOf${type}`, this, ruleIndex);
    }
  };
  var SymbolState = class SymbolState {
    classType = "SymbolState";
    units = {};
    _afterTransitions = [];
    _beforeTransitions = [];

    constructor(symbol, type, unit, ruleIndex) {
      this.symbol = symbol;
      this.type = type;
      this.unit = unit;
      this.ruleIndex = ruleIndex;
      this.startStates = [];
    }

    get transitions() {
      let transitions = this.alltransitions;

      if (!transitions) {
        const { symbol, unit, startStates, units } = this;
        this.alltransitions = transitions = [];
        const myProductions = productionsBySymbol[symbol];

        if (!myProductions) {
          throw new Error("unexpected productionsBySymbol: " + symbol);
        }

        for (const i of myProductions.ruleIndexes) {
          const p = myProductions.productions[i];
          const rhs = parser.getProductionRhs(p);
          const rootSymbolUnit = buildRhsSM(symbol, rhs, i);
          units[i] = rootSymbolUnit;
          startStates.push(rootSymbolUnit.start);
          transitions.push(new Transition(rootSymbolUnit.start));
          rootSymbolUnit.end.pushTransition(unit.end);
        }

        this.alltransitions = transitions = [
          ...this._beforeTransitions,
          ...transitions,
          ...this._afterTransitions,
        ];
      }

      return transitions;
    }

    getTransitions() {
      return this.transitions;
    }

    getUnits() {
      this.getTransitions();
      return this.units;
    }

    getAlternativeStartStates() {
      this.getTransitions();
      let startStates = [];
      const { productions, getProductionPredict } = parser;

      for (const s of this.startStates) {
        const ruleIndex = s.ruleIndex;
        const production = productions[ruleIndex];
        const predict = getProductionPredict(production);

        if (!predict || predict.call(parser) !== false) {
          startStates.push(s);
        }
      }

      return startStates;
    }

    pushBeforeTransition(endState, condition) {
      this._beforeTransitions.push(new Transition(endState, condition));
    }

    pushTransition(endState, condition) {
      this._afterTransitions.push(new Transition(endState, condition));
    }
  };
  var SymbolStateUnit = class SymbolStateUnit {
    unitType = "symbol";
    lazy = false;

    constructor(type, ruleIndex) {
      this.type = type;
      this.ruleIndex = ruleIndex;
      this.end = new State(`endOf${type}`, this, ruleIndex);
      this.start = new SymbolState(type, `startOf${type}`, this, ruleIndex);
    }
  };
  var Transition = class Transition {
    constructor(to, condition) {
      this.to = to;
      this.condition = condition;
    }

    perform() {
      if (this.condition) {
        const ret = this.condition();

        if (ret === true) {
          return {
            count: 0,
          };
        }

        return ret;
      }

      return {
        count: 0,
      };
    }
  };
  var buildRhsSM = function (symbol, rhs, ruleIndex) {
    function getUnit(rr) {
      if (isSymbol(rr)) {
        return new SymbolStateUnit(rr, ruleIndex);
      }

      const unit = new StateUnit(rr, ruleIndex);
      unit.start.pushTransition(unit.end, createTokenMatcher(rr));
      return unit;
    }

    const units = [];

    for (const r of rhs) {
      if (typeof r !== "string") {
        continue;
      }

      let finalUnit;

      if (isOptionalSymbol(r)) {
        const rr = normalizeSymbol(r);
        const unit = getUnit(rr);
        finalUnit = new StateUnit(rr, ruleIndex);
        finalUnit.unitType = "optional";

        if (isLazySymbol(r)) {
          finalUnit.lazy = true;
        }

        finalUnit.start.pushTransition(unit.start);
        finalUnit.start.pushTransition(finalUnit.end);
        unit.end.pushTransition(finalUnit.end);
      } else if (isZeroOrMoreSymbol(r)) {
        const rr = normalizeSymbol(r);
        const unit = getUnit(rr);
        finalUnit = new StateUnit(rr, ruleIndex);
        finalUnit.unitType = "zeroOrMore";

        if (isLazySymbol(r)) {
          finalUnit.lazy = true;
        }

        finalUnit.start.pushTransition(unit.start);
        unit.start.pushTransition(finalUnit.end);
        unit.end.pushTransition(unit.start);
      } else {
        finalUnit = getUnit(r);
      }

      units.push(finalUnit);
    }

    return concatUnits(symbol, units, ruleIndex);
  };
  var concatUnits = function (type, us, ruleIndex) {
    const l = us.length;

    for (let i = 0; i < l - 1; i++) {
      const first = us[i];
      const s = us[i + 1];
      first.end.pushTransition(s.start);
    }

    const ret = new RootSymbolUnit(type, ruleIndex);

    if (us[0] && us[l - 1]) {
      ret.start = us[0].start;
      ret.end = us[l - 1].end;
    } else {
      ret.start = new State(`startOf${type}`, ret, ruleIndex);
      ret.end = new State(`endOf${type}`, ret, ruleIndex);
      ret.start.pushTransition(ret.end);
    }

    ret.units = us;
    return ret;
  };
  var findExpectedTokenFromStateMachine = function (
    { childReverseIndex },
    stack = new Set()
  ) {
    const ret = new Set();
    const { ruleUnit: parentUnit } = getParentSymbolItem();
    const { units } = parentUnit;
    let unit = units[units.length - 1 - childReverseIndex];
    const states = [unit.start];

    while (states.length) {
      const state = states.pop();

      if (stack.has(state)) {
        continue;
      }

      stack.add(state);

      for (const t of state.transitions) {
        var _t$condition;

        if (
          (_t$condition = t.condition) !== null &&
          _t$condition !== void 0 &&
          _t$condition.token
        ) {
          ret.add(t.condition.token);
          continue;
        }

        if (t.to) {
          states.push(t.to);
        }
      }
    }

    return Array.from(ret);
  };
  var getParentSymbolItem = function () {
    let parentSymbolItem;

    for (let i = symbolStack.length - 1; i >= 0; i--) {
      const s = symbolStack[i];

      if ((s === null || s === void 0 ? void 0 : s.type) === "rule") {
        parentSymbolItem = s;
        break;
      }
    }

    return parentSymbolItem;
  };
  var getUnitBySymbol = function (symbol) {
    if (!smUnitBySymbol[symbol]) {
      smUnitBySymbol[symbol] = new SymbolStateUnit(symbol, -1);
    }

    return smUnitBySymbol[symbol];
  };
  var isSymbol = function (s) {
    return !!productionsBySymbol[s];
  };
  var findBestAlternation = function (_forSymbol, states, endState) {
    //console.log('start findBestAlternation: ' + _forSymbol);
    //const start = Date.now();
    let reachableStates = [];

    for (const state of states) {
      reachableStates.push({
        state,
        ruleIndexes: [state.ruleIndex],
      });
    }

    let ruleIndexes = new Map(); //const times = [];

    let count = 0;

    while (1) {
      //const start = Date.now();
      reachableStates = getNextReachableStateItems(
        reachableStates,
        ruleIndexes,
        endState,
        count
      );

      if (
        reachableStates.length === 1 &&
        !ruleIndexes.has(VIRTUAL_OPTIONAL_RULE_INDEX)
      ) {
        const values = new Set(ruleIndexes.values());

        if (
          !values.size ||
          (values.size === 1 && Array.from(values)[0] === 0)
        ) {
          ruleIndexes.set(reachableStates[0].ruleIndexes[0], count + 1);
          break;
        }
      } //times.push(Date.now() - start);

      if (reachableStates.length) {
        ++count;
        lexer.lex();
      } else {
        break;
      }
    }

    let arr = Array.from(ruleIndexes.keys());

    if (arr.length > 1) {
      if (ruleIndexes.has(VIRTUAL_OPTIONAL_RULE_INDEX)) {
        ruleIndexes.set(VIRTUAL_OPTIONAL_RULE_INDEX, 0xffff);
      }

      arr = arr.sort((a, b) => {
        const ret = ruleIndexes.get(b) - ruleIndexes.get(a);

        if (ret === 0) {
          return a - b;
        }

        return ret;
      });
    } // const time = Date.now() - start;
    // console.log('');
    // const time=0
    // console.log(_forSymbol + ' findBestAlternation: ' + time + ' ' + arr);
    // for(const a of arr){
    //   if(a===VIRTUAL_OPTIONAL_RULE_INDEX){
    //     console.log('skip');
    //   } else {
    //     console.log((parser.productions as any)[a][1])
    //   }
    // }
    // console.log('');

    return arr;
  };
  var getNextReachableStateItems = function (
    reachableStates,
    ruleIndexes,
    endState,
    count
  ) {
    // function last<T>(arr: T[], n = 1) {
    //   return arr[arr.length - n];
    // }
    let stack = [];
    let newReachableStates = [];
    const encounteredMap = new Map();

    for (let i = 0; i < reachableStates.length; i++) {
      const currentState = reachableStates[i];

      if (!currentState) {
        continue;
      }

      stack.push(currentState);
      let stateItem;
      let state;
      let currentRuleIndexes = currentState.ruleIndexes;
      let encountered = encounteredMap.get(currentRuleIndexes[0]);

      if (!encountered) {
        encountered = new Set();
        encounteredMap.set(currentRuleIndexes[0], encountered);
      }

      while (stack.length) {
        stateItem = stack.shift();

        if (!stateItem) {
          continue;
        }

        state = stateItem.state;

        if (
          state === endState ||
          (!state.transitions.length &&
            lexer.getCurrentToken().token === Lexer.STATIC.EOF_TOKEN)
        ) {
          const rootIndex = stateItem.ruleIndexes[0];
          ruleIndexes.set(rootIndex, count); // for (let j = 0; j < stack.length; j++) {
          //   const s = stack[j];
          //   if (s && s.ruleIndexes[0] === rootIndex) {
          //     stack[j] = null;
          //   }
          // }
          // for (let j = i; j < reachableStates.length; j++) {
          //   const v = reachableStates[j];
          //   if (v && v.ruleIndexes[0] === rootIndex) {
          //     reachableStates[j] = null;
          //   }
          // }
          // for (let j = 0; j < newReachableStates.length; j++) {
          //   const v = newReachableStates[j];
          //   if (v && v.ruleIndexes[0] === rootIndex) {
          //     newReachableStates[j] = null;
          //   }
          // }

          continue;
        }

        if (encountered.has(state)) {
          continue;
        }

        encountered.add(state);
        currentRuleIndexes = stateItem.ruleIndexes;
        let finded;

        for (const t of state.transitions) {
          const find = t.perform();
          finded = finded || !!find;

          if (find) {
            let ruleIndexes = currentRuleIndexes; // const toRuleIndex = t.to.ruleIndex;
            // if (last(currentRuleIndexes) !== toRuleIndex) {
            //   ruleIndexes = [...ruleIndexes, toRuleIndex];
            // }

            if (find.count) {
              newReachableStates.push({
                state: t.to,
                ruleIndexes,
              });
            } else {
              stack.push({
                state: t.to,
                ruleIndexes,
              });
            }
          }
        }
      }
    }

    newReachableStates = newReachableStates.filter((n) => !!n);
    let current = newReachableStates[0];

    if (current && ruleIndexes.size === 0) {
      let i = 1;

      for (i = 1; i < newReachableStates.length; i++) {
        let next = newReachableStates[i];

        if (next) {
          if (current.ruleIndexes[0] !== next.ruleIndexes[0]) {
            break;
          }

          current = next;
        }
      }

      if (current && i === newReachableStates.length) {
        ruleIndexes.set(current.ruleIndexes[0], count);
        return [];
      }
    }

    return newReachableStates;
  };
  var createTokenMatcher = (token) => {
    const fn = () => {
      const currentToken = lexer.getCurrentToken();
      return currentToken.t === token
        ? {
            count: 1,
          }
        : false;
    };

    fn.token = token;
    return fn;
  };
  var initLLK = function () {
    const { productions } = parser;

    for (let i = 0; i < productions.length; i++) {
      const p = productions[i];
      const symbol = parser.getProductionSymbol(p);
      const item = (productionsBySymbol[symbol] = productionsBySymbol[
        symbol
      ] || {
        ruleIndexes: [],
        productions: [],
      });
      item.productions[i] = p;
      item.ruleIndexes.push(i);
    }
  };
  initLLK();
  parser.parse = parse;
  var productionRuleIndexMap = {
    0: 1,
    1: 1,
    2: 2,
    3: 2,
    4: 2,
    5: 3,
    6: 3,
    7: 3,
    8: 3,
    9: 3,
    10: 4,
    11: 4,
    12: 5,
    13: 6,
    14: 6,
    15: 7,
    16: 7,
    17: 7,
    18: 7,
    19: 7,
    20: 8,
    21: 8,
    22: 8,
    23: 8,
    24: 9,
    25: 10,
    26: 11,
    27: 12,
    28: 13,
    29: 14,
    30: 14,
    31: 15,
    32: 15,
    33: 15,
    34: 15,
    35: 15,
    36: 15,
    37: 15,
    38: 15,
    39: 16,
    40: 16,
    41: 17,
    42: 17,
    43: 18,
    44: 19,
    45: 19,
    46: 19,
    47: 19,
    48: 19,
    49: 19,
    50: 20,
    51: 20,
    52: 20,
    53: 20,
    54: 20,
    55: 20,
    56: 20,
    57: 21,
    58: 22,
    59: 22,
    60: 23,
    61: 23,
    62: 23,
    63: 24,
    64: 25,
    65: 25,
    66: 26,
    67: 27,
    68: 27,
    69: 28,
    70: 28,
    71: 29,
    72: 29,
    73: 29,
    74: 29,
    75: 29,
    76: 29,
    77: 29,
    78: 30,
    79: 30,
    80: 30,
    81: 30,
    82: 30,
    83: 30,
    84: 30,
    85: 31,
    86: 31,
    87: 32,
    88: 32,
    89: 33,
    90: 34,
    91: 34,
    92: 35,
    93: 35,
    94: 36,
    95: 37,
    96: 37,
    97: 37,
    98: 38,
    99: 38,
    100: 39,
    101: 39,
    102: 39,
    103: 40,
    104: 40,
    105: 40,
    106: 40,
    107: 40,
    108: 41,
    109: 41,
    110: 41,
    111: 41,
    112: 41,
    113: 41,
    114: 41,
    115: 42,
    116: 43,
    117: 44,
    118: 45,
    119: 45,
    120: 46,
    121: 46,
    122: 46,
    123: 46,
    124: 46,
    125: 46,
    126: 47,
    127: 47,
    128: 47,
    129: 47,
    130: 48,
    131: 49,
    132: 50,
    133: 50,
    134: 50,
    135: 50,
    136: 50,
    137: 51,
    138: 51,
    139: 51,
    140: 51,
    141: 52,
    142: 52,
    143: 52,
    144: 52,
    145: 52,
    146: 52,
    147: 52,
    148: 52,
    149: 52,
    150: 52,
    151: 53,
    152: 53,
    153: 54,
  };
  return parser;
})();

export default vbaParser;
