/*
Generated By kison v0.5.36

Generate time: Wed Dec 08 2021 14:01:06 GMT+0800 (中国标准时间)
*/
var vbaParser = (function (undefined) {
  var BaseAstNode = class BaseAstNode {
    start = 0;
    end = 0;
    firstLine = 0;
    lastLine = 0;
    firstColumn = 0;
    lastColumn = 0;

    toJSON() {
      const ret = {};

      for (const k of Object.keys(this)) {
        if (k !== 'parent' && k !== 't') {
          const v = this[k];

          if (v !== undefined) {
            ret[k] = v;
          }
        }
      }

      return ret;
    }
  };
  var AstSymbolNode = class AstSymbolNode extends BaseAstNode {
    symbol = '';
    type = 'symbol';
    children = [];
    ruleIndex = -1;
    internalRuleIndex = -1;

    constructor(params) {
      super();
      Object.assign(this, params);

      if (params.children) {
        this.setChildren(params.children);
      }

      if (params.internalRuleIndex !== undefined) {
        this.ruleIndex = productionRuleIndexMap[this.internalRuleIndex];
      }
    }

    addChild(c) {
      this.addChildren([c]);
    }

    addChildren(cs) {
      this.children = this.children || [];
      this.children.push(...cs);
      this.setChildren(this.children);
    }

    done() {
      if (this.isWrap && this.children.length === 1) {
        const c = this.children[0];

        if (c.type === 'symbol' && c.symbol === this.symbol) {
          this.label = c.label;
          this.setChildren(c.children);
          return false;
        }
      }

      this.setChildren(this.children);
      return true;
    }

    setChildren(cs) {
      if (!cs.length) {
        this.children = [];
        return;
      }

      const first = cs[0];
      const last = cs[cs.length - 1];
      this.start = first.start;
      this.end = last.end;
      this.firstLine = first.firstLine;
      this.lastLine = last.lastLine;
      this.firstColumn = first.firstColumn;
      this.lastColumn = last.lastColumn;
      this.children = cs;

      for (const c of cs) {
        c.parent = this;
      }
    }
  };
  var AstTokenNode = class AstTokenNode extends BaseAstNode {
    token = '';
    t = '';
    type = 'token';
    text = '';

    constructor(params) {
      super();
      Object.assign(this, params);
    }
  };
  var AstErrorNode = class AstErrorNode extends AstTokenNode {
    constructor(ErrorTokenParams) {
      super(ErrorTokenParams);
      Object.assign(ErrorTokenParams);
    }
  };
  var getLabeledRhsForAddNodeFlag = function (production, extraRhs) {
    let rhs = extraRhs || parser.getProductionRhs(production);
    const label = parser.getProductionLabel(production);

    if (label) {
      let newRhs = [];

      for (const r of rhs) {
        if (isAddAstNodeFlag(r)) {
          newRhs.push(() => {
            astStack[astStack.length - 1].label = getOriginalSymbol(label);
          });
        }

        newRhs.push(r);
      }

      rhs = newRhs;
    } else if (!extraRhs) {
      rhs = [...rhs];
    }

    return rhs;
  };
  var checkLLEndError = function (parseTree, getExpected, ret) {
    const { EOF_TOKEN } = Lexer.STATIC;

    if (!ret.error && lexer.getCurrentToken().token !== EOF_TOKEN) {
      var _peekStack;

      // reduction done but still has input
      if (!symbolStack.length) {
        getExpected = () => [EOF_TOKEN];

        lexer.lex();
      }

      const token = lexer.getCurrentToken();
      ret.error = {
        ...getParseError(getExpected, token),
        expected: getExpected(),
        symbol:
          (_peekStack = peekStack(astStack)) === null || _peekStack === void 0
            ? void 0
            : _peekStack.symbol,
        token,
      };
      ret.errorNode = closeAstWhenError(parseTree, ret.error, astStack);
    }

    return ret;
  };
  var takeCareLLError = function (
    parseTree,
    getExpected,
    onErrorRecovery,
    topSymbol,
    shouldDelete,
    transformNode,
    recoveryTokens,
    ret,
  ) {
    const expected = getExpected();
    const recommendedAction = {};
    const currentToken = lexer.getCurrentToken();
    const nextToken = lexer.peekTokens()[0]; // should delete

    if (
      topSymbol === nextToken.t ||
      shouldDelete({
        currentToken,
        nextToken,
      })
    ) {
      recommendedAction.action = 'del';
    } else if (expected.length) {
      recommendedAction.action = 'add';
    }

    const token = recommendedAction.action === 'add' ? nextToken : currentToken;
    ret.error = {
      recovery: false,
      ...getParseError(() => expected, token),
      expected,
      symbol: peekStack(astStack).symbol,
      token,
    };

    if (onErrorRecovery) {
      const localErrorNode = new AstErrorNode({
        error: ret.error,
        ...ret.error.token,
      });

      if (parseTree) {
        peekStack(astStack).addChild(localErrorNode);
      }

      const recovery =
        onErrorRecovery(
          {
            errorNode: localErrorNode,
            parseTree: getAstRootNode(astStack, transformNode, true),
          },
          recommendedAction,
        ) || {};
      const { action } = recovery;
      peekStack(astStack).children.pop();

      if (!action) {
        ret.errorNode = closeAstWhenError(parseTree, ret.error, astStack);
        ret.breakToEnd = true;
        return ret;
      }

      if (action === 'del') {
        ret.error.recovery = true;
        const deleteToken = recoveryTokens.pop();
        deleteToken.recovery = 'del';
        ret.token = undefined;
      } else if (action === 'add') {
        ret.error.recovery = true;
        ret.token = {
          ...ret.token,
          token: recovery.token,
          text: recovery.text,
          t: lexer.mapSymbol(recovery.token),
          recovery: 'add',
        };
        lexer.pushToken(ret.token);
        pushRecoveryTokens(recoveryTokens, ret.token);
      }
    } else {
      ret.errorNode = closeAstWhenError(parseTree, ret.error, astStack);
      ret.breakToEnd = true;
    }

    return ret;
  };
  var takeCareLLAction = function (popSymbolStack, peekSymbolStack) {
    let topSymbol = peekSymbolStack();

    while (topSymbol && typeof topSymbol === 'function') {
      topSymbol.call(parser);
      popSymbolStack();
      topSymbol = peekSymbolStack();
    }

    return topSymbol;
  };
  var reduceLLAction = function (
    parseTree,
    topSymbol,
    popSymbolStack,
    peekSymbolStack,
  ) {
    while (isProductionEndFlag(topSymbol) || isAddAstNodeFlag(topSymbol)) {
      if (parseTree) {
        let ast = astStack.pop();
        const needAction = ast.done();

        if (needAction) {
          const ruleIndex = ast.internalRuleIndex;
          const production = parser.productions[ruleIndex];
          const action = parser.getProductionAction(production);

          if (action) {
            action.call(parser);
          }
        }

        if (isAddAstNodeFlag(topSymbol)) {
          const stackTop = peekStack(astStack);
          const wrap = new AstSymbolNode({
            id: ++globalSymbolNodeId,
            isWrap: true,
            symbol: ast.symbol,
            label: ast.label,
            children: [ast],
            internalRuleIndex: ast.internalRuleIndex,
          });
          stackTop.children.pop();
          stackTop.addChild(wrap);
          astStack.push(wrap);
        }
      }

      popSymbolStack();
      topSymbol = peekSymbolStack();

      if (!topSymbol) {
        break;
      }
    }

    return topSymbol;
  };
  var prepareLLParse = function () {
    globalSymbolNodeId = 0;
    parser.userData = {};
    symbolStack = [];
    astStack = [
      new AstSymbolNode({
        id: 0,
        symbol: '',
        children: [],
      }),
    ];
  };
  var endLLParse = function () {
    globalSymbolNodeId = 0;
    parser.userData = {};
    symbolStack = [];
    astStack = [];
  };
  var filterRhs = function (rhs) {
    const ret = [];

    for (const r of rhs) {
      if (typeof r === 'string') {
        ret.push(r);
      }
    }

    return ret;
  };
  var isExtraAstNode = function (ast) {
    return ast.children && !ast.children.length;
  };
  var peekStack = function (stack, n = 1) {
    return stack[stack.length - n];
  };
  var getOriginalSymbol = function (s) {
    let uncompressed = lexer.mapReverseSymbol(s); // return uncompressed;

    return parser.prioritySymbolMap[uncompressed] || uncompressed;
  };
  var closeAstWhenError = function (parseTree, error, astStack) {
    const errorNode = new AstErrorNode({
      error,
      ...error.token,
    });

    if (parseTree) {
      const top = peekStack(astStack);

      if (top.type === 'symbol') {
        top.addChild(errorNode);
      }

      while (astStack.length > 1) {
        const ast = astStack.pop();

        if (ast && ast.type === 'symbol' && isExtraAstNode(ast)) {
          const topAst = peekStack(astStack);

          if (topAst.type === 'symbol') {
            topAst.children.pop();
            topAst.addChildren(ast.children);
          }
        }
      }
    }

    return errorNode;
  };
  var pushRecoveryTokens = function (recoveryTokens, token) {
    var _recoveryTokens;

    const { EOF_TOKEN } = Lexer.STATIC;
    let eof;

    if (
      ((_recoveryTokens = recoveryTokens[recoveryTokens.length - 1]) === null ||
      _recoveryTokens === void 0
        ? void 0
        : _recoveryTokens.token) === EOF_TOKEN
    ) {
      eof = recoveryTokens.pop();
    }

    recoveryTokens.push(token);

    if (eof && token.token !== EOF_TOKEN) {
      recoveryTokens.push(eof);
    }
  };
  var getParseError = function (
    getExpected,
    nextToken = lexer.getCurrentToken(),
  ) {
    const expected = getExpected();
    const tips = [];

    if (expected.length) {
      tips.push("'" + expected.join("', '") + "' expected.");
    }

    tips.push("current token: '" + nextToken.token + "'.");
    const tip = tips.join('\n');
    return {
      errorMessage: [
        'syntax error at line ' +
          nextToken.firstLine +
          ':\n' +
          lexer.showDebugInfo(nextToken),
        ...tips,
      ].join('\n'),
      tip,
    };
  };
  var cleanAst = function (ast, transformNode) {
    if (!transformNode) {
      return ast;
    }

    if (ast.children) {
      let children;
      let childrenChanged;

      while (true) {
        let changed = false;
        let index = 0;
        children = [];

        for (const c of ast.children) {
          const node = transformNode({
            node: c,
            index,
            parent: ast,
            defaultTransformNode: defaultTransformAstNode,
          });

          if (Array.isArray(node)) {
            children.push(...node);
          } else if (node) {
            children.push(node);
          }

          changed = changed || node !== c;
          index++;
        }

        if (!changed) {
          break;
        } else {
          ast.setChildren(children);
          childrenChanged = true;
        }
      }

      if (childrenChanged && ast.parent) {
        cleanAst(ast.parent, transformNode);
      } else {
        for (const c of children) {
          if (c.type === 'symbol') {
            cleanAst(c, transformNode);
          }
        }
      }
    }

    return ast;
  };
  var getAstRootNode = function (astStack, transformNode, raw) {
    var _ast, _ast$children;

    let ast = astStack[0];

    if (!ast) {
      return ast;
    }

    if (ast.type !== 'symbol') {
      return ast;
    }

    ast =
      (_ast = ast) === null || _ast === void 0
        ? void 0
        : (_ast$children = _ast.children) === null || _ast$children === void 0
        ? void 0
        : _ast$children[0];

    if (ast && ast.type === 'symbol' && ast.symbol === START_TAG) {
      var _ast2, _ast2$children;

      ast =
        (_ast2 = ast) === null || _ast2 === void 0
          ? void 0
          : (_ast2$children = _ast2.children) === null ||
            _ast2$children === void 0
          ? void 0
          : _ast2$children[0];
    }

    if (ast) {
      ast.parent = undefined;
    }

    if (raw) {
      return ast;
    }

    if (ast && ast.type === 'token') {
      return ast;
    }

    return ast && cleanAst(ast, transformNode);
  };
  var defaultTransformAstNode = function ({ node, parent }) {
    if (node.type === 'token' || node.symbol !== parent.symbol) {
      return node;
    }

    if (node.label || parent.label) {
      if (node.label !== parent.label) {
        return node;
      }
    }

    if (parent.children.length === 1) {
      return node.children;
    }

    return node;
  };
  var isAddAstNodeFlag = function (t) {
    return t === productionAddAstNodeFlag;
  };
  var isProductionEndFlag = function (t) {
    return t === productionEndFlag;
  };
  var isZeroOrMoreSymbol = function (s) {
    return (
      typeof s === 'string' && s !== '*?' && s.length > 1 && !!s.match(/\*\??$/)
    );
  };
  var isOneOrMoreSymbol = function (s) {
    return (
      typeof s === 'string' && s !== '+?' && s.length > 1 && !!s.match(/\+\??$/)
    );
  };
  var isLazySymbol = function (s) {
    const match = typeof s === 'string' && s.match(/(\*|\+|\?)\?$/);
    return match && s.length !== 2;
  };
  var isOptionalSymbol = function (s) {
    return typeof s === 'string' && s.length > 1 && !!s.match(/\??\?$/);
  };
  var normalizeSymbol = function (s) {
    const ret =
      isOptionalSymbol(s) || isZeroOrMoreSymbol(s) || isOneOrMoreSymbol(s)
        ? s.replace(/(\*|\+|\?)?\??$/, '')
        : s; // ??

    return ret || (s && s.slice(0, -1));
  };
  var VIRTUAL_OPTIONAL_RULE_INDEX = -100;
  var START_TAG = '$START';
  var smUnitBySymbol = {};
  var productionSkipAstNodeSet = undefined;
  var symbolStack = [{}];
  var astStack = [];
  var productionsBySymbol = {};
  var productionAddAstNodeFlag = 1;
  var productionEndFlag = 2;
  var globalSymbolNodeId = 0;
  var Lexer = function (cfg) {
    this.nextTokens = [];

    if (Lexer.supportSticky === undefined) {
      try {
        Lexer.supportSticky = typeof /(?:)/.sticky == 'boolean';
      } catch (e) {
        Lexer.supportSticky = false;
      }
    }

    const lexerRuleIndexMap = (this.lexerRuleIndexMap = {
      token: 0,
      regexp: 1,
      action: 2,
      predict: 3,
      state: 4,
      channel: 5,
      more: 6,
    });
    const STATIC = Lexer.STATIC;
    this.tokenSet = new Set([STATIC.EOF_TOKEN, STATIC.UNKNOWN_TOKEN]);
    this.rules = [];
    this.defaultEnv = undefined;
    Object.assign(this, cfg);
    this.rules = this.rules.concat();
    this.regexpIndex = this.isCompress
      ? this.lexerRuleIndexMap.regexp
      : 'regexp';
    this.getRuleItem = this.isCompress
      ? this.getRuleItemCompress
      : this.getRuleItemNoCompress;
    this.transformRules();
    this.userData = {};
    const errorRule = (this.errorRule = {
      regexp: this.matchAny,
      token: Lexer.STATIC.UNKNOWN_TOKEN,
    });

    for (const rule of this.rules) {
      const token = this.getRuleItem(rule, 'token');

      if (token) {
        this.tokenSet.add(token);
      }
    }

    if (this.isCompress) {
      const errorRuleCompress = (this.errorRule = []);
      errorRuleCompress[lexerRuleIndexMap.token] = errorRule.token;
      errorRuleCompress[lexerRuleIndexMap.regexp] = errorRule.regexp;
    }

    this.resetInput(this.input);
    this.options = {};
  };
  Lexer.prototype = {
    transformRegExp: function (obj, p, disableSticky) {
      const pattern = obj[p];

      if (pattern.test) {
        let source = pattern.source;

        if (source.startsWith('^')) {
          source = source.slice(1);
        }

        var flags = Lexer.supportSticky && !disableSticky ? 'gy' : 'g';
        if (pattern.multiline) flags += 'm';
        if (pattern.ignoreCase) flags += 'i';
        if (pattern.unicode) flags += 'u';
        obj[p] = new RegExp(source, flags);
      } else if (typeof pattern === 'object') {
        for (const k of Object.keys(pattern)) {
          this.transformRegExp(pattern, k);
        }
      }
    },
    hasToken: function (t) {
      return this.tokenSet.has(t);
    },
    transformRules: function () {
      if (Lexer.supportSticky) {
        const { regexpIndex } = this;

        for (const r of this.rules) {
          this.transformRegExp(r, regexpIndex);
        }
      }
    },
    matchAny: function () {
      return this.end < this.input.length ? this.input.charAt(this.end) : false;
    },
    addRule: function (rule) {
      this.rules.push(rule);
      const token = this.getRuleItem(rule, 'token');

      if (token) {
        this.tokenSet.add(token);
      }
    },
    resetInput: function (input) {
      this.token = '';
      this.nextTokens = [];
      this.tokens = [];
      this.userData = {};
      this.input = input;
      this.matched = '';
      this.stateStack = [Lexer.STATIC.INITIAL_STATE];
      this.match = '';
      this.text = '';
      this.firstLine = 1;
      this.lineNumber = 1;
      this.lastLine = 1;
      this.start = 0;
      this.end = 0;
      this.firstColumn = 1;
      this.lastColumn = 1;
    },
    getRuleItemNoCompress: function (rule, itemType) {
      return rule[itemType];
    },
    getRuleItemCompress: function (rule, itemType) {
      return rule[this.lexerRuleIndexMap[itemType]];
    },
    getCurrentRules: function () {
      var currentState = this.stateStack[this.stateStack.length - 1],
        rules = [];

      for (const r of this.rules) {
        var state = this.getRuleItem(r, 'state');

        if (!state) {
          if (currentState === Lexer.STATIC.INITIAL_STATE) {
            rules.push(r);
          }
        } else if (state.indexOf(currentState) !== -1) {
          rules.push(r);
        }
      }

      rules.push(this.errorRule);
      return rules;
    },
    peekState: function (n = 1) {
      return this.mapReverseState(this.stateStack[this.stateStack.length - n]);
    },
    pushState: function (state) {
      this.stateStack.push(this.mapState(state));
    },
    popState: function (num = 1) {
      var ret;

      while (num--) {
        ret = this.stateStack.pop();
      }

      return ret && this.mapReverseState(ret);
    },
    showDebugInfo: function (nextToken) {
      function truncate(str, before = false) {
        let c = before
          ? str.slice(0 - DEBUG_CONTEXT_LIMIT)
          : str.slice(0, DEBUG_CONTEXT_LIMIT);
        c = c.replace(/\r\n/g, '\n');
        let s = str.length > DEBUG_CONTEXT_LIMIT ? '...' : '';
        const ret = before ? s + c : c + s;
        let end = '';

        if (str.endsWith('\n') && !ret.endsWith('\n')) {
          end = '\n';
        }

        return ret + end;
      }

      nextToken = nextToken || this.getCurrentToken();
      var { DEBUG_CONTEXT_LIMIT } = Lexer.STATIC;
      var { input } = this;
      const matched = input.slice(0, nextToken.start);
      var past = truncate(matched, true);
      var next = input.slice(nextToken.start).replace(/\r\n/g, '\n'); //#JSCOVERAGE_ENDIF

      const lastLine = past.lastIndexOf('\n');
      const dashLength = past.length - lastLine;
      let middleIndex = next.indexOf('\n');
      let middle = '';

      if (middleIndex > -1) {
        middle = truncate(next.slice(0, middleIndex + 1));
        next = next.slice(middleIndex);
      } else {
        middle = truncate(next) + '\n';
        next = '';
      }

      middle += new Array(dashLength).join('-') + '^';
      next = truncate(next);
      return past + middle + next;
    },
    mapSymbol: function (n) {
      return n;
    },
    mapReverseSymbol: function (n) {
      return n;
    },
    mapState: function (n) {
      return n;
    },
    mapReverseState: function (n) {
      return n;
    },
    toJSON: function () {
      const currentToken = this.getCurrentToken();
      return {
        t: currentToken.t,
        text: currentToken.text,
        firstLine: currentToken.firstLine,
        firstColumn: currentToken.firstColumn,
        lastLine: currentToken.lastLine,
        lastColumn: currentToken.lastColumn,
        token: currentToken.token,
        start: currentToken.start,
        end: currentToken.end,
      };
    },
    stash: function () {
      this.stashIndex = this.tokens.length;
    },
    stashPop: function () {
      this.nextTokens = [
        ...this.tokens.slice(this.stashIndex),
        ...this.nextTokens,
      ];
      this.tokens.length = this.stashIndex;
    },
    matchRegExp: function (predict, regexp) {
      let ret;

      if (typeof regexp !== 'function') {
        regexp.lastIndex = this.end;
        ret = regexp.exec(this.input);

        if (ret && ret.index !== this.end) {
          return null;
        }
      } else {
        ret = regexp.call(this, this);
      }

      if (
        ret &&
        (predict === null || predict === void 0
          ? void 0
          : predict.call(this, ret)) === false
      ) {
        return null;
      }

      return ret;
    },
    pushToken: function (token) {
      var _tokens;

      const tokens = this.tokens;

      if (
        ((_tokens = tokens[tokens.length - 1]) === null || _tokens === void 0
          ? void 0
          : _tokens.token) === Lexer.STATIC.EOF_TOKEN
      ) {
        tokens.pop();
      }

      tokens.push(token);
    },
    peekTokens: function (num = 1) {
      const ret = [];
      this.stash();

      for (let i = 0; i < num; i++) {
        ret.push(this.lex());
      }

      this.stashPop();
      return ret;
    },
    lex: function () {
      const { EOF_TOKEN } = Lexer.STATIC;
      let token = this.nextToken();

      while (token.more) {
        const nextToken = this.nextToken();
        nextToken.start = token.start;
        nextToken.firstLine = token.firstLine;
        nextToken.firstColumn = token.firstColumn;
        nextToken.text = token.text + nextToken.text;
        token = nextToken;
      }

      const tokens = this.tokens;
      const lastToken = tokens[tokens.length - 1];

      if (
        lastToken &&
        token.token === EOF_TOKEN &&
        lastToken.token === EOF_TOKEN
      ) {
        return token;
      }

      this.tokens.push(token);

      if (token.channel || !token.token) {
        return this.lex();
      }

      return token;
    },
    getCurrentToken: function () {
      const { tokens } = this;
      return tokens[tokens.length - 1] || this.lex();
    },
    getLastToken: function (filter) {
      const { tokens } = this;
      let index = tokens.length - 2;

      if (filter) {
        while (index >= 0 && filter(tokens[index]) === false) {
          index--;
        }
      }

      return tokens[index] || this.getCurrentToken();
    },
    nextChar: function (index = 0) {
      return this.getChar(this.end + index);
    },
    nextCharCode: function (index = 0) {
      return this.getCharCode(this.end + index);
    },
    nextStartsWith: function (search) {
      let { input, end } = this;
      const l = search.length;

      for (let i = 0; i < l; i++) {
        if (input.charAt(end++) !== search.charAt(i)) {
          return false;
        }
      }

      return true;
    },
    nextCharAt: function (index) {
      return this.input.charAt(this.end + index);
    },
    nextLength: function () {
      return this.input.length - this.end;
    },
    getChar: function (index = 0) {
      if (this.options.unicode) {
        const code = this.input.codePointAt(index);

        if (code === undefined || isNaN(code)) {
          return '';
        }

        return String.fromCodePoint(code);
      }

      return this.input.charAt(index);
    },
    getCharCode: function (index = 0) {
      if (this.options.unicode) {
        return this.input.codePointAt(index);
      }

      return this.input.charCodeAt(index);
    },
    getTokensLength: function () {
      return this.tokens.length;
    },
    nextToken: function () {
      if (this.nextTokens.length) {
        return this.nextTokens.shift();
      }

      var i,
        rule,
        m,
        ret,
        lines,
        rules = this.getCurrentRules();
      var { input } = this;
      var { env = this.defaultEnv } = this.options;
      this.match = this.text = '';

      if (this.end >= input.length) {
        this.token = Lexer.STATIC.EOF_TOKEN;
        this.start = this.end;
        this.firstLine = this.lastLine;
        this.firstColumn = this.lastColumn;
        return {
          text: '',
          t: this.mapSymbol(this.token),
          token: this.token,
          start: this.start,
          end: this.end,
          firstLine: this.firstLine,
          firstColumn: this.firstColumn,
          lastLine: this.lastLine,
          lastColumn: this.lastColumn,
        };
      }

      for (i = 0; i < rules.length; i++) {
        rule = rules[i];
        let regexp = this.getRuleItem(rule, 'regexp');
        let token = this.getRuleItem(rule, 'token');
        let channel = this.getRuleItem(rule, 'channel');
        let action = this.getRuleItem(rule, 'action');
        let more = this.getRuleItem(rule, 'more');
        let predict = this.getRuleItem(rule, 'predict');

        if (
          typeof regexp !== 'function' &&
          regexp &&
          env &&
          typeof regexp.test !== 'function'
        ) {
          regexp = regexp[env];
        }

        if (!regexp) {
          continue;
        } //#JSCOVERAGE_ENDIF

        if ((m = this.matchRegExp(predict, regexp))) {
          const start = this.end;
          const end = this.end + m[0].length;
          lines = m[0].split('\n');
          lines.shift();
          this.lineNumber += lines.length;
          const position = {
            start: start,
            end: end,
            firstLine: this.lastLine,
            lastLine: this.lineNumber,
            firstColumn: this.lastColumn,
            lastColumn: lines.length
              ? lines[lines.length - 1].length + 1
              : this.lastColumn + m[0].length,
          };

          if (more) {
            position.more = more;
          }

          Object.assign(this, position);
          var match; // for error report

          match = this.match = m[0]; // all matches

          this.matches = m; // may change by user

          this.text = match; // matched content utils now

          this.matched += match;
          ret = action && action.call(this);

          if (ret === undefined) {
            ret = token;
          } else {
            ret = this.mapSymbol(ret);
          }

          if (ret) {
            this.token = this.mapReverseSymbol(ret);
            return {
              text: this.text,
              channel,
              token: this.token,
              t: ret,
              ...position,
            };
          } else {
            // ignore
            return this.nextToken();
          }
        }
      }

      throw new Error('no match lexer');
    },
  };
  Lexer.STATIC = {
    INITIAL_STATE: 'I',
    DEBUG_CONTEXT_LIMIT: 79,
    EOF_TOKEN: '$EOF',
    UNKNOWN_TOKEN: '$UNKNOWN',
  };
  var lexer = new Lexer({
    rules: [
      [
        'ALIAS',
        /ALIAS\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'AND',
        /AND\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ATTRIBUTE',
        /ATTRIBUTE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'AS',
        /AS\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'BEGIN',
        /BEGIN\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'BOOLEAN',
        /BOOLEAN\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'BYVAL',
        /BYVAL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'BYREF',
        /BYREF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'BYTE',
        /BYTE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'CALL',
        /CALL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'CASE',
        /CASE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'CONST',
        /CONST\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DATE',
        /DATE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DECLARE',
        /DECLARE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFBOOL',
        /DEFBOOL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFBYTE',
        /DEFBYTE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFDATE',
        /DEFDATE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFDBL',
        /DEFDBL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFDEC',
        /DEFDEC\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFCUR',
        /DEFCUR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFINT',
        /DEFINT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFLNG',
        /DEFLNG\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFOBJ',
        /DEFOBJ\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFSNG',
        /DEFSNG\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFSTR',
        /DEFSTR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DEFVAR',
        /DEFVAR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DIM',
        /DIM\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DO',
        /DO\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DOUBLE',
        /DOUBLE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EACH',
        /EACH\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ELSE',
        /ELSE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ELSEIF',
        /ELSEIF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_ENUM',
        /END ENUM\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_FUNCTION',
        /END FUNCTION\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_IF',
        /END IF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_PROPERTY',
        /END PROPERTY\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_SELECT',
        /END SELECT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_SUB',
        /END SUB\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_TYPE',
        /END TYPE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END_WITH',
        /END WITH\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'END',
        /END\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ENUM',
        /ENUM\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EQV',
        /EQV\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ERASE',
        /ERASE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EVENT',
        /EVENT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EXIT_DO',
        /EXIT DO\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EXIT_FOR',
        /EXIT FOR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EXIT_FUNCTION',
        /EXIT FUNCTION\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EXIT_PROPERTY',
        /EXIT PROPERTY\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'EXIT_SUB',
        /EXIT SUB\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'FALSE',
        /FALSE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'FRIEND',
        /FRIEND\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'FOR',
        /FOR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'FUNCTION',
        /FUNCTION\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'GET',
        /GET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'GLOBAL',
        /GLOBAL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'GOSUB',
        /GOSUB\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'GOTO',
        /GOTO\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'IF',
        /IF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'IMPLEMENTS',
        /IMPLEMENTS\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'IN',
        /IN\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ISNOT',
        /ISNOT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'IS',
        /IS\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'INTEGER',
        /INTEGER\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LONG',
        /LONG\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LOOP',
        /LOOP\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LEN',
        /LEN\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LET',
        /LET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LIB',
        /LIB\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LIKE',
        /LIKE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'LSET',
        /LSET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'MACRO_CONST',
        /#CONST\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'MACRO_IF',
        /#IF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'MACRO_ELSEIF',
        /#ELSEIF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'MACRO_ELSE',
        /#ELSE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'MACRO_END_IF',
        /#END IF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'MOD',
        /MOD\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'NEXT',
        /NEXT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'NEW',
        /NEW\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'NOT',
        /NOT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'NOTHING',
        /NOTHING\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'NULL',
        /NULL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ON_ERROR',
        /ON ERROR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ON_LOCAL_ERROR',
        /ON LOCAL ERROR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'ON',
        /ON\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'OPTIONAL',
        /OPTIONAL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'OPTION_BASE',
        /OPTION BASE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'OPTION_EXPLICIT',
        /OPTION EXPLICIT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'OPTION_COMPARE',
        /OPTION COMPARE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'OPTION_PRIVATE_MODULE',
        /OPTION PRIVATE MODULE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'OR',
        /OR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PARAMARRAY',
        /PARAMARRAY\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PRESERVE',
        /PRESERVE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PRIVATE',
        /PRIVATE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PROPERTY_GET',
        /PROPERTY GET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PROPERTY_LET',
        /PROPERTY LET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PROPERTY_SET',
        /PROPERTY SET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PTRSAFE',
        /PTRSAFE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'PUBLIC',
        /PUBLIC\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'RAISEEVENT',
        /RAISEEVENT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'REDIM',
        /REDIM\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'RESET',
        /RESET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'RESUME',
        /RESUME\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'RETURN',
        /RETURN\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'SELECT',
        /SELECT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'SET',
        /SET\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'SINGLE',
        /SINGLE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'STATIC',
        /STATIC\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'STEP',
        /STEP\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'STOP',
        /STOP\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'STRING',
        /STRING\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'SUB',
        /SUB\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'THEN',
        /THEN\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'TO',
        /TO\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'TRUE',
        /TRUE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'TYPEOF',
        /TYPEOF\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'UNTIL',
        /UNTIL\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'VARIANT',
        /VARIANT\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'WEND',
        /WEND\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'WHILE',
        /WHILE\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'WITH',
        /WITH\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'WITHEVENTS',
        /WITHEVENTS\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'XOR',
        /XOR\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'IMP',
        /IMP\b/gi,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      [
        'DATELITERAL',
        /#(?:(?:(?:\d+|(?:(?:JAN|FEB|MAR|APR|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)))(?:\s?[\/,-]?\s?)(?:\d+|(?:(?:JAN|FEB|MAR|APR|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)))(?:(?:\s?[\/,-]?\s?)(?:\d+|(?:(?:JAN|FEB|MAR|APR|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER))))?)\s?(?:\d+(?:\s?(AM|PM|A|P))|\d+(?:\s?(:|.)\s?)\d+(?:(?:\s?(:|.)\s?)\d+)?(?:\s?(AM|PM|A|P))?)|(?:(?:\d+|(?:(?:JAN|FEB|MAR|APR|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)))(?:\s?[\/,-]?\s?)(?:\d+|(?:(?:JAN|FEB|MAR|APR|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)))(?:(?:\s?[\/,-]?\s?)(?:\d+|(?:(?:JAN|FEB|MAR|APR|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER))))?)|(?:\d+(?:\s?(AM|PM|A|P))|\d+(?:\s?(:|.)\s?)\d+(?:(?:\s?(:|.)\s?)\d+)?(?:\s?(AM|PM|A|P))?))#/gi,
      ],
      ['DOUBLELITERAL', /[0-9]*\.[0-9]+(E[0-9]+)?/g],
      ['SPACE_DOT', / +\./g],
      ['ASSIGN', /:=/g],
      ['NEQ', /<>/g],
      ['LEQ', /<=/g],
      ['GEQ', />=/g],
      ['MINUS_EQ', /\-=/g],
      ['PLUS_EQ', /\+=/g],
      ['COLON', /:/g],
      ['AMPERSAND', /&/g],
      ['DIV', /\//g],
      ['IDIV', /\\/g],
      ['EQ', /=/g],
      ['GT', />/g],
      ['LPAREN', /\(/g],
      ['LT', /</g],
      ['MINUS', /\-/g],
      ['MULT', /\*/g],
      ['PLUS', /\+/g],
      ['POW', /\^/g],
      ['RPAREN', /\)/g],
      ['L_SQUARE_BRACKET', /\[/g],
      ['R_SQUARE_BRACKET', /\]/g],
      ['NEWLINE', /([\r\n]+)/g],
      [
        'REMCOMMENT',
        /(\:?rem((([\u0020\t]+_\r?\n)|[\u0020\t])+)(([\u0020\t]+_\r?\n)|[^\r\n])*)/g,
      ],
      ['COMMENT', /('(([\u0020\t]+_\r?\n)|[^\r\n])*)/g],
      [
        'HIDDEN',
        /((([\u0020\t]+_\r?\n)|[\u0020\t])+)|(\s+)/gi,
        undefined,
        undefined,
        undefined,
        'HIDDEN',
      ],
      ['STRINGLITERAL', /"(""|[^"\r\n])*"/g],
      ['INTEGERLITERAL', /[0-9]+/g],
      [
        'IDENTIFIER',
        /\w[\w\d]*/g,
        function () {
          this.text = (this.text || '').toLowerCase();
        },
      ],
      ["'|'", /'\|'/g],
      ["'('", /'\('/g],
      ["')'+", /'\)'\+/g],
      ['endOfLine+', /endOfLine\+/g],
      ["')'", /'\)'/g],
      [',', /,/g],
      ['.', /\./g],
      ['!', /!/g],
      ['&', /&/g],
      ['%', /%/g],
      ['#', /#/g],
      ['@', /@/g],
      ['$', /\$/g],
    ],
    isCompress: 1,
    defaultEnv: undefined,
  });
  function lex(input, options = {}) {
    lexer.options = options;
    lexer.resetInput(input);
    const { state } = options;

    if (state) {
      if (state.userData) {
        lexer.userData = state.userData;
      }

      if (state.stateStack) {
        lexer.stateStack = state.stateStack;
      }
    }

    while (lexer.lex().token !== Lexer.STATIC.EOF_TOKEN);

    return {
      state: {
        userData: lexer.userData,
        stateStack: lexer.stateStack,
      },
      tokens: lexer.tokens,
    };
  }
  var parser = {
    productions: [
      ['$START', ['progam']],
      [
        'progam',
        [
          'moduleDeclarations?',
          'endOfLine*',
          'moduleBody?',
          'endOfLine*',
          '$EOF',
        ],
      ],
      ['endOfLine', ['NEWLINE']],
      ['endOfLine', ['COMMENT']],
      ['endOfLine', ['REMCOMMENT']],
      ['endOfStatement_group_def_2', ['endOfLine']],
      ['endOfStatement_group_1', ['endOfStatement_group_def_2']],
      ['endOfStatement_group_def_3', ['COLON']],
      ['endOfStatement_group_1', ['endOfStatement_group_def_3']],
      ['endOfStatement', ['endOfStatement_group_1', 'endOfStatement_group_1*']],
      [
        'moduleDeclarations_group_def_5',
        ['endOfLine', 'endOfLine*', 'moduleDeclarationsElement'],
      ],
      [
        'moduleDeclarations',
        [
          'moduleDeclarationsElement',
          'moduleDeclarations_group_def_5*',
          'endOfLine*',
        ],
      ],
      ['moduleDeclarationsElement', ['COMMENT']],
      ['moduleDeclarationsElement', ['variableStmt']],
      ['moduleDeclarationsElement', ['moduleOption']],
      ['moduleOption', ['OPTION_BASE', 'INTEGERLITERAL']],
      ['moduleOption', ['OPTION_COMPARE', 'IDENTIFIER']],
      ['moduleOption', ['OPTION_EXPLICIT']],
      ['moduleOption', ['OPTION_PRIVATE_MODULE']],
      [
        'moduleBody_group_def_7',
        ['endOfLine', 'endOfLine*', 'moduleBodyElement'],
      ],
      [
        'moduleBody',
        ['moduleBodyElement', 'moduleBody_group_def_7*', 'endOfLine*'],
      ],
      ['moduleBodyElement', ['functionStmt']],
      ['moduleBodyElement', ['propertyGetStmt']],
      ['moduleBodyElement', ['propertySetStmt']],
      ['moduleBodyElement', ['propertyLetStmt']],
      ['moduleBodyElement', ['subStmt']],
      ['visibility', ['PRIVATE']],
      ['visibility', ['PUBLIC']],
      ['visibility', ['FRIEND']],
      ['visibility', ['GLOBAL']],
      [
        'subStmt',
        [
          'visibility?',
          'STATIC?',
          'SUB',
          'ambiguousIdentifier',
          'argList?',
          'endOfStatement',
          'block?',
          'END_SUB',
        ],
      ],
      [
        'propertyGetStmt',
        [
          'visibility?',
          'STATIC?',
          'PROPERTY_GET',
          'ambiguousIdentifier',
          'typeHint?',
          'LPAREN',
          'RPAREN',
          'asTypeClause?',
          'endOfStatement',
          'block?',
          'END_PROPERTY',
        ],
      ],
      [
        'propertySetStmt',
        [
          'visibility?',
          'STATIC?',
          'PROPERTY_SET',
          'ambiguousIdentifier',
          'argList?',
          'endOfStatement',
          'block?',
          'END_PROPERTY',
        ],
      ],
      [
        'propertyLetStmt',
        [
          'visibility?',
          'STATIC?',
          'PROPERTY_LET',
          'ambiguousIdentifier',
          'argList?',
          'endOfStatement',
          'block?',
          'END_PROPERTY',
        ],
      ],
      [
        'functionStmt',
        [
          'visibility?',
          'STATIC?',
          'FUNCTION',
          'ambiguousIdentifier',
          'typeHint?',
          'argList?',
          'asTypeClause?',
          'endOfStatement',
          'block?',
          'END_FUNCTION',
        ],
      ],
      ['block_group_def_9', ['endOfStatement', 'blockStmt']],
      ['block', ['blockStmt', 'block_group_def_9*', 'endOfStatement']],
      ['blockStmt', ['lineLabel', 'blockStmt?']],
      ['blockStmt', ['goToStmt']],
      ['blockStmt', ['ifThenElseStmt']],
      ['blockStmt', ['selectCaseStmt']],
      ['blockStmt', ['forNextStmt']],
      ['blockStmt', ['forEachStmt']],
      ['blockStmt', ['doLoopStmt']],
      ['blockStmt', ['whileWendStmt']],
      ['blockStmt', ['onErrorStmt']],
      ['blockStmt', ['withStmt']],
      ['blockStmt', ['eraseStmt']],
      ['blockStmt', ['exitStmt']],
      ['blockStmt', ['explicitCallStmt']],
      ['blockStmt', ['setStmt']],
      ['blockStmt', ['redimStmt']],
      ['blockStmt', ['letStmt']],
      ['blockStmt', ['variableStmt']],
      ['blockStmt', ['implicitCallStmt_InBlock']],
      [
        'whileWendStmt',
        ['WHILE', 'valueStmt', 'endOfStatement', 'block', 'WEND'],
      ],
      ['doLoopStmt', ['DO', 'endOfStatement', 'block', 'LOOP']],
      ['doLoopStmt_group_def_11', ['WHILE']],
      ['doLoopStmt_group_10', ['doLoopStmt_group_def_11']],
      ['doLoopStmt_group_def_12', ['UNTIL']],
      ['doLoopStmt_group_10', ['doLoopStmt_group_def_12']],
      [
        'doLoopStmt',
        [
          'DO',
          'doLoopStmt_group_10',
          'valueStmt',
          'endOfStatement',
          'block',
          'LOOP',
        ],
      ],
      ['doLoopStmt_group_13', ['doLoopStmt_group_def_11']],
      ['doLoopStmt_group_13', ['doLoopStmt_group_def_12']],
      [
        'doLoopStmt',
        [
          'DO',
          'endOfStatement',
          'block',
          'LOOP',
          'doLoopStmt_group_13',
          'valueStmt',
        ],
      ],
      ['forNextStmt_group_def_15', ['STEP', 'valueStmt']],
      [
        'forNextStmt',
        [
          'FOR',
          'ambiguousIdentifier',
          'typeHint?',
          'asTypeClause?',
          'EQ',
          'valueStmt',
          'TO',
          'valueStmt',
          'forNextStmt_group_def_15?',
          'endOfStatement',
          'block?',
          'NEXT',
          'ambiguousIdentifier?',
        ],
      ],
      [
        'forEachStmt',
        [
          'FOR',
          'EACH',
          'ambiguousIdentifier',
          'typeHint?',
          'IN',
          'valueStmt',
          'endOfStatement',
          'block?',
          'NEXT',
          'ambiguousIdentifier?',
        ],
      ],
      [
        'selectCaseStmt',
        [
          'SELECT',
          'CASE',
          'valueStmt',
          'endOfStatement',
          'sC_Case*',
          'END_SELECT',
        ],
      ],
      [
        'sC_Selection',
        ['IS', 'comparisonOperator', 'valueStmt'],
        undefined,
        'caseCondIs',
      ],
      [
        'sC_Selection',
        ['valueStmt', 'TO', 'valueStmt'],
        undefined,
        'caseCondTo',
      ],
      ['sC_Selection', ['valueStmt'], undefined, 'caseCondValue'],
      ['sC_Case', ['CASE', 'sC_Cond', 'endOfStatement', 'block?']],
      ['sC_Cond', ['ELSE'], undefined, 'caseCondElse'],
      ['sC_Cond_group_def_17', [',', 'sC_Selection']],
      [
        'sC_Cond',
        ['sC_Selection', 'sC_Cond_group_def_17*'],
        undefined,
        'caseCondSelection',
      ],
      ['comparisonOperator', ['LT']],
      ['comparisonOperator', ['LEQ']],
      ['comparisonOperator', ['GT']],
      ['comparisonOperator', ['GEQ']],
      ['comparisonOperator', ['EQ']],
      ['comparisonOperator', ['NEQ']],
      ['comparisonOperator', ['IS']],
      ['ifThenElseStmt_group_def_19', ['ELSE', 'blockStmt']],
      [
        'ifThenElseStmt',
        [
          'IF',
          'valueStmt',
          'THEN',
          'blockStmt',
          'ifThenElseStmt_group_def_19?',
        ],
        undefined,
        'InlineIfThenElse',
      ],
      [
        'ifThenElseStmt',
        ['ifBlockStmt', 'ifElseIfBlockStmt*', 'ifElseBlockStmt?', 'END_IF'],
        undefined,
        'BlockIfThenElse',
      ],
      ['ifBlockStmt', ['IF', 'valueStmt', 'THEN', 'endOfStatement', 'block?']],
      [
        'ifElseIfBlockStmt',
        ['ELSEIF', 'valueStmt', 'THEN', 'endOfStatement', 'block?'],
      ],
      ['ifElseBlockStmt', ['ELSE', 'endOfStatement', 'block?']],
      ['onErrorStmt_group_def_21', ['ambiguousIdentifier']],
      ['onErrorStmt_group_20', ['onErrorStmt_group_def_21']],
      ['onErrorStmt_group_def_22', ['MINUS', 'INTEGERLITERAL']],
      ['onErrorStmt_group_20', ['onErrorStmt_group_def_22']],
      ['onErrorStmt', ['ON_ERROR', 'GOTO', 'onErrorStmt_group_20']],
      ['lineLabel', ['ambiguousIdentifier', 'COLON']],
      ['goToStmt', ['GOTO', 'ambiguousIdentifier']],
      ['eraseStmt_group_def_24', [',', 'valueStmt']],
      ['eraseStmt', ['ERASE', 'valueStmt', 'eraseStmt_group_def_24*']],
      ['redimStmt_group_def_26', [',', 'redimSubStmt']],
      [
        'redimStmt',
        ['REDIM', 'PRESERVE?', 'redimSubStmt', 'redimStmt_group_def_26*'],
      ],
      [
        'redimSubStmt',
        [
          'implicitCallStmt_InStmt',
          'LPAREN',
          'subscripts',
          'RPAREN',
          'asTypeClause?',
        ],
      ],
      ['exitStmt', ['EXIT_DO']],
      ['exitStmt', ['EXIT_FOR']],
      ['exitStmt', ['EXIT_FUNCTION']],
      ['exitStmt', ['EXIT_PROPERTY']],
      ['exitStmt', ['EXIT_SUB']],
      ['exitStmt', ['END']],
      ['letStmt_group_def_28', ['EQ']],
      ['letStmt_group_27', ['letStmt_group_def_28']],
      ['letStmt_group_def_29', ['PLUS_EQ']],
      ['letStmt_group_27', ['letStmt_group_def_29']],
      ['letStmt_group_def_30', ['MINUS_EQ']],
      ['letStmt_group_27', ['letStmt_group_def_30']],
      [
        'letStmt',
        ['LET?', 'implicitCallStmt_InStmt', 'letStmt_group_27', 'valueStmt'],
      ],
      ['setStmt', ['SET', 'implicitCallStmt_InStmt', 'EQ', 'valueStmt']],
      ['explicitCallStmt', ['eCS_MemberProcedureCall']],
      ['explicitCallStmt', ['eCS_ProcedureCall']],
      [
        'eCS_MemberProcedureCall_group_def_32',
        ['implicitCallStmt_InStmt?', '.'],
      ],
      [
        'eCS_MemberProcedureCall_group_31',
        ['eCS_MemberProcedureCall_group_def_32'],
      ],
      ['eCS_MemberProcedureCall_group_def_33', ['SPACE_DOT']],
      [
        'eCS_MemberProcedureCall_group_31',
        ['eCS_MemberProcedureCall_group_def_33'],
      ],
      [
        'eCS_MemberProcedureCall_group_def_35',
        ['LPAREN', 'argsCall', 'RPAREN'],
      ],
      ['eCS_MemberProcedureCall_group_def_37', ['LPAREN', 'indexes', 'RPAREN']],
      [
        'eCS_MemberProcedureCall',
        [
          'CALL',
          'eCS_MemberProcedureCall_group_31',
          'ambiguousIdentifier',
          'typeHint?',
          'eCS_MemberProcedureCall_group_def_35?',
          'eCS_MemberProcedureCall_group_def_37*',
        ],
      ],
      [
        'eCS_ProcedureCall',
        [
          'CALL',
          'ambiguousIdentifier',
          'typeHint?',
          'eCS_MemberProcedureCall_group_def_35?',
          'eCS_MemberProcedureCall_group_def_37*',
        ],
      ],
      ['implicitCallStmt_InBlock', ['iCS_B_MemberProcedureCall']],
      ['implicitCallStmt_InBlock', ['iCS_B_ProcedureCall']],
      [
        'iCS_B_MemberProcedureCall',
        [
          'implicitCallStmt_InStmt',
          '.',
          'ambiguousIdentifier',
          'typeHint?',
          'argsCall?',
          'dictionaryCallStmt?',
          'eCS_MemberProcedureCall_group_def_37*',
        ],
      ],
      [
        'iCS_B_ProcedureCall',
        [
          'certainIdentifier',
          'argsCall?',
          'eCS_MemberProcedureCall_group_def_37?',
        ],
      ],
      ['argsCall_group_def_43', [',', 'argCall?']],
      ['argsCall', [',*', 'argCall', 'argsCall_group_def_43*']],
      ['argCall', ['valueStmt']],
      ['variableStmt_group_def_45', ['DIM']],
      ['variableStmt_group_44', ['variableStmt_group_def_45']],
      ['variableStmt_group_def_46', ['STATIC']],
      ['variableStmt_group_44', ['variableStmt_group_def_46']],
      ['variableStmt_group_def_47', ['visibility']],
      ['variableStmt_group_44', ['variableStmt_group_def_47']],
      [
        'variableStmt',
        ['variableStmt_group_44', 'WITHEVENTS?', 'variableListStmt'],
      ],
      ['withStmt_group_def_49', ['implicitCallStmt_InStmt']],
      ['withStmt_group_48', ['withStmt_group_def_49']],
      ['withStmt_group_def_50', ['NEW', 'type_']],
      ['withStmt_group_48', ['withStmt_group_def_50']],
      [
        'withStmt',
        ['WITH', 'withStmt_group_48', 'endOfStatement', 'block?', 'END_WITH'],
      ],
      ['variableListStmt_group_def_52', [',', 'variableSubStmt']],
      [
        'variableListStmt',
        ['variableSubStmt', 'variableListStmt_group_def_52*'],
      ],
      ['variableSubStmt_group_def_54', ['LPAREN', 'subscripts?', 'RPAREN']],
      [
        'variableSubStmt',
        [
          'ambiguousIdentifier',
          'variableSubStmt_group_def_54?',
          'typeHint?',
          'asTypeClause?',
        ],
      ],
      ['indexes', ['valueStmt', 'eraseStmt_group_def_24*']],
      ['subscript__group_def_57', ['valueStmt', 'TO']],
      ['subscript_', ['subscript__group_def_57?', 'valueStmt']],
      ['subscripts_group_def_59', [',', 'subscript_']],
      ['subscripts', ['subscript_', 'subscripts_group_def_59*']],
      ['subscript_', ['subscript__group_def_57?', 'valueStmt']],
      ['argList_group_def_63', [',', 'arg']],
      ['argList_group_def_64', ['arg', 'argList_group_def_63*']],
      ['argList', ['LPAREN', 'argList_group_def_64?', 'RPAREN']],
      ['valueStmt_p_end', ['literal']],
      ['valueStmt_p_end', ['implicitCallStmt_InStmt']],
      ['valueStmt_p_end', ['ambiguousIdentifier', 'ASSIGN', 'valueStmt']],
      ['valueStmt_p_end', ['NEW', 'valueStmt']],
      [
        'valueStmt_p_end',
        ['LPAREN', 'valueStmt', 'RPAREN'],
        undefined,
        'AtomExpression',
      ],
      ['implicitCallStmt_InStmt', ['iCS_S_MembersCall']],
      ['implicitCallStmt_InStmt', ['iCS_S_VariableOrProcedureCall']],
      ['implicitCallStmt_InStmt', ['iCS_S_ProcedureOrArrayCall']],
      ['iCS_S_MembersCall_group_def_67', ['iCS_S_VariableOrProcedureCall']],
      ['iCS_S_MembersCall_group_66', ['iCS_S_MembersCall_group_def_67']],
      ['iCS_S_MembersCall_group_def_68', ['iCS_S_ProcedureOrArrayCall']],
      ['iCS_S_MembersCall_group_66', ['iCS_S_MembersCall_group_def_68']],
      [
        'iCS_S_MembersCall_group_def_69',
        ['iCS_S_MembersCall_group_66', 'iCS_S_MemberCall'],
      ],
      ['iCS_S_MembersCall_group_65', ['iCS_S_MembersCall_group_def_69']],
      ['iCS_S_MembersCall_group_def_70', ['iCS_S_SpaceMemberCall']],
      ['iCS_S_MembersCall_group_65', ['iCS_S_MembersCall_group_def_70']],
      [
        'iCS_S_MembersCall',
        [
          'iCS_S_MembersCall_group_65',
          'iCS_S_MemberCall*',
          'dictionaryCallStmt?',
          'eCS_MemberProcedureCall_group_def_37*',
        ],
      ],
      ['iCS_S_MemberCall_group_72', ['iCS_S_MembersCall_group_def_67']],
      ['iCS_S_MemberCall_group_72', ['iCS_S_MembersCall_group_def_68']],
      ['iCS_S_MemberCall', ['.', 'iCS_S_MemberCall_group_72']],
      ['iCS_S_SpaceMemberCall_group_73', ['iCS_S_MembersCall_group_def_67']],
      ['iCS_S_SpaceMemberCall_group_73', ['iCS_S_MembersCall_group_def_68']],
      [
        'iCS_S_SpaceMemberCall',
        ['SPACE_DOT', 'iCS_S_SpaceMemberCall_group_73'],
      ],
      [
        'iCS_S_ProcedureOrArrayCall',
        [
          'ambiguousIdentifier',
          'typeHint?',
          'LPAREN',
          'argsCall?',
          'RPAREN',
          'dictionaryCallStmt?',
          'eCS_MemberProcedureCall_group_def_37*',
        ],
      ],
      [
        'iCS_S_VariableOrProcedureCall',
        [
          'ambiguousIdentifier',
          'typeHint?',
          'dictionaryCallStmt?',
          'eCS_MemberProcedureCall_group_def_37*',
        ],
      ],
      ['dictionaryCallStmt', ['!', 'ambiguousIdentifier', 'typeHint?']],
      ['literal', ['DOUBLELITERAL']],
      ['literal', ['INTEGERLITERAL']],
      ['literal', ['STRINGLITERAL']],
      ['literal', ['NOTHING']],
      ['literal', ['NULL']],
      ['literal', ['TRUE']],
      ['literal', ['FALSE']],
      ['literal', ['DATELITERAL']],
      ['typeHint', ['&']],
      ['typeHint', ['%']],
      ['typeHint', ['#']],
      ['typeHint', ['!']],
      ['typeHint', ['@']],
      ['typeHint', ['$']],
      ['arg_group_def_77', ['BYVAL']],
      ['arg_group_76', ['arg_group_def_77']],
      ['arg_group_def_78', ['BYREF']],
      ['arg_group_76', ['arg_group_def_78']],
      ['arg_group_def_80', ['LPAREN', 'RPAREN']],
      [
        'arg',
        [
          'OPTIONAL?',
          'arg_group_76?',
          'PARAMARRAY?',
          'ambiguousIdentifier',
          'typeHint?',
          'arg_group_def_80?',
          'asTypeClause?',
          'argDefaultValue?',
        ],
      ],
      ['argDefaultValue', ['EQ', 'valueStmt']],
      ['asTypeClause', ['AS', 'NEW?', 'type_', 'fieldLength?']],
      ['type__group_def_82', ['baseType']],
      ['type__group_81', ['type__group_def_82']],
      ['type__group_def_83', ['complexType']],
      ['type__group_81', ['type__group_def_83']],
      ['type_', ['type__group_81', 'arg_group_def_80?']],
      ['complexType_group_def_87', ['.']],
      ['complexType_group_86', ['complexType_group_def_87']],
      ['complexType_group_def_88', ['!']],
      ['complexType_group_86', ['complexType_group_def_88']],
      [
        'complexType_group_def_89',
        ['complexType_group_86', 'ambiguousIdentifier'],
      ],
      ['complexType', ['ambiguousIdentifier', 'complexType_group_def_89*']],
      ['baseType', ['BOOLEAN']],
      ['baseType', ['BYTE']],
      ['baseType', ['DOUBLE']],
      ['baseType', ['INTEGER']],
      ['baseType', ['LONG']],
      ['baseType', ['SINGLE']],
      ['baseType', ['VARIANT']],
      ['baseType', ['STRING']],
      ['baseType', ['DATE']],
      ['fieldLength', ['MULT', 'INTEGERLITERAL']],
      ['fieldLength', ['MULT', 'ambiguousIdentifier']],
      ['ambiguousIdentifier', ['ALIAS']],
      ['ambiguousIdentifier', ['AND']],
      ['ambiguousIdentifier', ['ATTRIBUTE']],
      ['ambiguousIdentifier', ['AS']],
      ['ambiguousIdentifier', ['BEGIN']],
      ['ambiguousIdentifier', ['BOOLEAN']],
      ['ambiguousIdentifier', ['BYVAL']],
      ['ambiguousIdentifier', ['BYREF']],
      ['ambiguousIdentifier', ['BYTE']],
      ['ambiguousIdentifier', ['CALL']],
      ['ambiguousIdentifier', ['CASE']],
      ['ambiguousIdentifier', ['CONST']],
      ['ambiguousIdentifier', ['DATE']],
      ['ambiguousIdentifier', ['DECLARE']],
      ['ambiguousIdentifier', ['DEFBOOL']],
      ['ambiguousIdentifier', ['DEFBYTE']],
      ['ambiguousIdentifier', ['DEFDATE']],
      ['ambiguousIdentifier', ['DEFDBL']],
      ['ambiguousIdentifier', ['DEFDEC']],
      ['ambiguousIdentifier', ['DEFCUR']],
      ['ambiguousIdentifier', ['DEFINT']],
      ['ambiguousIdentifier', ['DEFLNG']],
      ['ambiguousIdentifier', ['DEFOBJ']],
      ['ambiguousIdentifier', ['DEFSNG']],
      ['ambiguousIdentifier', ['DEFSTR']],
      ['ambiguousIdentifier', ['DEFVAR']],
      ['ambiguousIdentifier', ['DIM']],
      ['ambiguousIdentifier', ['DO']],
      ['ambiguousIdentifier', ['DOUBLE']],
      ['ambiguousIdentifier', ['EACH']],
      ['ambiguousIdentifier', ['ELSE']],
      ['ambiguousIdentifier', ['ELSEIF']],
      ['ambiguousIdentifier', ['END_ENUM']],
      ['ambiguousIdentifier', ['END_FUNCTION']],
      ['ambiguousIdentifier', ['END_IF']],
      ['ambiguousIdentifier', ['END_PROPERTY']],
      ['ambiguousIdentifier', ['END_SELECT']],
      ['ambiguousIdentifier', ['END_SUB']],
      ['ambiguousIdentifier', ['END_TYPE']],
      ['ambiguousIdentifier', ['END_WITH']],
      ['ambiguousIdentifier', ['END']],
      ['ambiguousIdentifier', ['ENUM']],
      ['ambiguousIdentifier', ['EQV']],
      ['ambiguousIdentifier', ['ERASE']],
      ['ambiguousIdentifier', ['EVENT']],
      ['ambiguousIdentifier', ['EXIT_DO']],
      ['ambiguousIdentifier', ['EXIT_FOR']],
      ['ambiguousIdentifier', ['EXIT_FUNCTION']],
      ['ambiguousIdentifier', ['EXIT_PROPERTY']],
      ['ambiguousIdentifier', ['EXIT_SUB']],
      ['ambiguousIdentifier', ['FALSE']],
      ['ambiguousIdentifier', ['FRIEND']],
      ['ambiguousIdentifier', ['FOR']],
      ['ambiguousIdentifier', ['FUNCTION']],
      ['ambiguousIdentifier', ['GET']],
      ['ambiguousIdentifier', ['GLOBAL']],
      ['ambiguousIdentifier', ['GOSUB']],
      ['ambiguousIdentifier', ['GOTO']],
      ['ambiguousIdentifier', ['IF']],
      ['ambiguousIdentifier', ['IMPLEMENTS']],
      ['ambiguousIdentifier', ['IN']],
      ['ambiguousIdentifier', ['ISNOT']],
      ['ambiguousIdentifier', ['IS']],
      ['ambiguousIdentifier', ['INTEGER']],
      ['ambiguousIdentifier', ['LONG']],
      ['ambiguousIdentifier', ['LOOP']],
      ['ambiguousIdentifier', ['LEN']],
      ['ambiguousIdentifier', ['LET']],
      ['ambiguousIdentifier', ['LIB']],
      ['ambiguousIdentifier', ['LIKE']],
      ['ambiguousIdentifier', ['LSET']],
      ['ambiguousIdentifier', ['MACRO_CONST']],
      ['ambiguousIdentifier', ['MACRO_IF']],
      ['ambiguousIdentifier', ['MACRO_ELSEIF']],
      ['ambiguousIdentifier', ['MACRO_ELSE']],
      ['ambiguousIdentifier', ['MACRO_END_IF']],
      ['ambiguousIdentifier', ['MOD']],
      ['ambiguousIdentifier', ['NEXT']],
      ['ambiguousIdentifier', ['NEW']],
      ['ambiguousIdentifier', ['NOT']],
      ['ambiguousIdentifier', ['NOTHING']],
      ['ambiguousIdentifier', ['NULL']],
      ['ambiguousIdentifier', ['ON_ERROR']],
      ['ambiguousIdentifier', ['ON_LOCAL_ERROR']],
      ['ambiguousIdentifier', ['ON']],
      ['ambiguousIdentifier', ['OPTIONAL']],
      ['ambiguousIdentifier', ['OPTION_BASE']],
      ['ambiguousIdentifier', ['OPTION_EXPLICIT']],
      ['ambiguousIdentifier', ['OPTION_COMPARE']],
      ['ambiguousIdentifier', ['OPTION_PRIVATE_MODULE']],
      ['ambiguousIdentifier', ['OR']],
      ['ambiguousIdentifier', ['PARAMARRAY']],
      ['ambiguousIdentifier', ['PRESERVE']],
      ['ambiguousIdentifier', ['PRIVATE']],
      ['ambiguousIdentifier', ['PROPERTY_GET']],
      ['ambiguousIdentifier', ['PROPERTY_LET']],
      ['ambiguousIdentifier', ['PROPERTY_SET']],
      ['ambiguousIdentifier', ['PTRSAFE']],
      ['ambiguousIdentifier', ['PUBLIC']],
      ['ambiguousIdentifier', ['RAISEEVENT']],
      ['ambiguousIdentifier', ['REDIM']],
      ['ambiguousIdentifier', ['RESET']],
      ['ambiguousIdentifier', ['RESUME']],
      ['ambiguousIdentifier', ['RETURN']],
      ['ambiguousIdentifier', ['SELECT']],
      ['ambiguousIdentifier', ['SET']],
      ['ambiguousIdentifier', ['SINGLE']],
      ['ambiguousIdentifier', ['STATIC']],
      ['ambiguousIdentifier', ['STEP']],
      ['ambiguousIdentifier', ['STOP']],
      ['ambiguousIdentifier', ['STRING']],
      ['ambiguousIdentifier', ['SUB']],
      ['ambiguousIdentifier', ['THEN']],
      ['ambiguousIdentifier', ['TO']],
      ['ambiguousIdentifier', ['TRUE']],
      ['ambiguousIdentifier', ['TYPEOF']],
      ['ambiguousIdentifier', ['UNTIL']],
      ['ambiguousIdentifier', ['VARIANT']],
      ['ambiguousIdentifier', ['WEND']],
      ['ambiguousIdentifier', ['WHILE']],
      ['ambiguousIdentifier', ['WITH']],
      ['ambiguousIdentifier', ['WITHEVENTS']],
      ['ambiguousIdentifier', ['XOR']],
      ['ambiguousIdentifier', ['IMP']],
      ['certainIdentifier', ['IDENTIFIER']],
      ['ambiguousIdentifier', ['IDENTIFIER']],
      ['valueStmt', ['valueStmt_p_2'], undefined, undefined, undefined, true],
      ['valueStmt', ['NOT', 'valueStmt'], undefined, 'PrefixExpression'],
      [
        '(valueStmt_p_2)1_',
        ['IS', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        'valueStmt_p_2',
        ['valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        undefined,
        undefined,
        true,
      ],
      [
        '(valueStmt_p_2)1_',
        ['ISNOT', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_2)1_',
        ['GEQ', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_2)1_',
        ['LEQ', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_2)1_',
        ['GT', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_2)1_',
        ['LT', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_2)1_',
        ['NEQ', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_2)1_',
        ['EQ', 'valueStmt_p_3', 1, '(valueStmt_p_2)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_3)1_',
        ['XOR', 'valueStmt_p_4', 1, '(valueStmt_p_3)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        'valueStmt_p_3',
        ['valueStmt_p_4', 1, '(valueStmt_p_3)1_'],
        undefined,
        undefined,
        undefined,
        true,
      ],
      [
        '(valueStmt_p_3)1_',
        ['OR', 'valueStmt_p_4', 1, '(valueStmt_p_3)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_3)1_',
        ['AND', 'valueStmt_p_4', 1, '(valueStmt_p_3)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_4)1_',
        ['PLUS', 'valueStmt_p_5', 1, '(valueStmt_p_4)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        'valueStmt_p_4',
        ['valueStmt_p_5', 1, '(valueStmt_p_4)1_'],
        undefined,
        undefined,
        undefined,
        true,
      ],
      [
        '(valueStmt_p_4)1_',
        ['MINUS', 'valueStmt_p_5', 1, '(valueStmt_p_4)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_4)1_',
        ['AMPERSAND', 'valueStmt_p_5', 1, '(valueStmt_p_4)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_5)1_',
        ['MULT', 'valueStmt_p_6', 1, '(valueStmt_p_5)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        'valueStmt_p_5',
        ['valueStmt_p_6', 1, '(valueStmt_p_5)1_'],
        undefined,
        undefined,
        undefined,
        true,
      ],
      [
        '(valueStmt_p_5)1_',
        ['DIV', 'valueStmt_p_6', 1, '(valueStmt_p_5)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_5)1_',
        ['IDIV', 'valueStmt_p_6', 1, '(valueStmt_p_5)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_5)1_',
        ['MOD', 'valueStmt_p_6', 1, '(valueStmt_p_5)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        '(valueStmt_p_6)1_',
        ['POW', 'valueStmt_p_7', 1, '(valueStmt_p_6)1_'],
        undefined,
        'BinaryExpression',
      ],
      [
        'valueStmt_p_6',
        ['valueStmt_p_7', 1, '(valueStmt_p_6)1_'],
        undefined,
        undefined,
        undefined,
        true,
      ],
      [
        'valueStmt_p_7',
        ['valueStmt_p_end'],
        undefined,
        undefined,
        undefined,
        true,
      ],
      [
        'valueStmt_p_7',
        ['MINUS', 'valueStmt_p_7'],
        undefined,
        'PrefixExpression',
      ],
      [
        'valueStmt_p_7',
        ['PLUS', 'valueStmt_p_7'],
        undefined,
        'PrefixExpression',
      ],
      ['(valueStmt_p_2)1_', []],
      ['(valueStmt_p_3)1_', []],
      ['(valueStmt_p_4)1_', []],
      ['(valueStmt_p_5)1_', []],
      ['(valueStmt_p_6)1_', []],
    ],
    productionIndexMap: {
      symbol: 0,
      rhs: 1,
      action: 2,
      label: 3,
      predict: 4,
      isWrap: 5,
    },
    isCompress: 1,
    getProductionItemByType: function (p, itemType) {
      if (this.isCompress) {
        return p && p[this.productionIndexMap[itemType]];
      }

      return p && p[itemType];
    },
    getProductionSymbol: function (p) {
      return this.getProductionItemByType(p, 'symbol');
    },
    getProductionRhs: function (p) {
      return this.getProductionItemByType(p, 'rhs');
    },
    getProductionAction: function (p) {
      return this.getProductionItemByType(p, 'action');
    },
    getProductionPredict: function (p) {
      return this.getProductionItemByType(p, 'predict');
    },
    getProductionIsWrap: function (p) {
      return this.getProductionItemByType(p, 'isWrap');
    },
    getProductionLabel: function (p) {
      return this.getProductionItemByType(p, 'label');
    },
    getCurrentSymbolNode: function () {
      return astStack[astStack.length - 1];
    },
  };
  parser.getProductionItemByType = parser.getProductionItemByType.bind(parser);
  parser.getProductionSymbol = parser.getProductionSymbol.bind(parser);
  parser.getProductionRhs = parser.getProductionRhs.bind(parser);
  parser.getProductionAction = parser.getProductionAction.bind(parser);
  parser.getProductionPredict = parser.getProductionPredict.bind(parser);
  parser.getProductionIsWrap = parser.getProductionIsWrap.bind(parser);
  parser.getProductionLabel = parser.getProductionLabel.bind(parser);
  parser.getCurrentSymbolNode = parser.getCurrentSymbolNode.bind(parser);
  parser.lexer = lexer;
  parser.lex = lex;
  parser.prioritySymbolMap = {
    valueStmt_p_end: 'valueStmt',
    valueStmt_p_1: 'valueStmt',
    valueStmt_p_2: 'valueStmt',
    valueStmt_p_3: 'valueStmt',
    valueStmt_p_4: 'valueStmt',
    valueStmt_p_5: 'valueStmt',
    valueStmt_p_6: 'valueStmt',
    valueStmt_p_7: 'valueStmt',
  };
  productionSkipAstNodeSet = new Set([
    5, 6, 7, 8, 10, 19, 35, 57, 58, 59, 60, 62, 63, 65, 74, 83, 89, 90, 91, 92,
    96, 98, 107, 108, 109, 110, 111, 112, 117, 118, 119, 120, 121, 122, 129,
    132, 133, 134, 135, 136, 137, 139, 140, 141, 142, 144, 146, 149, 151, 154,
    155, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 177, 178, 197, 198,
    199, 200, 201, 205, 206, 207, 208, 210, 211, 212, 213, 214, 355, 357, 358,
    359, 360, 361, 362, 363, 364, 366, 367, 368, 370, 371, 372, 374, 375, 376,
    377, 382, 383, 384, 385, 386,
  ]);
  const parserPredictTable = {
    $START: {
      COMMENT: [0],
      DIM: [0],
      STATIC: [0],
      OPTION_BASE: [0],
      OPTION_COMPARE: [0],
      OPTION_EXPLICIT: [0],
      OPTION_PRIVATE_MODULE: [0],
      NEWLINE: [0],
      REMCOMMENT: [0],
      PRIVATE: [0],
      PUBLIC: [0],
      FRIEND: [0],
      GLOBAL: [0],
      FUNCTION: [0],
      PROPERTY_GET: [0],
      PROPERTY_SET: [0],
      PROPERTY_LET: [0],
      SUB: [0],
      $EOF: [0],
    },
    progam: {
      COMMENT: [1],
      DIM: [1],
      STATIC: [1],
      PRIVATE: [1],
      PUBLIC: [1],
      FRIEND: [1],
      GLOBAL: [1],
      OPTION_BASE: [1],
      OPTION_COMPARE: [1],
      OPTION_EXPLICIT: [1],
      OPTION_PRIVATE_MODULE: [1],
      NEWLINE: [1],
      REMCOMMENT: [1],
      FUNCTION: [1],
      PROPERTY_GET: [1],
      PROPERTY_SET: [1],
      PROPERTY_LET: [1],
      SUB: [1],
      $EOF: [1],
    },
    endOfLine: {
      NEWLINE: [2],
      COMMENT: [3],
      REMCOMMENT: [4],
    },
    endOfStatement_group_def_2: {
      NEWLINE: [5],
      COMMENT: [5],
      REMCOMMENT: [5],
    },
    endOfStatement_group_1: {
      NEWLINE: [6],
      COMMENT: [6],
      REMCOMMENT: [6],
      COLON: [8],
    },
    endOfStatement_group_def_3: {
      COLON: [7],
    },
    endOfStatement: {
      NEWLINE: [9],
      COMMENT: [9],
      REMCOMMENT: [9],
      COLON: [9],
    },
    moduleDeclarations_group_def_5: {
      NEWLINE: [10],
      COMMENT: [10],
      REMCOMMENT: [10],
    },
    moduleDeclarations: {
      COMMENT: [11],
      DIM: [11],
      STATIC: [11],
      PRIVATE: [11],
      PUBLIC: [11],
      FRIEND: [11],
      GLOBAL: [11],
      OPTION_BASE: [11],
      OPTION_COMPARE: [11],
      OPTION_EXPLICIT: [11],
      OPTION_PRIVATE_MODULE: [11],
    },
    moduleDeclarationsElement: {
      COMMENT: [12],
      DIM: [13],
      STATIC: [13],
      PRIVATE: [13],
      PUBLIC: [13],
      FRIEND: [13],
      GLOBAL: [13],
      OPTION_BASE: [14],
      OPTION_COMPARE: [14],
      OPTION_EXPLICIT: [14],
      OPTION_PRIVATE_MODULE: [14],
    },
    moduleOption: {
      OPTION_BASE: [15],
      OPTION_COMPARE: [16],
      OPTION_EXPLICIT: [17],
      OPTION_PRIVATE_MODULE: [18],
    },
    moduleBody_group_def_7: {
      NEWLINE: [19],
      COMMENT: [19],
      REMCOMMENT: [19],
    },
    moduleBody: {
      PRIVATE: [20],
      PUBLIC: [20],
      FRIEND: [20],
      GLOBAL: [20],
      STATIC: [20],
      FUNCTION: [20],
      PROPERTY_GET: [20],
      PROPERTY_SET: [20],
      PROPERTY_LET: [20],
      SUB: [20],
    },
    moduleBodyElement: {
      PRIVATE: [21, 22, 23, 24, 25],
      PUBLIC: [21, 22, 23, 24, 25],
      FRIEND: [21, 22, 23, 24, 25],
      GLOBAL: [21, 22, 23, 24, 25],
      STATIC: [21, 22, 23, 24, 25],
      FUNCTION: [21],
      PROPERTY_GET: [22],
      PROPERTY_SET: [23],
      PROPERTY_LET: [24],
      SUB: [25],
    },
    visibility: {
      PRIVATE: [26],
      PUBLIC: [27],
      FRIEND: [28],
      GLOBAL: [29],
    },
    subStmt: {
      PRIVATE: [30],
      PUBLIC: [30],
      FRIEND: [30],
      GLOBAL: [30],
      STATIC: [30],
      SUB: [30],
    },
    propertyGetStmt: {
      PRIVATE: [31],
      PUBLIC: [31],
      FRIEND: [31],
      GLOBAL: [31],
      STATIC: [31],
      PROPERTY_GET: [31],
    },
    propertySetStmt: {
      PRIVATE: [32],
      PUBLIC: [32],
      FRIEND: [32],
      GLOBAL: [32],
      STATIC: [32],
      PROPERTY_SET: [32],
    },
    propertyLetStmt: {
      PRIVATE: [33],
      PUBLIC: [33],
      FRIEND: [33],
      GLOBAL: [33],
      STATIC: [33],
      PROPERTY_LET: [33],
    },
    functionStmt: {
      PRIVATE: [34],
      PUBLIC: [34],
      FRIEND: [34],
      GLOBAL: [34],
      STATIC: [34],
      FUNCTION: [34],
    },
    block_group_def_9: {
      NEWLINE: [35],
      COMMENT: [35],
      REMCOMMENT: [35],
      COLON: [35],
    },
    block: {
      ALIAS: [36],
      AND: [36],
      ATTRIBUTE: [36],
      AS: [36],
      BEGIN: [36],
      BOOLEAN: [36],
      BYVAL: [36],
      BYREF: [36],
      BYTE: [36],
      CALL: [36],
      CASE: [36],
      CONST: [36],
      DATE: [36],
      DECLARE: [36],
      DEFBOOL: [36],
      DEFBYTE: [36],
      DEFDATE: [36],
      DEFDBL: [36],
      DEFDEC: [36],
      DEFCUR: [36],
      DEFINT: [36],
      DEFLNG: [36],
      DEFOBJ: [36],
      DEFSNG: [36],
      DEFSTR: [36],
      DEFVAR: [36],
      DIM: [36],
      DO: [36],
      DOUBLE: [36],
      EACH: [36],
      ELSE: [36],
      ELSEIF: [36],
      END_ENUM: [36],
      END_FUNCTION: [36],
      END_IF: [36],
      END_PROPERTY: [36],
      END_SELECT: [36],
      END_SUB: [36],
      END_TYPE: [36],
      END_WITH: [36],
      END: [36],
      ENUM: [36],
      EQV: [36],
      ERASE: [36],
      EVENT: [36],
      EXIT_DO: [36],
      EXIT_FOR: [36],
      EXIT_FUNCTION: [36],
      EXIT_PROPERTY: [36],
      EXIT_SUB: [36],
      FALSE: [36],
      FRIEND: [36],
      FOR: [36],
      FUNCTION: [36],
      GET: [36],
      GLOBAL: [36],
      GOSUB: [36],
      GOTO: [36],
      IF: [36],
      IMPLEMENTS: [36],
      IN: [36],
      ISNOT: [36],
      IS: [36],
      INTEGER: [36],
      LONG: [36],
      LOOP: [36],
      LEN: [36],
      LET: [36],
      LIB: [36],
      LIKE: [36],
      LSET: [36],
      MACRO_CONST: [36],
      MACRO_IF: [36],
      MACRO_ELSEIF: [36],
      MACRO_ELSE: [36],
      MACRO_END_IF: [36],
      MOD: [36],
      NEXT: [36],
      NEW: [36],
      NOT: [36],
      NOTHING: [36],
      NULL: [36],
      ON_ERROR: [36],
      ON_LOCAL_ERROR: [36],
      ON: [36],
      OPTIONAL: [36],
      OPTION_BASE: [36],
      OPTION_EXPLICIT: [36],
      OPTION_COMPARE: [36],
      OPTION_PRIVATE_MODULE: [36],
      OR: [36],
      PARAMARRAY: [36],
      PRESERVE: [36],
      PRIVATE: [36],
      PROPERTY_GET: [36],
      PROPERTY_LET: [36],
      PROPERTY_SET: [36],
      PTRSAFE: [36],
      PUBLIC: [36],
      RAISEEVENT: [36],
      REDIM: [36],
      RESET: [36],
      RESUME: [36],
      RETURN: [36],
      SELECT: [36],
      SET: [36],
      SINGLE: [36],
      STATIC: [36],
      STEP: [36],
      STOP: [36],
      STRING: [36],
      SUB: [36],
      THEN: [36],
      TO: [36],
      TRUE: [36],
      TYPEOF: [36],
      UNTIL: [36],
      VARIANT: [36],
      WEND: [36],
      WHILE: [36],
      WITH: [36],
      WITHEVENTS: [36],
      XOR: [36],
      IMP: [36],
      IDENTIFIER: [36],
      SPACE_DOT: [36],
    },
    blockStmt: {
      ALIAS: [37, 52, 54],
      AND: [37, 52, 54],
      ATTRIBUTE: [37, 52, 54],
      AS: [37, 52, 54],
      BEGIN: [37, 52, 54],
      BOOLEAN: [37, 52, 54],
      BYVAL: [37, 52, 54],
      BYREF: [37, 52, 54],
      BYTE: [37, 52, 54],
      CALL: [37, 49, 52, 54],
      CASE: [37, 52, 54],
      CONST: [37, 52, 54],
      DATE: [37, 52, 54],
      DECLARE: [37, 52, 54],
      DEFBOOL: [37, 52, 54],
      DEFBYTE: [37, 52, 54],
      DEFDATE: [37, 52, 54],
      DEFDBL: [37, 52, 54],
      DEFDEC: [37, 52, 54],
      DEFCUR: [37, 52, 54],
      DEFINT: [37, 52, 54],
      DEFLNG: [37, 52, 54],
      DEFOBJ: [37, 52, 54],
      DEFSNG: [37, 52, 54],
      DEFSTR: [37, 52, 54],
      DEFVAR: [37, 52, 54],
      DIM: [37, 52, 53, 54],
      DO: [37, 43, 52, 54],
      DOUBLE: [37, 52, 54],
      EACH: [37, 52, 54],
      ELSE: [37, 52, 54],
      ELSEIF: [37, 52, 54],
      END_ENUM: [37, 52, 54],
      END_FUNCTION: [37, 52, 54],
      END_IF: [37, 52, 54],
      END_PROPERTY: [37, 52, 54],
      END_SELECT: [37, 52, 54],
      END_SUB: [37, 52, 54],
      END_TYPE: [37, 52, 54],
      END_WITH: [37, 52, 54],
      END: [37, 48, 52, 54],
      ENUM: [37, 52, 54],
      EQV: [37, 52, 54],
      ERASE: [37, 47, 52, 54],
      EVENT: [37, 52, 54],
      EXIT_DO: [37, 48, 52, 54],
      EXIT_FOR: [37, 48, 52, 54],
      EXIT_FUNCTION: [37, 48, 52, 54],
      EXIT_PROPERTY: [37, 48, 52, 54],
      EXIT_SUB: [37, 48, 52, 54],
      FALSE: [37, 52, 54],
      FRIEND: [37, 52, 53, 54],
      FOR: [37, 41, 42, 52, 54],
      FUNCTION: [37, 52, 54],
      GET: [37, 52, 54],
      GLOBAL: [37, 52, 53, 54],
      GOSUB: [37, 52, 54],
      GOTO: [37, 38, 52, 54],
      IF: [37, 39, 52, 54],
      IMPLEMENTS: [37, 52, 54],
      IN: [37, 52, 54],
      ISNOT: [37, 52, 54],
      IS: [37, 52, 54],
      INTEGER: [37, 52, 54],
      LONG: [37, 52, 54],
      LOOP: [37, 52, 54],
      LEN: [37, 52, 54],
      LET: [37, 52, 54],
      LIB: [37, 52, 54],
      LIKE: [37, 52, 54],
      LSET: [37, 52, 54],
      MACRO_CONST: [37, 52, 54],
      MACRO_IF: [37, 52, 54],
      MACRO_ELSEIF: [37, 52, 54],
      MACRO_ELSE: [37, 52, 54],
      MACRO_END_IF: [37, 52, 54],
      MOD: [37, 52, 54],
      NEXT: [37, 52, 54],
      NEW: [37, 52, 54],
      NOT: [37, 52, 54],
      NOTHING: [37, 52, 54],
      NULL: [37, 52, 54],
      ON_ERROR: [37, 45, 52, 54],
      ON_LOCAL_ERROR: [37, 52, 54],
      ON: [37, 52, 54],
      OPTIONAL: [37, 52, 54],
      OPTION_BASE: [37, 52, 54],
      OPTION_EXPLICIT: [37, 52, 54],
      OPTION_COMPARE: [37, 52, 54],
      OPTION_PRIVATE_MODULE: [37, 52, 54],
      OR: [37, 52, 54],
      PARAMARRAY: [37, 52, 54],
      PRESERVE: [37, 52, 54],
      PRIVATE: [37, 52, 53, 54],
      PROPERTY_GET: [37, 52, 54],
      PROPERTY_LET: [37, 52, 54],
      PROPERTY_SET: [37, 52, 54],
      PTRSAFE: [37, 52, 54],
      PUBLIC: [37, 52, 53, 54],
      RAISEEVENT: [37, 52, 54],
      REDIM: [37, 51, 52, 54],
      RESET: [37, 52, 54],
      RESUME: [37, 52, 54],
      RETURN: [37, 52, 54],
      SELECT: [37, 40, 52, 54],
      SET: [37, 50, 52, 54],
      SINGLE: [37, 52, 54],
      STATIC: [37, 52, 53, 54],
      STEP: [37, 52, 54],
      STOP: [37, 52, 54],
      STRING: [37, 52, 54],
      SUB: [37, 52, 54],
      THEN: [37, 52, 54],
      TO: [37, 52, 54],
      TRUE: [37, 52, 54],
      TYPEOF: [37, 52, 54],
      UNTIL: [37, 52, 54],
      VARIANT: [37, 52, 54],
      WEND: [37, 52, 54],
      WHILE: [37, 44, 52, 54],
      WITH: [37, 46, 52, 54],
      WITHEVENTS: [37, 52, 54],
      XOR: [37, 52, 54],
      IMP: [37, 52, 54],
      IDENTIFIER: [37, 52, 54],
      SPACE_DOT: [52, 54],
    },
    whileWendStmt: {
      WHILE: [55],
    },
    doLoopStmt: {
      DO: [56, 61, 64],
    },
    doLoopStmt_group_def_11: {
      WHILE: [57],
    },
    doLoopStmt_group_10: {
      WHILE: [58],
      UNTIL: [60],
    },
    doLoopStmt_group_def_12: {
      UNTIL: [59],
    },
    doLoopStmt_group_13: {
      WHILE: [62],
      UNTIL: [63],
    },
    forNextStmt_group_def_15: {
      STEP: [65],
    },
    forNextStmt: {
      FOR: [66],
    },
    forEachStmt: {
      FOR: [67],
    },
    selectCaseStmt: {
      SELECT: [68],
    },
    sC_Selection: {
      IS: [69, 70, 71],
      DOUBLELITERAL: [70, 71],
      INTEGERLITERAL: [70, 71],
      STRINGLITERAL: [70, 71],
      NOTHING: [70, 71],
      NULL: [70, 71],
      TRUE: [70, 71],
      FALSE: [70, 71],
      DATELITERAL: [70, 71],
      SPACE_DOT: [70, 71],
      ALIAS: [70, 71],
      AND: [70, 71],
      ATTRIBUTE: [70, 71],
      AS: [70, 71],
      BEGIN: [70, 71],
      BOOLEAN: [70, 71],
      BYVAL: [70, 71],
      BYREF: [70, 71],
      BYTE: [70, 71],
      CALL: [70, 71],
      CASE: [70, 71],
      CONST: [70, 71],
      DATE: [70, 71],
      DECLARE: [70, 71],
      DEFBOOL: [70, 71],
      DEFBYTE: [70, 71],
      DEFDATE: [70, 71],
      DEFDBL: [70, 71],
      DEFDEC: [70, 71],
      DEFCUR: [70, 71],
      DEFINT: [70, 71],
      DEFLNG: [70, 71],
      DEFOBJ: [70, 71],
      DEFSNG: [70, 71],
      DEFSTR: [70, 71],
      DEFVAR: [70, 71],
      DIM: [70, 71],
      DO: [70, 71],
      DOUBLE: [70, 71],
      EACH: [70, 71],
      ELSE: [70, 71],
      ELSEIF: [70, 71],
      END_ENUM: [70, 71],
      END_FUNCTION: [70, 71],
      END_IF: [70, 71],
      END_PROPERTY: [70, 71],
      END_SELECT: [70, 71],
      END_SUB: [70, 71],
      END_TYPE: [70, 71],
      END_WITH: [70, 71],
      END: [70, 71],
      ENUM: [70, 71],
      EQV: [70, 71],
      ERASE: [70, 71],
      EVENT: [70, 71],
      EXIT_DO: [70, 71],
      EXIT_FOR: [70, 71],
      EXIT_FUNCTION: [70, 71],
      EXIT_PROPERTY: [70, 71],
      EXIT_SUB: [70, 71],
      FRIEND: [70, 71],
      FOR: [70, 71],
      FUNCTION: [70, 71],
      GET: [70, 71],
      GLOBAL: [70, 71],
      GOSUB: [70, 71],
      GOTO: [70, 71],
      IF: [70, 71],
      IMPLEMENTS: [70, 71],
      IN: [70, 71],
      ISNOT: [70, 71],
      INTEGER: [70, 71],
      LONG: [70, 71],
      LOOP: [70, 71],
      LEN: [70, 71],
      LET: [70, 71],
      LIB: [70, 71],
      LIKE: [70, 71],
      LSET: [70, 71],
      MACRO_CONST: [70, 71],
      MACRO_IF: [70, 71],
      MACRO_ELSEIF: [70, 71],
      MACRO_ELSE: [70, 71],
      MACRO_END_IF: [70, 71],
      MOD: [70, 71],
      NEXT: [70, 71],
      NEW: [70, 71],
      NOT: [70, 71],
      ON_ERROR: [70, 71],
      ON_LOCAL_ERROR: [70, 71],
      ON: [70, 71],
      OPTIONAL: [70, 71],
      OPTION_BASE: [70, 71],
      OPTION_EXPLICIT: [70, 71],
      OPTION_COMPARE: [70, 71],
      OPTION_PRIVATE_MODULE: [70, 71],
      OR: [70, 71],
      PARAMARRAY: [70, 71],
      PRESERVE: [70, 71],
      PRIVATE: [70, 71],
      PROPERTY_GET: [70, 71],
      PROPERTY_LET: [70, 71],
      PROPERTY_SET: [70, 71],
      PTRSAFE: [70, 71],
      PUBLIC: [70, 71],
      RAISEEVENT: [70, 71],
      REDIM: [70, 71],
      RESET: [70, 71],
      RESUME: [70, 71],
      RETURN: [70, 71],
      SELECT: [70, 71],
      SET: [70, 71],
      SINGLE: [70, 71],
      STATIC: [70, 71],
      STEP: [70, 71],
      STOP: [70, 71],
      STRING: [70, 71],
      SUB: [70, 71],
      THEN: [70, 71],
      TO: [70, 71],
      TYPEOF: [70, 71],
      UNTIL: [70, 71],
      VARIANT: [70, 71],
      WEND: [70, 71],
      WHILE: [70, 71],
      WITH: [70, 71],
      WITHEVENTS: [70, 71],
      XOR: [70, 71],
      IMP: [70, 71],
      IDENTIFIER: [70, 71],
      LPAREN: [70, 71],
      MINUS: [70, 71],
      PLUS: [70, 71],
    },
    sC_Case: {
      CASE: [72],
    },
    sC_Cond: {
      ELSE: [73, 75],
      IS: [75],
      DOUBLELITERAL: [75],
      INTEGERLITERAL: [75],
      STRINGLITERAL: [75],
      NOTHING: [75],
      NULL: [75],
      TRUE: [75],
      FALSE: [75],
      DATELITERAL: [75],
      SPACE_DOT: [75],
      ALIAS: [75],
      AND: [75],
      ATTRIBUTE: [75],
      AS: [75],
      BEGIN: [75],
      BOOLEAN: [75],
      BYVAL: [75],
      BYREF: [75],
      BYTE: [75],
      CALL: [75],
      CASE: [75],
      CONST: [75],
      DATE: [75],
      DECLARE: [75],
      DEFBOOL: [75],
      DEFBYTE: [75],
      DEFDATE: [75],
      DEFDBL: [75],
      DEFDEC: [75],
      DEFCUR: [75],
      DEFINT: [75],
      DEFLNG: [75],
      DEFOBJ: [75],
      DEFSNG: [75],
      DEFSTR: [75],
      DEFVAR: [75],
      DIM: [75],
      DO: [75],
      DOUBLE: [75],
      EACH: [75],
      ELSEIF: [75],
      END_ENUM: [75],
      END_FUNCTION: [75],
      END_IF: [75],
      END_PROPERTY: [75],
      END_SELECT: [75],
      END_SUB: [75],
      END_TYPE: [75],
      END_WITH: [75],
      END: [75],
      ENUM: [75],
      EQV: [75],
      ERASE: [75],
      EVENT: [75],
      EXIT_DO: [75],
      EXIT_FOR: [75],
      EXIT_FUNCTION: [75],
      EXIT_PROPERTY: [75],
      EXIT_SUB: [75],
      FRIEND: [75],
      FOR: [75],
      FUNCTION: [75],
      GET: [75],
      GLOBAL: [75],
      GOSUB: [75],
      GOTO: [75],
      IF: [75],
      IMPLEMENTS: [75],
      IN: [75],
      ISNOT: [75],
      INTEGER: [75],
      LONG: [75],
      LOOP: [75],
      LEN: [75],
      LET: [75],
      LIB: [75],
      LIKE: [75],
      LSET: [75],
      MACRO_CONST: [75],
      MACRO_IF: [75],
      MACRO_ELSEIF: [75],
      MACRO_ELSE: [75],
      MACRO_END_IF: [75],
      MOD: [75],
      NEXT: [75],
      NEW: [75],
      NOT: [75],
      ON_ERROR: [75],
      ON_LOCAL_ERROR: [75],
      ON: [75],
      OPTIONAL: [75],
      OPTION_BASE: [75],
      OPTION_EXPLICIT: [75],
      OPTION_COMPARE: [75],
      OPTION_PRIVATE_MODULE: [75],
      OR: [75],
      PARAMARRAY: [75],
      PRESERVE: [75],
      PRIVATE: [75],
      PROPERTY_GET: [75],
      PROPERTY_LET: [75],
      PROPERTY_SET: [75],
      PTRSAFE: [75],
      PUBLIC: [75],
      RAISEEVENT: [75],
      REDIM: [75],
      RESET: [75],
      RESUME: [75],
      RETURN: [75],
      SELECT: [75],
      SET: [75],
      SINGLE: [75],
      STATIC: [75],
      STEP: [75],
      STOP: [75],
      STRING: [75],
      SUB: [75],
      THEN: [75],
      TO: [75],
      TYPEOF: [75],
      UNTIL: [75],
      VARIANT: [75],
      WEND: [75],
      WHILE: [75],
      WITH: [75],
      WITHEVENTS: [75],
      XOR: [75],
      IMP: [75],
      IDENTIFIER: [75],
      LPAREN: [75],
      MINUS: [75],
      PLUS: [75],
    },
    sC_Cond_group_def_17: {
      ',': [74],
    },
    comparisonOperator: {
      LT: [76],
      LEQ: [77],
      GT: [78],
      GEQ: [79],
      EQ: [80],
      NEQ: [81],
      IS: [82],
    },
    ifThenElseStmt_group_def_19: {
      ELSE: [83],
    },
    ifThenElseStmt: {
      IF: [84, 85],
    },
    ifBlockStmt: {
      IF: [86],
    },
    ifElseIfBlockStmt: {
      ELSEIF: [87],
    },
    ifElseBlockStmt: {
      ELSE: [88],
    },
    onErrorStmt_group_def_21: {
      ALIAS: [89],
      AND: [89],
      ATTRIBUTE: [89],
      AS: [89],
      BEGIN: [89],
      BOOLEAN: [89],
      BYVAL: [89],
      BYREF: [89],
      BYTE: [89],
      CALL: [89],
      CASE: [89],
      CONST: [89],
      DATE: [89],
      DECLARE: [89],
      DEFBOOL: [89],
      DEFBYTE: [89],
      DEFDATE: [89],
      DEFDBL: [89],
      DEFDEC: [89],
      DEFCUR: [89],
      DEFINT: [89],
      DEFLNG: [89],
      DEFOBJ: [89],
      DEFSNG: [89],
      DEFSTR: [89],
      DEFVAR: [89],
      DIM: [89],
      DO: [89],
      DOUBLE: [89],
      EACH: [89],
      ELSE: [89],
      ELSEIF: [89],
      END_ENUM: [89],
      END_FUNCTION: [89],
      END_IF: [89],
      END_PROPERTY: [89],
      END_SELECT: [89],
      END_SUB: [89],
      END_TYPE: [89],
      END_WITH: [89],
      END: [89],
      ENUM: [89],
      EQV: [89],
      ERASE: [89],
      EVENT: [89],
      EXIT_DO: [89],
      EXIT_FOR: [89],
      EXIT_FUNCTION: [89],
      EXIT_PROPERTY: [89],
      EXIT_SUB: [89],
      FALSE: [89],
      FRIEND: [89],
      FOR: [89],
      FUNCTION: [89],
      GET: [89],
      GLOBAL: [89],
      GOSUB: [89],
      GOTO: [89],
      IF: [89],
      IMPLEMENTS: [89],
      IN: [89],
      ISNOT: [89],
      IS: [89],
      INTEGER: [89],
      LONG: [89],
      LOOP: [89],
      LEN: [89],
      LET: [89],
      LIB: [89],
      LIKE: [89],
      LSET: [89],
      MACRO_CONST: [89],
      MACRO_IF: [89],
      MACRO_ELSEIF: [89],
      MACRO_ELSE: [89],
      MACRO_END_IF: [89],
      MOD: [89],
      NEXT: [89],
      NEW: [89],
      NOT: [89],
      NOTHING: [89],
      NULL: [89],
      ON_ERROR: [89],
      ON_LOCAL_ERROR: [89],
      ON: [89],
      OPTIONAL: [89],
      OPTION_BASE: [89],
      OPTION_EXPLICIT: [89],
      OPTION_COMPARE: [89],
      OPTION_PRIVATE_MODULE: [89],
      OR: [89],
      PARAMARRAY: [89],
      PRESERVE: [89],
      PRIVATE: [89],
      PROPERTY_GET: [89],
      PROPERTY_LET: [89],
      PROPERTY_SET: [89],
      PTRSAFE: [89],
      PUBLIC: [89],
      RAISEEVENT: [89],
      REDIM: [89],
      RESET: [89],
      RESUME: [89],
      RETURN: [89],
      SELECT: [89],
      SET: [89],
      SINGLE: [89],
      STATIC: [89],
      STEP: [89],
      STOP: [89],
      STRING: [89],
      SUB: [89],
      THEN: [89],
      TO: [89],
      TRUE: [89],
      TYPEOF: [89],
      UNTIL: [89],
      VARIANT: [89],
      WEND: [89],
      WHILE: [89],
      WITH: [89],
      WITHEVENTS: [89],
      XOR: [89],
      IMP: [89],
      IDENTIFIER: [89],
    },
    onErrorStmt_group_20: {
      ALIAS: [90],
      AND: [90],
      ATTRIBUTE: [90],
      AS: [90],
      BEGIN: [90],
      BOOLEAN: [90],
      BYVAL: [90],
      BYREF: [90],
      BYTE: [90],
      CALL: [90],
      CASE: [90],
      CONST: [90],
      DATE: [90],
      DECLARE: [90],
      DEFBOOL: [90],
      DEFBYTE: [90],
      DEFDATE: [90],
      DEFDBL: [90],
      DEFDEC: [90],
      DEFCUR: [90],
      DEFINT: [90],
      DEFLNG: [90],
      DEFOBJ: [90],
      DEFSNG: [90],
      DEFSTR: [90],
      DEFVAR: [90],
      DIM: [90],
      DO: [90],
      DOUBLE: [90],
      EACH: [90],
      ELSE: [90],
      ELSEIF: [90],
      END_ENUM: [90],
      END_FUNCTION: [90],
      END_IF: [90],
      END_PROPERTY: [90],
      END_SELECT: [90],
      END_SUB: [90],
      END_TYPE: [90],
      END_WITH: [90],
      END: [90],
      ENUM: [90],
      EQV: [90],
      ERASE: [90],
      EVENT: [90],
      EXIT_DO: [90],
      EXIT_FOR: [90],
      EXIT_FUNCTION: [90],
      EXIT_PROPERTY: [90],
      EXIT_SUB: [90],
      FALSE: [90],
      FRIEND: [90],
      FOR: [90],
      FUNCTION: [90],
      GET: [90],
      GLOBAL: [90],
      GOSUB: [90],
      GOTO: [90],
      IF: [90],
      IMPLEMENTS: [90],
      IN: [90],
      ISNOT: [90],
      IS: [90],
      INTEGER: [90],
      LONG: [90],
      LOOP: [90],
      LEN: [90],
      LET: [90],
      LIB: [90],
      LIKE: [90],
      LSET: [90],
      MACRO_CONST: [90],
      MACRO_IF: [90],
      MACRO_ELSEIF: [90],
      MACRO_ELSE: [90],
      MACRO_END_IF: [90],
      MOD: [90],
      NEXT: [90],
      NEW: [90],
      NOT: [90],
      NOTHING: [90],
      NULL: [90],
      ON_ERROR: [90],
      ON_LOCAL_ERROR: [90],
      ON: [90],
      OPTIONAL: [90],
      OPTION_BASE: [90],
      OPTION_EXPLICIT: [90],
      OPTION_COMPARE: [90],
      OPTION_PRIVATE_MODULE: [90],
      OR: [90],
      PARAMARRAY: [90],
      PRESERVE: [90],
      PRIVATE: [90],
      PROPERTY_GET: [90],
      PROPERTY_LET: [90],
      PROPERTY_SET: [90],
      PTRSAFE: [90],
      PUBLIC: [90],
      RAISEEVENT: [90],
      REDIM: [90],
      RESET: [90],
      RESUME: [90],
      RETURN: [90],
      SELECT: [90],
      SET: [90],
      SINGLE: [90],
      STATIC: [90],
      STEP: [90],
      STOP: [90],
      STRING: [90],
      SUB: [90],
      THEN: [90],
      TO: [90],
      TRUE: [90],
      TYPEOF: [90],
      UNTIL: [90],
      VARIANT: [90],
      WEND: [90],
      WHILE: [90],
      WITH: [90],
      WITHEVENTS: [90],
      XOR: [90],
      IMP: [90],
      IDENTIFIER: [90],
      MINUS: [92],
    },
    onErrorStmt_group_def_22: {
      MINUS: [91],
    },
    onErrorStmt: {
      ON_ERROR: [93],
    },
    lineLabel: {
      ALIAS: [94],
      AND: [94],
      ATTRIBUTE: [94],
      AS: [94],
      BEGIN: [94],
      BOOLEAN: [94],
      BYVAL: [94],
      BYREF: [94],
      BYTE: [94],
      CALL: [94],
      CASE: [94],
      CONST: [94],
      DATE: [94],
      DECLARE: [94],
      DEFBOOL: [94],
      DEFBYTE: [94],
      DEFDATE: [94],
      DEFDBL: [94],
      DEFDEC: [94],
      DEFCUR: [94],
      DEFINT: [94],
      DEFLNG: [94],
      DEFOBJ: [94],
      DEFSNG: [94],
      DEFSTR: [94],
      DEFVAR: [94],
      DIM: [94],
      DO: [94],
      DOUBLE: [94],
      EACH: [94],
      ELSE: [94],
      ELSEIF: [94],
      END_ENUM: [94],
      END_FUNCTION: [94],
      END_IF: [94],
      END_PROPERTY: [94],
      END_SELECT: [94],
      END_SUB: [94],
      END_TYPE: [94],
      END_WITH: [94],
      END: [94],
      ENUM: [94],
      EQV: [94],
      ERASE: [94],
      EVENT: [94],
      EXIT_DO: [94],
      EXIT_FOR: [94],
      EXIT_FUNCTION: [94],
      EXIT_PROPERTY: [94],
      EXIT_SUB: [94],
      FALSE: [94],
      FRIEND: [94],
      FOR: [94],
      FUNCTION: [94],
      GET: [94],
      GLOBAL: [94],
      GOSUB: [94],
      GOTO: [94],
      IF: [94],
      IMPLEMENTS: [94],
      IN: [94],
      ISNOT: [94],
      IS: [94],
      INTEGER: [94],
      LONG: [94],
      LOOP: [94],
      LEN: [94],
      LET: [94],
      LIB: [94],
      LIKE: [94],
      LSET: [94],
      MACRO_CONST: [94],
      MACRO_IF: [94],
      MACRO_ELSEIF: [94],
      MACRO_ELSE: [94],
      MACRO_END_IF: [94],
      MOD: [94],
      NEXT: [94],
      NEW: [94],
      NOT: [94],
      NOTHING: [94],
      NULL: [94],
      ON_ERROR: [94],
      ON_LOCAL_ERROR: [94],
      ON: [94],
      OPTIONAL: [94],
      OPTION_BASE: [94],
      OPTION_EXPLICIT: [94],
      OPTION_COMPARE: [94],
      OPTION_PRIVATE_MODULE: [94],
      OR: [94],
      PARAMARRAY: [94],
      PRESERVE: [94],
      PRIVATE: [94],
      PROPERTY_GET: [94],
      PROPERTY_LET: [94],
      PROPERTY_SET: [94],
      PTRSAFE: [94],
      PUBLIC: [94],
      RAISEEVENT: [94],
      REDIM: [94],
      RESET: [94],
      RESUME: [94],
      RETURN: [94],
      SELECT: [94],
      SET: [94],
      SINGLE: [94],
      STATIC: [94],
      STEP: [94],
      STOP: [94],
      STRING: [94],
      SUB: [94],
      THEN: [94],
      TO: [94],
      TRUE: [94],
      TYPEOF: [94],
      UNTIL: [94],
      VARIANT: [94],
      WEND: [94],
      WHILE: [94],
      WITH: [94],
      WITHEVENTS: [94],
      XOR: [94],
      IMP: [94],
      IDENTIFIER: [94],
    },
    goToStmt: {
      GOTO: [95],
    },
    eraseStmt_group_def_24: {
      ',': [96],
    },
    eraseStmt: {
      ERASE: [97],
    },
    redimStmt_group_def_26: {
      ',': [98],
    },
    redimStmt: {
      REDIM: [99],
    },
    redimSubStmt: {
      SPACE_DOT: [100],
      ALIAS: [100],
      AND: [100],
      ATTRIBUTE: [100],
      AS: [100],
      BEGIN: [100],
      BOOLEAN: [100],
      BYVAL: [100],
      BYREF: [100],
      BYTE: [100],
      CALL: [100],
      CASE: [100],
      CONST: [100],
      DATE: [100],
      DECLARE: [100],
      DEFBOOL: [100],
      DEFBYTE: [100],
      DEFDATE: [100],
      DEFDBL: [100],
      DEFDEC: [100],
      DEFCUR: [100],
      DEFINT: [100],
      DEFLNG: [100],
      DEFOBJ: [100],
      DEFSNG: [100],
      DEFSTR: [100],
      DEFVAR: [100],
      DIM: [100],
      DO: [100],
      DOUBLE: [100],
      EACH: [100],
      ELSE: [100],
      ELSEIF: [100],
      END_ENUM: [100],
      END_FUNCTION: [100],
      END_IF: [100],
      END_PROPERTY: [100],
      END_SELECT: [100],
      END_SUB: [100],
      END_TYPE: [100],
      END_WITH: [100],
      END: [100],
      ENUM: [100],
      EQV: [100],
      ERASE: [100],
      EVENT: [100],
      EXIT_DO: [100],
      EXIT_FOR: [100],
      EXIT_FUNCTION: [100],
      EXIT_PROPERTY: [100],
      EXIT_SUB: [100],
      FALSE: [100],
      FRIEND: [100],
      FOR: [100],
      FUNCTION: [100],
      GET: [100],
      GLOBAL: [100],
      GOSUB: [100],
      GOTO: [100],
      IF: [100],
      IMPLEMENTS: [100],
      IN: [100],
      ISNOT: [100],
      IS: [100],
      INTEGER: [100],
      LONG: [100],
      LOOP: [100],
      LEN: [100],
      LET: [100],
      LIB: [100],
      LIKE: [100],
      LSET: [100],
      MACRO_CONST: [100],
      MACRO_IF: [100],
      MACRO_ELSEIF: [100],
      MACRO_ELSE: [100],
      MACRO_END_IF: [100],
      MOD: [100],
      NEXT: [100],
      NEW: [100],
      NOT: [100],
      NOTHING: [100],
      NULL: [100],
      ON_ERROR: [100],
      ON_LOCAL_ERROR: [100],
      ON: [100],
      OPTIONAL: [100],
      OPTION_BASE: [100],
      OPTION_EXPLICIT: [100],
      OPTION_COMPARE: [100],
      OPTION_PRIVATE_MODULE: [100],
      OR: [100],
      PARAMARRAY: [100],
      PRESERVE: [100],
      PRIVATE: [100],
      PROPERTY_GET: [100],
      PROPERTY_LET: [100],
      PROPERTY_SET: [100],
      PTRSAFE: [100],
      PUBLIC: [100],
      RAISEEVENT: [100],
      REDIM: [100],
      RESET: [100],
      RESUME: [100],
      RETURN: [100],
      SELECT: [100],
      SET: [100],
      SINGLE: [100],
      STATIC: [100],
      STEP: [100],
      STOP: [100],
      STRING: [100],
      SUB: [100],
      THEN: [100],
      TO: [100],
      TRUE: [100],
      TYPEOF: [100],
      UNTIL: [100],
      VARIANT: [100],
      WEND: [100],
      WHILE: [100],
      WITH: [100],
      WITHEVENTS: [100],
      XOR: [100],
      IMP: [100],
      IDENTIFIER: [100],
    },
    exitStmt: {
      EXIT_DO: [101],
      EXIT_FOR: [102],
      EXIT_FUNCTION: [103],
      EXIT_PROPERTY: [104],
      EXIT_SUB: [105],
      END: [106],
    },
    letStmt_group_def_28: {
      EQ: [107],
    },
    letStmt_group_27: {
      EQ: [108],
      PLUS_EQ: [110],
      MINUS_EQ: [112],
    },
    letStmt_group_def_29: {
      PLUS_EQ: [109],
    },
    letStmt_group_def_30: {
      MINUS_EQ: [111],
    },
    letStmt: {
      LET: [113],
      SPACE_DOT: [113],
      ALIAS: [113],
      AND: [113],
      ATTRIBUTE: [113],
      AS: [113],
      BEGIN: [113],
      BOOLEAN: [113],
      BYVAL: [113],
      BYREF: [113],
      BYTE: [113],
      CALL: [113],
      CASE: [113],
      CONST: [113],
      DATE: [113],
      DECLARE: [113],
      DEFBOOL: [113],
      DEFBYTE: [113],
      DEFDATE: [113],
      DEFDBL: [113],
      DEFDEC: [113],
      DEFCUR: [113],
      DEFINT: [113],
      DEFLNG: [113],
      DEFOBJ: [113],
      DEFSNG: [113],
      DEFSTR: [113],
      DEFVAR: [113],
      DIM: [113],
      DO: [113],
      DOUBLE: [113],
      EACH: [113],
      ELSE: [113],
      ELSEIF: [113],
      END_ENUM: [113],
      END_FUNCTION: [113],
      END_IF: [113],
      END_PROPERTY: [113],
      END_SELECT: [113],
      END_SUB: [113],
      END_TYPE: [113],
      END_WITH: [113],
      END: [113],
      ENUM: [113],
      EQV: [113],
      ERASE: [113],
      EVENT: [113],
      EXIT_DO: [113],
      EXIT_FOR: [113],
      EXIT_FUNCTION: [113],
      EXIT_PROPERTY: [113],
      EXIT_SUB: [113],
      FALSE: [113],
      FRIEND: [113],
      FOR: [113],
      FUNCTION: [113],
      GET: [113],
      GLOBAL: [113],
      GOSUB: [113],
      GOTO: [113],
      IF: [113],
      IMPLEMENTS: [113],
      IN: [113],
      ISNOT: [113],
      IS: [113],
      INTEGER: [113],
      LONG: [113],
      LOOP: [113],
      LEN: [113],
      LIB: [113],
      LIKE: [113],
      LSET: [113],
      MACRO_CONST: [113],
      MACRO_IF: [113],
      MACRO_ELSEIF: [113],
      MACRO_ELSE: [113],
      MACRO_END_IF: [113],
      MOD: [113],
      NEXT: [113],
      NEW: [113],
      NOT: [113],
      NOTHING: [113],
      NULL: [113],
      ON_ERROR: [113],
      ON_LOCAL_ERROR: [113],
      ON: [113],
      OPTIONAL: [113],
      OPTION_BASE: [113],
      OPTION_EXPLICIT: [113],
      OPTION_COMPARE: [113],
      OPTION_PRIVATE_MODULE: [113],
      OR: [113],
      PARAMARRAY: [113],
      PRESERVE: [113],
      PRIVATE: [113],
      PROPERTY_GET: [113],
      PROPERTY_LET: [113],
      PROPERTY_SET: [113],
      PTRSAFE: [113],
      PUBLIC: [113],
      RAISEEVENT: [113],
      REDIM: [113],
      RESET: [113],
      RESUME: [113],
      RETURN: [113],
      SELECT: [113],
      SET: [113],
      SINGLE: [113],
      STATIC: [113],
      STEP: [113],
      STOP: [113],
      STRING: [113],
      SUB: [113],
      THEN: [113],
      TO: [113],
      TRUE: [113],
      TYPEOF: [113],
      UNTIL: [113],
      VARIANT: [113],
      WEND: [113],
      WHILE: [113],
      WITH: [113],
      WITHEVENTS: [113],
      XOR: [113],
      IMP: [113],
      IDENTIFIER: [113],
    },
    setStmt: {
      SET: [114],
    },
    explicitCallStmt: {
      CALL: [115, 116],
    },
    eCS_MemberProcedureCall_group_def_32: {
      SPACE_DOT: [117],
      ALIAS: [117],
      AND: [117],
      ATTRIBUTE: [117],
      AS: [117],
      BEGIN: [117],
      BOOLEAN: [117],
      BYVAL: [117],
      BYREF: [117],
      BYTE: [117],
      CALL: [117],
      CASE: [117],
      CONST: [117],
      DATE: [117],
      DECLARE: [117],
      DEFBOOL: [117],
      DEFBYTE: [117],
      DEFDATE: [117],
      DEFDBL: [117],
      DEFDEC: [117],
      DEFCUR: [117],
      DEFINT: [117],
      DEFLNG: [117],
      DEFOBJ: [117],
      DEFSNG: [117],
      DEFSTR: [117],
      DEFVAR: [117],
      DIM: [117],
      DO: [117],
      DOUBLE: [117],
      EACH: [117],
      ELSE: [117],
      ELSEIF: [117],
      END_ENUM: [117],
      END_FUNCTION: [117],
      END_IF: [117],
      END_PROPERTY: [117],
      END_SELECT: [117],
      END_SUB: [117],
      END_TYPE: [117],
      END_WITH: [117],
      END: [117],
      ENUM: [117],
      EQV: [117],
      ERASE: [117],
      EVENT: [117],
      EXIT_DO: [117],
      EXIT_FOR: [117],
      EXIT_FUNCTION: [117],
      EXIT_PROPERTY: [117],
      EXIT_SUB: [117],
      FALSE: [117],
      FRIEND: [117],
      FOR: [117],
      FUNCTION: [117],
      GET: [117],
      GLOBAL: [117],
      GOSUB: [117],
      GOTO: [117],
      IF: [117],
      IMPLEMENTS: [117],
      IN: [117],
      ISNOT: [117],
      IS: [117],
      INTEGER: [117],
      LONG: [117],
      LOOP: [117],
      LEN: [117],
      LET: [117],
      LIB: [117],
      LIKE: [117],
      LSET: [117],
      MACRO_CONST: [117],
      MACRO_IF: [117],
      MACRO_ELSEIF: [117],
      MACRO_ELSE: [117],
      MACRO_END_IF: [117],
      MOD: [117],
      NEXT: [117],
      NEW: [117],
      NOT: [117],
      NOTHING: [117],
      NULL: [117],
      ON_ERROR: [117],
      ON_LOCAL_ERROR: [117],
      ON: [117],
      OPTIONAL: [117],
      OPTION_BASE: [117],
      OPTION_EXPLICIT: [117],
      OPTION_COMPARE: [117],
      OPTION_PRIVATE_MODULE: [117],
      OR: [117],
      PARAMARRAY: [117],
      PRESERVE: [117],
      PRIVATE: [117],
      PROPERTY_GET: [117],
      PROPERTY_LET: [117],
      PROPERTY_SET: [117],
      PTRSAFE: [117],
      PUBLIC: [117],
      RAISEEVENT: [117],
      REDIM: [117],
      RESET: [117],
      RESUME: [117],
      RETURN: [117],
      SELECT: [117],
      SET: [117],
      SINGLE: [117],
      STATIC: [117],
      STEP: [117],
      STOP: [117],
      STRING: [117],
      SUB: [117],
      THEN: [117],
      TO: [117],
      TRUE: [117],
      TYPEOF: [117],
      UNTIL: [117],
      VARIANT: [117],
      WEND: [117],
      WHILE: [117],
      WITH: [117],
      WITHEVENTS: [117],
      XOR: [117],
      IMP: [117],
      IDENTIFIER: [117],
      '.': [117],
    },
    eCS_MemberProcedureCall_group_31: {
      SPACE_DOT: [118, 120],
      ALIAS: [118],
      AND: [118],
      ATTRIBUTE: [118],
      AS: [118],
      BEGIN: [118],
      BOOLEAN: [118],
      BYVAL: [118],
      BYREF: [118],
      BYTE: [118],
      CALL: [118],
      CASE: [118],
      CONST: [118],
      DATE: [118],
      DECLARE: [118],
      DEFBOOL: [118],
      DEFBYTE: [118],
      DEFDATE: [118],
      DEFDBL: [118],
      DEFDEC: [118],
      DEFCUR: [118],
      DEFINT: [118],
      DEFLNG: [118],
      DEFOBJ: [118],
      DEFSNG: [118],
      DEFSTR: [118],
      DEFVAR: [118],
      DIM: [118],
      DO: [118],
      DOUBLE: [118],
      EACH: [118],
      ELSE: [118],
      ELSEIF: [118],
      END_ENUM: [118],
      END_FUNCTION: [118],
      END_IF: [118],
      END_PROPERTY: [118],
      END_SELECT: [118],
      END_SUB: [118],
      END_TYPE: [118],
      END_WITH: [118],
      END: [118],
      ENUM: [118],
      EQV: [118],
      ERASE: [118],
      EVENT: [118],
      EXIT_DO: [118],
      EXIT_FOR: [118],
      EXIT_FUNCTION: [118],
      EXIT_PROPERTY: [118],
      EXIT_SUB: [118],
      FALSE: [118],
      FRIEND: [118],
      FOR: [118],
      FUNCTION: [118],
      GET: [118],
      GLOBAL: [118],
      GOSUB: [118],
      GOTO: [118],
      IF: [118],
      IMPLEMENTS: [118],
      IN: [118],
      ISNOT: [118],
      IS: [118],
      INTEGER: [118],
      LONG: [118],
      LOOP: [118],
      LEN: [118],
      LET: [118],
      LIB: [118],
      LIKE: [118],
      LSET: [118],
      MACRO_CONST: [118],
      MACRO_IF: [118],
      MACRO_ELSEIF: [118],
      MACRO_ELSE: [118],
      MACRO_END_IF: [118],
      MOD: [118],
      NEXT: [118],
      NEW: [118],
      NOT: [118],
      NOTHING: [118],
      NULL: [118],
      ON_ERROR: [118],
      ON_LOCAL_ERROR: [118],
      ON: [118],
      OPTIONAL: [118],
      OPTION_BASE: [118],
      OPTION_EXPLICIT: [118],
      OPTION_COMPARE: [118],
      OPTION_PRIVATE_MODULE: [118],
      OR: [118],
      PARAMARRAY: [118],
      PRESERVE: [118],
      PRIVATE: [118],
      PROPERTY_GET: [118],
      PROPERTY_LET: [118],
      PROPERTY_SET: [118],
      PTRSAFE: [118],
      PUBLIC: [118],
      RAISEEVENT: [118],
      REDIM: [118],
      RESET: [118],
      RESUME: [118],
      RETURN: [118],
      SELECT: [118],
      SET: [118],
      SINGLE: [118],
      STATIC: [118],
      STEP: [118],
      STOP: [118],
      STRING: [118],
      SUB: [118],
      THEN: [118],
      TO: [118],
      TRUE: [118],
      TYPEOF: [118],
      UNTIL: [118],
      VARIANT: [118],
      WEND: [118],
      WHILE: [118],
      WITH: [118],
      WITHEVENTS: [118],
      XOR: [118],
      IMP: [118],
      IDENTIFIER: [118],
      '.': [118],
    },
    eCS_MemberProcedureCall_group_def_33: {
      SPACE_DOT: [119],
    },
    eCS_MemberProcedureCall_group_def_35: {
      LPAREN: [121],
    },
    eCS_MemberProcedureCall_group_def_37: {
      LPAREN: [122],
    },
    eCS_MemberProcedureCall: {
      CALL: [123],
    },
    eCS_ProcedureCall: {
      CALL: [124],
    },
    implicitCallStmt_InBlock: {
      SPACE_DOT: [125],
      ALIAS: [125],
      AND: [125],
      ATTRIBUTE: [125],
      AS: [125],
      BEGIN: [125],
      BOOLEAN: [125],
      BYVAL: [125],
      BYREF: [125],
      BYTE: [125],
      CALL: [125],
      CASE: [125],
      CONST: [125],
      DATE: [125],
      DECLARE: [125],
      DEFBOOL: [125],
      DEFBYTE: [125],
      DEFDATE: [125],
      DEFDBL: [125],
      DEFDEC: [125],
      DEFCUR: [125],
      DEFINT: [125],
      DEFLNG: [125],
      DEFOBJ: [125],
      DEFSNG: [125],
      DEFSTR: [125],
      DEFVAR: [125],
      DIM: [125],
      DO: [125],
      DOUBLE: [125],
      EACH: [125],
      ELSE: [125],
      ELSEIF: [125],
      END_ENUM: [125],
      END_FUNCTION: [125],
      END_IF: [125],
      END_PROPERTY: [125],
      END_SELECT: [125],
      END_SUB: [125],
      END_TYPE: [125],
      END_WITH: [125],
      END: [125],
      ENUM: [125],
      EQV: [125],
      ERASE: [125],
      EVENT: [125],
      EXIT_DO: [125],
      EXIT_FOR: [125],
      EXIT_FUNCTION: [125],
      EXIT_PROPERTY: [125],
      EXIT_SUB: [125],
      FALSE: [125],
      FRIEND: [125],
      FOR: [125],
      FUNCTION: [125],
      GET: [125],
      GLOBAL: [125],
      GOSUB: [125],
      GOTO: [125],
      IF: [125],
      IMPLEMENTS: [125],
      IN: [125],
      ISNOT: [125],
      IS: [125],
      INTEGER: [125],
      LONG: [125],
      LOOP: [125],
      LEN: [125],
      LET: [125],
      LIB: [125],
      LIKE: [125],
      LSET: [125],
      MACRO_CONST: [125],
      MACRO_IF: [125],
      MACRO_ELSEIF: [125],
      MACRO_ELSE: [125],
      MACRO_END_IF: [125],
      MOD: [125],
      NEXT: [125],
      NEW: [125],
      NOT: [125],
      NOTHING: [125],
      NULL: [125],
      ON_ERROR: [125],
      ON_LOCAL_ERROR: [125],
      ON: [125],
      OPTIONAL: [125],
      OPTION_BASE: [125],
      OPTION_EXPLICIT: [125],
      OPTION_COMPARE: [125],
      OPTION_PRIVATE_MODULE: [125],
      OR: [125],
      PARAMARRAY: [125],
      PRESERVE: [125],
      PRIVATE: [125],
      PROPERTY_GET: [125],
      PROPERTY_LET: [125],
      PROPERTY_SET: [125],
      PTRSAFE: [125],
      PUBLIC: [125],
      RAISEEVENT: [125],
      REDIM: [125],
      RESET: [125],
      RESUME: [125],
      RETURN: [125],
      SELECT: [125],
      SET: [125],
      SINGLE: [125],
      STATIC: [125],
      STEP: [125],
      STOP: [125],
      STRING: [125],
      SUB: [125],
      THEN: [125],
      TO: [125],
      TRUE: [125],
      TYPEOF: [125],
      UNTIL: [125],
      VARIANT: [125],
      WEND: [125],
      WHILE: [125],
      WITH: [125],
      WITHEVENTS: [125],
      XOR: [125],
      IMP: [125],
      IDENTIFIER: [125, 126],
    },
    iCS_B_MemberProcedureCall: {
      SPACE_DOT: [127],
      ALIAS: [127],
      AND: [127],
      ATTRIBUTE: [127],
      AS: [127],
      BEGIN: [127],
      BOOLEAN: [127],
      BYVAL: [127],
      BYREF: [127],
      BYTE: [127],
      CALL: [127],
      CASE: [127],
      CONST: [127],
      DATE: [127],
      DECLARE: [127],
      DEFBOOL: [127],
      DEFBYTE: [127],
      DEFDATE: [127],
      DEFDBL: [127],
      DEFDEC: [127],
      DEFCUR: [127],
      DEFINT: [127],
      DEFLNG: [127],
      DEFOBJ: [127],
      DEFSNG: [127],
      DEFSTR: [127],
      DEFVAR: [127],
      DIM: [127],
      DO: [127],
      DOUBLE: [127],
      EACH: [127],
      ELSE: [127],
      ELSEIF: [127],
      END_ENUM: [127],
      END_FUNCTION: [127],
      END_IF: [127],
      END_PROPERTY: [127],
      END_SELECT: [127],
      END_SUB: [127],
      END_TYPE: [127],
      END_WITH: [127],
      END: [127],
      ENUM: [127],
      EQV: [127],
      ERASE: [127],
      EVENT: [127],
      EXIT_DO: [127],
      EXIT_FOR: [127],
      EXIT_FUNCTION: [127],
      EXIT_PROPERTY: [127],
      EXIT_SUB: [127],
      FALSE: [127],
      FRIEND: [127],
      FOR: [127],
      FUNCTION: [127],
      GET: [127],
      GLOBAL: [127],
      GOSUB: [127],
      GOTO: [127],
      IF: [127],
      IMPLEMENTS: [127],
      IN: [127],
      ISNOT: [127],
      IS: [127],
      INTEGER: [127],
      LONG: [127],
      LOOP: [127],
      LEN: [127],
      LET: [127],
      LIB: [127],
      LIKE: [127],
      LSET: [127],
      MACRO_CONST: [127],
      MACRO_IF: [127],
      MACRO_ELSEIF: [127],
      MACRO_ELSE: [127],
      MACRO_END_IF: [127],
      MOD: [127],
      NEXT: [127],
      NEW: [127],
      NOT: [127],
      NOTHING: [127],
      NULL: [127],
      ON_ERROR: [127],
      ON_LOCAL_ERROR: [127],
      ON: [127],
      OPTIONAL: [127],
      OPTION_BASE: [127],
      OPTION_EXPLICIT: [127],
      OPTION_COMPARE: [127],
      OPTION_PRIVATE_MODULE: [127],
      OR: [127],
      PARAMARRAY: [127],
      PRESERVE: [127],
      PRIVATE: [127],
      PROPERTY_GET: [127],
      PROPERTY_LET: [127],
      PROPERTY_SET: [127],
      PTRSAFE: [127],
      PUBLIC: [127],
      RAISEEVENT: [127],
      REDIM: [127],
      RESET: [127],
      RESUME: [127],
      RETURN: [127],
      SELECT: [127],
      SET: [127],
      SINGLE: [127],
      STATIC: [127],
      STEP: [127],
      STOP: [127],
      STRING: [127],
      SUB: [127],
      THEN: [127],
      TO: [127],
      TRUE: [127],
      TYPEOF: [127],
      UNTIL: [127],
      VARIANT: [127],
      WEND: [127],
      WHILE: [127],
      WITH: [127],
      WITHEVENTS: [127],
      XOR: [127],
      IMP: [127],
      IDENTIFIER: [127],
    },
    iCS_B_ProcedureCall: {
      IDENTIFIER: [128],
    },
    argsCall_group_def_43: {
      ',': [129],
    },
    argsCall: {
      ',': [130],
      DOUBLELITERAL: [130],
      INTEGERLITERAL: [130],
      STRINGLITERAL: [130],
      NOTHING: [130],
      NULL: [130],
      TRUE: [130],
      FALSE: [130],
      DATELITERAL: [130],
      SPACE_DOT: [130],
      ALIAS: [130],
      AND: [130],
      ATTRIBUTE: [130],
      AS: [130],
      BEGIN: [130],
      BOOLEAN: [130],
      BYVAL: [130],
      BYREF: [130],
      BYTE: [130],
      CALL: [130],
      CASE: [130],
      CONST: [130],
      DATE: [130],
      DECLARE: [130],
      DEFBOOL: [130],
      DEFBYTE: [130],
      DEFDATE: [130],
      DEFDBL: [130],
      DEFDEC: [130],
      DEFCUR: [130],
      DEFINT: [130],
      DEFLNG: [130],
      DEFOBJ: [130],
      DEFSNG: [130],
      DEFSTR: [130],
      DEFVAR: [130],
      DIM: [130],
      DO: [130],
      DOUBLE: [130],
      EACH: [130],
      ELSE: [130],
      ELSEIF: [130],
      END_ENUM: [130],
      END_FUNCTION: [130],
      END_IF: [130],
      END_PROPERTY: [130],
      END_SELECT: [130],
      END_SUB: [130],
      END_TYPE: [130],
      END_WITH: [130],
      END: [130],
      ENUM: [130],
      EQV: [130],
      ERASE: [130],
      EVENT: [130],
      EXIT_DO: [130],
      EXIT_FOR: [130],
      EXIT_FUNCTION: [130],
      EXIT_PROPERTY: [130],
      EXIT_SUB: [130],
      FRIEND: [130],
      FOR: [130],
      FUNCTION: [130],
      GET: [130],
      GLOBAL: [130],
      GOSUB: [130],
      GOTO: [130],
      IF: [130],
      IMPLEMENTS: [130],
      IN: [130],
      ISNOT: [130],
      IS: [130],
      INTEGER: [130],
      LONG: [130],
      LOOP: [130],
      LEN: [130],
      LET: [130],
      LIB: [130],
      LIKE: [130],
      LSET: [130],
      MACRO_CONST: [130],
      MACRO_IF: [130],
      MACRO_ELSEIF: [130],
      MACRO_ELSE: [130],
      MACRO_END_IF: [130],
      MOD: [130],
      NEXT: [130],
      NEW: [130],
      NOT: [130],
      ON_ERROR: [130],
      ON_LOCAL_ERROR: [130],
      ON: [130],
      OPTIONAL: [130],
      OPTION_BASE: [130],
      OPTION_EXPLICIT: [130],
      OPTION_COMPARE: [130],
      OPTION_PRIVATE_MODULE: [130],
      OR: [130],
      PARAMARRAY: [130],
      PRESERVE: [130],
      PRIVATE: [130],
      PROPERTY_GET: [130],
      PROPERTY_LET: [130],
      PROPERTY_SET: [130],
      PTRSAFE: [130],
      PUBLIC: [130],
      RAISEEVENT: [130],
      REDIM: [130],
      RESET: [130],
      RESUME: [130],
      RETURN: [130],
      SELECT: [130],
      SET: [130],
      SINGLE: [130],
      STATIC: [130],
      STEP: [130],
      STOP: [130],
      STRING: [130],
      SUB: [130],
      THEN: [130],
      TO: [130],
      TYPEOF: [130],
      UNTIL: [130],
      VARIANT: [130],
      WEND: [130],
      WHILE: [130],
      WITH: [130],
      WITHEVENTS: [130],
      XOR: [130],
      IMP: [130],
      IDENTIFIER: [130],
      LPAREN: [130],
      MINUS: [130],
      PLUS: [130],
    },
    argCall: {
      DOUBLELITERAL: [131],
      INTEGERLITERAL: [131],
      STRINGLITERAL: [131],
      NOTHING: [131],
      NULL: [131],
      TRUE: [131],
      FALSE: [131],
      DATELITERAL: [131],
      SPACE_DOT: [131],
      ALIAS: [131],
      AND: [131],
      ATTRIBUTE: [131],
      AS: [131],
      BEGIN: [131],
      BOOLEAN: [131],
      BYVAL: [131],
      BYREF: [131],
      BYTE: [131],
      CALL: [131],
      CASE: [131],
      CONST: [131],
      DATE: [131],
      DECLARE: [131],
      DEFBOOL: [131],
      DEFBYTE: [131],
      DEFDATE: [131],
      DEFDBL: [131],
      DEFDEC: [131],
      DEFCUR: [131],
      DEFINT: [131],
      DEFLNG: [131],
      DEFOBJ: [131],
      DEFSNG: [131],
      DEFSTR: [131],
      DEFVAR: [131],
      DIM: [131],
      DO: [131],
      DOUBLE: [131],
      EACH: [131],
      ELSE: [131],
      ELSEIF: [131],
      END_ENUM: [131],
      END_FUNCTION: [131],
      END_IF: [131],
      END_PROPERTY: [131],
      END_SELECT: [131],
      END_SUB: [131],
      END_TYPE: [131],
      END_WITH: [131],
      END: [131],
      ENUM: [131],
      EQV: [131],
      ERASE: [131],
      EVENT: [131],
      EXIT_DO: [131],
      EXIT_FOR: [131],
      EXIT_FUNCTION: [131],
      EXIT_PROPERTY: [131],
      EXIT_SUB: [131],
      FRIEND: [131],
      FOR: [131],
      FUNCTION: [131],
      GET: [131],
      GLOBAL: [131],
      GOSUB: [131],
      GOTO: [131],
      IF: [131],
      IMPLEMENTS: [131],
      IN: [131],
      ISNOT: [131],
      IS: [131],
      INTEGER: [131],
      LONG: [131],
      LOOP: [131],
      LEN: [131],
      LET: [131],
      LIB: [131],
      LIKE: [131],
      LSET: [131],
      MACRO_CONST: [131],
      MACRO_IF: [131],
      MACRO_ELSEIF: [131],
      MACRO_ELSE: [131],
      MACRO_END_IF: [131],
      MOD: [131],
      NEXT: [131],
      NEW: [131],
      NOT: [131],
      ON_ERROR: [131],
      ON_LOCAL_ERROR: [131],
      ON: [131],
      OPTIONAL: [131],
      OPTION_BASE: [131],
      OPTION_EXPLICIT: [131],
      OPTION_COMPARE: [131],
      OPTION_PRIVATE_MODULE: [131],
      OR: [131],
      PARAMARRAY: [131],
      PRESERVE: [131],
      PRIVATE: [131],
      PROPERTY_GET: [131],
      PROPERTY_LET: [131],
      PROPERTY_SET: [131],
      PTRSAFE: [131],
      PUBLIC: [131],
      RAISEEVENT: [131],
      REDIM: [131],
      RESET: [131],
      RESUME: [131],
      RETURN: [131],
      SELECT: [131],
      SET: [131],
      SINGLE: [131],
      STATIC: [131],
      STEP: [131],
      STOP: [131],
      STRING: [131],
      SUB: [131],
      THEN: [131],
      TO: [131],
      TYPEOF: [131],
      UNTIL: [131],
      VARIANT: [131],
      WEND: [131],
      WHILE: [131],
      WITH: [131],
      WITHEVENTS: [131],
      XOR: [131],
      IMP: [131],
      IDENTIFIER: [131],
      LPAREN: [131],
      MINUS: [131],
      PLUS: [131],
    },
    variableStmt_group_def_45: {
      DIM: [132],
    },
    variableStmt_group_44: {
      DIM: [133],
      STATIC: [135],
      PRIVATE: [137],
      PUBLIC: [137],
      FRIEND: [137],
      GLOBAL: [137],
    },
    variableStmt_group_def_46: {
      STATIC: [134],
    },
    variableStmt_group_def_47: {
      PRIVATE: [136],
      PUBLIC: [136],
      FRIEND: [136],
      GLOBAL: [136],
    },
    variableStmt: {
      DIM: [138],
      STATIC: [138],
      PRIVATE: [138],
      PUBLIC: [138],
      FRIEND: [138],
      GLOBAL: [138],
    },
    withStmt_group_def_49: {
      SPACE_DOT: [139],
      ALIAS: [139],
      AND: [139],
      ATTRIBUTE: [139],
      AS: [139],
      BEGIN: [139],
      BOOLEAN: [139],
      BYVAL: [139],
      BYREF: [139],
      BYTE: [139],
      CALL: [139],
      CASE: [139],
      CONST: [139],
      DATE: [139],
      DECLARE: [139],
      DEFBOOL: [139],
      DEFBYTE: [139],
      DEFDATE: [139],
      DEFDBL: [139],
      DEFDEC: [139],
      DEFCUR: [139],
      DEFINT: [139],
      DEFLNG: [139],
      DEFOBJ: [139],
      DEFSNG: [139],
      DEFSTR: [139],
      DEFVAR: [139],
      DIM: [139],
      DO: [139],
      DOUBLE: [139],
      EACH: [139],
      ELSE: [139],
      ELSEIF: [139],
      END_ENUM: [139],
      END_FUNCTION: [139],
      END_IF: [139],
      END_PROPERTY: [139],
      END_SELECT: [139],
      END_SUB: [139],
      END_TYPE: [139],
      END_WITH: [139],
      END: [139],
      ENUM: [139],
      EQV: [139],
      ERASE: [139],
      EVENT: [139],
      EXIT_DO: [139],
      EXIT_FOR: [139],
      EXIT_FUNCTION: [139],
      EXIT_PROPERTY: [139],
      EXIT_SUB: [139],
      FALSE: [139],
      FRIEND: [139],
      FOR: [139],
      FUNCTION: [139],
      GET: [139],
      GLOBAL: [139],
      GOSUB: [139],
      GOTO: [139],
      IF: [139],
      IMPLEMENTS: [139],
      IN: [139],
      ISNOT: [139],
      IS: [139],
      INTEGER: [139],
      LONG: [139],
      LOOP: [139],
      LEN: [139],
      LET: [139],
      LIB: [139],
      LIKE: [139],
      LSET: [139],
      MACRO_CONST: [139],
      MACRO_IF: [139],
      MACRO_ELSEIF: [139],
      MACRO_ELSE: [139],
      MACRO_END_IF: [139],
      MOD: [139],
      NEXT: [139],
      NEW: [139],
      NOT: [139],
      NOTHING: [139],
      NULL: [139],
      ON_ERROR: [139],
      ON_LOCAL_ERROR: [139],
      ON: [139],
      OPTIONAL: [139],
      OPTION_BASE: [139],
      OPTION_EXPLICIT: [139],
      OPTION_COMPARE: [139],
      OPTION_PRIVATE_MODULE: [139],
      OR: [139],
      PARAMARRAY: [139],
      PRESERVE: [139],
      PRIVATE: [139],
      PROPERTY_GET: [139],
      PROPERTY_LET: [139],
      PROPERTY_SET: [139],
      PTRSAFE: [139],
      PUBLIC: [139],
      RAISEEVENT: [139],
      REDIM: [139],
      RESET: [139],
      RESUME: [139],
      RETURN: [139],
      SELECT: [139],
      SET: [139],
      SINGLE: [139],
      STATIC: [139],
      STEP: [139],
      STOP: [139],
      STRING: [139],
      SUB: [139],
      THEN: [139],
      TO: [139],
      TRUE: [139],
      TYPEOF: [139],
      UNTIL: [139],
      VARIANT: [139],
      WEND: [139],
      WHILE: [139],
      WITH: [139],
      WITHEVENTS: [139],
      XOR: [139],
      IMP: [139],
      IDENTIFIER: [139],
    },
    withStmt_group_48: {
      SPACE_DOT: [140],
      ALIAS: [140],
      AND: [140],
      ATTRIBUTE: [140],
      AS: [140],
      BEGIN: [140],
      BOOLEAN: [140],
      BYVAL: [140],
      BYREF: [140],
      BYTE: [140],
      CALL: [140],
      CASE: [140],
      CONST: [140],
      DATE: [140],
      DECLARE: [140],
      DEFBOOL: [140],
      DEFBYTE: [140],
      DEFDATE: [140],
      DEFDBL: [140],
      DEFDEC: [140],
      DEFCUR: [140],
      DEFINT: [140],
      DEFLNG: [140],
      DEFOBJ: [140],
      DEFSNG: [140],
      DEFSTR: [140],
      DEFVAR: [140],
      DIM: [140],
      DO: [140],
      DOUBLE: [140],
      EACH: [140],
      ELSE: [140],
      ELSEIF: [140],
      END_ENUM: [140],
      END_FUNCTION: [140],
      END_IF: [140],
      END_PROPERTY: [140],
      END_SELECT: [140],
      END_SUB: [140],
      END_TYPE: [140],
      END_WITH: [140],
      END: [140],
      ENUM: [140],
      EQV: [140],
      ERASE: [140],
      EVENT: [140],
      EXIT_DO: [140],
      EXIT_FOR: [140],
      EXIT_FUNCTION: [140],
      EXIT_PROPERTY: [140],
      EXIT_SUB: [140],
      FALSE: [140],
      FRIEND: [140],
      FOR: [140],
      FUNCTION: [140],
      GET: [140],
      GLOBAL: [140],
      GOSUB: [140],
      GOTO: [140],
      IF: [140],
      IMPLEMENTS: [140],
      IN: [140],
      ISNOT: [140],
      IS: [140],
      INTEGER: [140],
      LONG: [140],
      LOOP: [140],
      LEN: [140],
      LET: [140],
      LIB: [140],
      LIKE: [140],
      LSET: [140],
      MACRO_CONST: [140],
      MACRO_IF: [140],
      MACRO_ELSEIF: [140],
      MACRO_ELSE: [140],
      MACRO_END_IF: [140],
      MOD: [140],
      NEXT: [140],
      NEW: [140, 142],
      NOT: [140],
      NOTHING: [140],
      NULL: [140],
      ON_ERROR: [140],
      ON_LOCAL_ERROR: [140],
      ON: [140],
      OPTIONAL: [140],
      OPTION_BASE: [140],
      OPTION_EXPLICIT: [140],
      OPTION_COMPARE: [140],
      OPTION_PRIVATE_MODULE: [140],
      OR: [140],
      PARAMARRAY: [140],
      PRESERVE: [140],
      PRIVATE: [140],
      PROPERTY_GET: [140],
      PROPERTY_LET: [140],
      PROPERTY_SET: [140],
      PTRSAFE: [140],
      PUBLIC: [140],
      RAISEEVENT: [140],
      REDIM: [140],
      RESET: [140],
      RESUME: [140],
      RETURN: [140],
      SELECT: [140],
      SET: [140],
      SINGLE: [140],
      STATIC: [140],
      STEP: [140],
      STOP: [140],
      STRING: [140],
      SUB: [140],
      THEN: [140],
      TO: [140],
      TRUE: [140],
      TYPEOF: [140],
      UNTIL: [140],
      VARIANT: [140],
      WEND: [140],
      WHILE: [140],
      WITH: [140],
      WITHEVENTS: [140],
      XOR: [140],
      IMP: [140],
      IDENTIFIER: [140],
    },
    withStmt_group_def_50: {
      NEW: [141],
    },
    withStmt: {
      WITH: [143],
    },
    variableListStmt_group_def_52: {
      ',': [144],
    },
    variableListStmt: {
      ALIAS: [145],
      AND: [145],
      ATTRIBUTE: [145],
      AS: [145],
      BEGIN: [145],
      BOOLEAN: [145],
      BYVAL: [145],
      BYREF: [145],
      BYTE: [145],
      CALL: [145],
      CASE: [145],
      CONST: [145],
      DATE: [145],
      DECLARE: [145],
      DEFBOOL: [145],
      DEFBYTE: [145],
      DEFDATE: [145],
      DEFDBL: [145],
      DEFDEC: [145],
      DEFCUR: [145],
      DEFINT: [145],
      DEFLNG: [145],
      DEFOBJ: [145],
      DEFSNG: [145],
      DEFSTR: [145],
      DEFVAR: [145],
      DIM: [145],
      DO: [145],
      DOUBLE: [145],
      EACH: [145],
      ELSE: [145],
      ELSEIF: [145],
      END_ENUM: [145],
      END_FUNCTION: [145],
      END_IF: [145],
      END_PROPERTY: [145],
      END_SELECT: [145],
      END_SUB: [145],
      END_TYPE: [145],
      END_WITH: [145],
      END: [145],
      ENUM: [145],
      EQV: [145],
      ERASE: [145],
      EVENT: [145],
      EXIT_DO: [145],
      EXIT_FOR: [145],
      EXIT_FUNCTION: [145],
      EXIT_PROPERTY: [145],
      EXIT_SUB: [145],
      FALSE: [145],
      FRIEND: [145],
      FOR: [145],
      FUNCTION: [145],
      GET: [145],
      GLOBAL: [145],
      GOSUB: [145],
      GOTO: [145],
      IF: [145],
      IMPLEMENTS: [145],
      IN: [145],
      ISNOT: [145],
      IS: [145],
      INTEGER: [145],
      LONG: [145],
      LOOP: [145],
      LEN: [145],
      LET: [145],
      LIB: [145],
      LIKE: [145],
      LSET: [145],
      MACRO_CONST: [145],
      MACRO_IF: [145],
      MACRO_ELSEIF: [145],
      MACRO_ELSE: [145],
      MACRO_END_IF: [145],
      MOD: [145],
      NEXT: [145],
      NEW: [145],
      NOT: [145],
      NOTHING: [145],
      NULL: [145],
      ON_ERROR: [145],
      ON_LOCAL_ERROR: [145],
      ON: [145],
      OPTIONAL: [145],
      OPTION_BASE: [145],
      OPTION_EXPLICIT: [145],
      OPTION_COMPARE: [145],
      OPTION_PRIVATE_MODULE: [145],
      OR: [145],
      PARAMARRAY: [145],
      PRESERVE: [145],
      PRIVATE: [145],
      PROPERTY_GET: [145],
      PROPERTY_LET: [145],
      PROPERTY_SET: [145],
      PTRSAFE: [145],
      PUBLIC: [145],
      RAISEEVENT: [145],
      REDIM: [145],
      RESET: [145],
      RESUME: [145],
      RETURN: [145],
      SELECT: [145],
      SET: [145],
      SINGLE: [145],
      STATIC: [145],
      STEP: [145],
      STOP: [145],
      STRING: [145],
      SUB: [145],
      THEN: [145],
      TO: [145],
      TRUE: [145],
      TYPEOF: [145],
      UNTIL: [145],
      VARIANT: [145],
      WEND: [145],
      WHILE: [145],
      WITH: [145],
      WITHEVENTS: [145],
      XOR: [145],
      IMP: [145],
      IDENTIFIER: [145],
    },
    variableSubStmt_group_def_54: {
      LPAREN: [146],
    },
    variableSubStmt: {
      ALIAS: [147],
      AND: [147],
      ATTRIBUTE: [147],
      AS: [147],
      BEGIN: [147],
      BOOLEAN: [147],
      BYVAL: [147],
      BYREF: [147],
      BYTE: [147],
      CALL: [147],
      CASE: [147],
      CONST: [147],
      DATE: [147],
      DECLARE: [147],
      DEFBOOL: [147],
      DEFBYTE: [147],
      DEFDATE: [147],
      DEFDBL: [147],
      DEFDEC: [147],
      DEFCUR: [147],
      DEFINT: [147],
      DEFLNG: [147],
      DEFOBJ: [147],
      DEFSNG: [147],
      DEFSTR: [147],
      DEFVAR: [147],
      DIM: [147],
      DO: [147],
      DOUBLE: [147],
      EACH: [147],
      ELSE: [147],
      ELSEIF: [147],
      END_ENUM: [147],
      END_FUNCTION: [147],
      END_IF: [147],
      END_PROPERTY: [147],
      END_SELECT: [147],
      END_SUB: [147],
      END_TYPE: [147],
      END_WITH: [147],
      END: [147],
      ENUM: [147],
      EQV: [147],
      ERASE: [147],
      EVENT: [147],
      EXIT_DO: [147],
      EXIT_FOR: [147],
      EXIT_FUNCTION: [147],
      EXIT_PROPERTY: [147],
      EXIT_SUB: [147],
      FALSE: [147],
      FRIEND: [147],
      FOR: [147],
      FUNCTION: [147],
      GET: [147],
      GLOBAL: [147],
      GOSUB: [147],
      GOTO: [147],
      IF: [147],
      IMPLEMENTS: [147],
      IN: [147],
      ISNOT: [147],
      IS: [147],
      INTEGER: [147],
      LONG: [147],
      LOOP: [147],
      LEN: [147],
      LET: [147],
      LIB: [147],
      LIKE: [147],
      LSET: [147],
      MACRO_CONST: [147],
      MACRO_IF: [147],
      MACRO_ELSEIF: [147],
      MACRO_ELSE: [147],
      MACRO_END_IF: [147],
      MOD: [147],
      NEXT: [147],
      NEW: [147],
      NOT: [147],
      NOTHING: [147],
      NULL: [147],
      ON_ERROR: [147],
      ON_LOCAL_ERROR: [147],
      ON: [147],
      OPTIONAL: [147],
      OPTION_BASE: [147],
      OPTION_EXPLICIT: [147],
      OPTION_COMPARE: [147],
      OPTION_PRIVATE_MODULE: [147],
      OR: [147],
      PARAMARRAY: [147],
      PRESERVE: [147],
      PRIVATE: [147],
      PROPERTY_GET: [147],
      PROPERTY_LET: [147],
      PROPERTY_SET: [147],
      PTRSAFE: [147],
      PUBLIC: [147],
      RAISEEVENT: [147],
      REDIM: [147],
      RESET: [147],
      RESUME: [147],
      RETURN: [147],
      SELECT: [147],
      SET: [147],
      SINGLE: [147],
      STATIC: [147],
      STEP: [147],
      STOP: [147],
      STRING: [147],
      SUB: [147],
      THEN: [147],
      TO: [147],
      TRUE: [147],
      TYPEOF: [147],
      UNTIL: [147],
      VARIANT: [147],
      WEND: [147],
      WHILE: [147],
      WITH: [147],
      WITHEVENTS: [147],
      XOR: [147],
      IMP: [147],
      IDENTIFIER: [147],
    },
    indexes: {
      DOUBLELITERAL: [148],
      INTEGERLITERAL: [148],
      STRINGLITERAL: [148],
      NOTHING: [148],
      NULL: [148],
      TRUE: [148],
      FALSE: [148],
      DATELITERAL: [148],
      SPACE_DOT: [148],
      ALIAS: [148],
      AND: [148],
      ATTRIBUTE: [148],
      AS: [148],
      BEGIN: [148],
      BOOLEAN: [148],
      BYVAL: [148],
      BYREF: [148],
      BYTE: [148],
      CALL: [148],
      CASE: [148],
      CONST: [148],
      DATE: [148],
      DECLARE: [148],
      DEFBOOL: [148],
      DEFBYTE: [148],
      DEFDATE: [148],
      DEFDBL: [148],
      DEFDEC: [148],
      DEFCUR: [148],
      DEFINT: [148],
      DEFLNG: [148],
      DEFOBJ: [148],
      DEFSNG: [148],
      DEFSTR: [148],
      DEFVAR: [148],
      DIM: [148],
      DO: [148],
      DOUBLE: [148],
      EACH: [148],
      ELSE: [148],
      ELSEIF: [148],
      END_ENUM: [148],
      END_FUNCTION: [148],
      END_IF: [148],
      END_PROPERTY: [148],
      END_SELECT: [148],
      END_SUB: [148],
      END_TYPE: [148],
      END_WITH: [148],
      END: [148],
      ENUM: [148],
      EQV: [148],
      ERASE: [148],
      EVENT: [148],
      EXIT_DO: [148],
      EXIT_FOR: [148],
      EXIT_FUNCTION: [148],
      EXIT_PROPERTY: [148],
      EXIT_SUB: [148],
      FRIEND: [148],
      FOR: [148],
      FUNCTION: [148],
      GET: [148],
      GLOBAL: [148],
      GOSUB: [148],
      GOTO: [148],
      IF: [148],
      IMPLEMENTS: [148],
      IN: [148],
      ISNOT: [148],
      IS: [148],
      INTEGER: [148],
      LONG: [148],
      LOOP: [148],
      LEN: [148],
      LET: [148],
      LIB: [148],
      LIKE: [148],
      LSET: [148],
      MACRO_CONST: [148],
      MACRO_IF: [148],
      MACRO_ELSEIF: [148],
      MACRO_ELSE: [148],
      MACRO_END_IF: [148],
      MOD: [148],
      NEXT: [148],
      NEW: [148],
      NOT: [148],
      ON_ERROR: [148],
      ON_LOCAL_ERROR: [148],
      ON: [148],
      OPTIONAL: [148],
      OPTION_BASE: [148],
      OPTION_EXPLICIT: [148],
      OPTION_COMPARE: [148],
      OPTION_PRIVATE_MODULE: [148],
      OR: [148],
      PARAMARRAY: [148],
      PRESERVE: [148],
      PRIVATE: [148],
      PROPERTY_GET: [148],
      PROPERTY_LET: [148],
      PROPERTY_SET: [148],
      PTRSAFE: [148],
      PUBLIC: [148],
      RAISEEVENT: [148],
      REDIM: [148],
      RESET: [148],
      RESUME: [148],
      RETURN: [148],
      SELECT: [148],
      SET: [148],
      SINGLE: [148],
      STATIC: [148],
      STEP: [148],
      STOP: [148],
      STRING: [148],
      SUB: [148],
      THEN: [148],
      TO: [148],
      TYPEOF: [148],
      UNTIL: [148],
      VARIANT: [148],
      WEND: [148],
      WHILE: [148],
      WITH: [148],
      WITHEVENTS: [148],
      XOR: [148],
      IMP: [148],
      IDENTIFIER: [148],
      LPAREN: [148],
      MINUS: [148],
      PLUS: [148],
    },
    subscript__group_def_57: {
      DOUBLELITERAL: [149],
      INTEGERLITERAL: [149],
      STRINGLITERAL: [149],
      NOTHING: [149],
      NULL: [149],
      TRUE: [149],
      FALSE: [149],
      DATELITERAL: [149],
      SPACE_DOT: [149],
      ALIAS: [149],
      AND: [149],
      ATTRIBUTE: [149],
      AS: [149],
      BEGIN: [149],
      BOOLEAN: [149],
      BYVAL: [149],
      BYREF: [149],
      BYTE: [149],
      CALL: [149],
      CASE: [149],
      CONST: [149],
      DATE: [149],
      DECLARE: [149],
      DEFBOOL: [149],
      DEFBYTE: [149],
      DEFDATE: [149],
      DEFDBL: [149],
      DEFDEC: [149],
      DEFCUR: [149],
      DEFINT: [149],
      DEFLNG: [149],
      DEFOBJ: [149],
      DEFSNG: [149],
      DEFSTR: [149],
      DEFVAR: [149],
      DIM: [149],
      DO: [149],
      DOUBLE: [149],
      EACH: [149],
      ELSE: [149],
      ELSEIF: [149],
      END_ENUM: [149],
      END_FUNCTION: [149],
      END_IF: [149],
      END_PROPERTY: [149],
      END_SELECT: [149],
      END_SUB: [149],
      END_TYPE: [149],
      END_WITH: [149],
      END: [149],
      ENUM: [149],
      EQV: [149],
      ERASE: [149],
      EVENT: [149],
      EXIT_DO: [149],
      EXIT_FOR: [149],
      EXIT_FUNCTION: [149],
      EXIT_PROPERTY: [149],
      EXIT_SUB: [149],
      FRIEND: [149],
      FOR: [149],
      FUNCTION: [149],
      GET: [149],
      GLOBAL: [149],
      GOSUB: [149],
      GOTO: [149],
      IF: [149],
      IMPLEMENTS: [149],
      IN: [149],
      ISNOT: [149],
      IS: [149],
      INTEGER: [149],
      LONG: [149],
      LOOP: [149],
      LEN: [149],
      LET: [149],
      LIB: [149],
      LIKE: [149],
      LSET: [149],
      MACRO_CONST: [149],
      MACRO_IF: [149],
      MACRO_ELSEIF: [149],
      MACRO_ELSE: [149],
      MACRO_END_IF: [149],
      MOD: [149],
      NEXT: [149],
      NEW: [149],
      NOT: [149],
      ON_ERROR: [149],
      ON_LOCAL_ERROR: [149],
      ON: [149],
      OPTIONAL: [149],
      OPTION_BASE: [149],
      OPTION_EXPLICIT: [149],
      OPTION_COMPARE: [149],
      OPTION_PRIVATE_MODULE: [149],
      OR: [149],
      PARAMARRAY: [149],
      PRESERVE: [149],
      PRIVATE: [149],
      PROPERTY_GET: [149],
      PROPERTY_LET: [149],
      PROPERTY_SET: [149],
      PTRSAFE: [149],
      PUBLIC: [149],
      RAISEEVENT: [149],
      REDIM: [149],
      RESET: [149],
      RESUME: [149],
      RETURN: [149],
      SELECT: [149],
      SET: [149],
      SINGLE: [149],
      STATIC: [149],
      STEP: [149],
      STOP: [149],
      STRING: [149],
      SUB: [149],
      THEN: [149],
      TO: [149],
      TYPEOF: [149],
      UNTIL: [149],
      VARIANT: [149],
      WEND: [149],
      WHILE: [149],
      WITH: [149],
      WITHEVENTS: [149],
      XOR: [149],
      IMP: [149],
      IDENTIFIER: [149],
      LPAREN: [149],
      MINUS: [149],
      PLUS: [149],
    },
    subscript_: {
      DOUBLELITERAL: [150, 153],
      INTEGERLITERAL: [150, 153],
      STRINGLITERAL: [150, 153],
      NOTHING: [150, 153],
      NULL: [150, 153],
      TRUE: [150, 153],
      FALSE: [150, 153],
      DATELITERAL: [150, 153],
      SPACE_DOT: [150, 153],
      ALIAS: [150, 153],
      AND: [150, 153],
      ATTRIBUTE: [150, 153],
      AS: [150, 153],
      BEGIN: [150, 153],
      BOOLEAN: [150, 153],
      BYVAL: [150, 153],
      BYREF: [150, 153],
      BYTE: [150, 153],
      CALL: [150, 153],
      CASE: [150, 153],
      CONST: [150, 153],
      DATE: [150, 153],
      DECLARE: [150, 153],
      DEFBOOL: [150, 153],
      DEFBYTE: [150, 153],
      DEFDATE: [150, 153],
      DEFDBL: [150, 153],
      DEFDEC: [150, 153],
      DEFCUR: [150, 153],
      DEFINT: [150, 153],
      DEFLNG: [150, 153],
      DEFOBJ: [150, 153],
      DEFSNG: [150, 153],
      DEFSTR: [150, 153],
      DEFVAR: [150, 153],
      DIM: [150, 153],
      DO: [150, 153],
      DOUBLE: [150, 153],
      EACH: [150, 153],
      ELSE: [150, 153],
      ELSEIF: [150, 153],
      END_ENUM: [150, 153],
      END_FUNCTION: [150, 153],
      END_IF: [150, 153],
      END_PROPERTY: [150, 153],
      END_SELECT: [150, 153],
      END_SUB: [150, 153],
      END_TYPE: [150, 153],
      END_WITH: [150, 153],
      END: [150, 153],
      ENUM: [150, 153],
      EQV: [150, 153],
      ERASE: [150, 153],
      EVENT: [150, 153],
      EXIT_DO: [150, 153],
      EXIT_FOR: [150, 153],
      EXIT_FUNCTION: [150, 153],
      EXIT_PROPERTY: [150, 153],
      EXIT_SUB: [150, 153],
      FRIEND: [150, 153],
      FOR: [150, 153],
      FUNCTION: [150, 153],
      GET: [150, 153],
      GLOBAL: [150, 153],
      GOSUB: [150, 153],
      GOTO: [150, 153],
      IF: [150, 153],
      IMPLEMENTS: [150, 153],
      IN: [150, 153],
      ISNOT: [150, 153],
      IS: [150, 153],
      INTEGER: [150, 153],
      LONG: [150, 153],
      LOOP: [150, 153],
      LEN: [150, 153],
      LET: [150, 153],
      LIB: [150, 153],
      LIKE: [150, 153],
      LSET: [150, 153],
      MACRO_CONST: [150, 153],
      MACRO_IF: [150, 153],
      MACRO_ELSEIF: [150, 153],
      MACRO_ELSE: [150, 153],
      MACRO_END_IF: [150, 153],
      MOD: [150, 153],
      NEXT: [150, 153],
      NEW: [150, 153],
      NOT: [150, 153],
      ON_ERROR: [150, 153],
      ON_LOCAL_ERROR: [150, 153],
      ON: [150, 153],
      OPTIONAL: [150, 153],
      OPTION_BASE: [150, 153],
      OPTION_EXPLICIT: [150, 153],
      OPTION_COMPARE: [150, 153],
      OPTION_PRIVATE_MODULE: [150, 153],
      OR: [150, 153],
      PARAMARRAY: [150, 153],
      PRESERVE: [150, 153],
      PRIVATE: [150, 153],
      PROPERTY_GET: [150, 153],
      PROPERTY_LET: [150, 153],
      PROPERTY_SET: [150, 153],
      PTRSAFE: [150, 153],
      PUBLIC: [150, 153],
      RAISEEVENT: [150, 153],
      REDIM: [150, 153],
      RESET: [150, 153],
      RESUME: [150, 153],
      RETURN: [150, 153],
      SELECT: [150, 153],
      SET: [150, 153],
      SINGLE: [150, 153],
      STATIC: [150, 153],
      STEP: [150, 153],
      STOP: [150, 153],
      STRING: [150, 153],
      SUB: [150, 153],
      THEN: [150, 153],
      TO: [150, 153],
      TYPEOF: [150, 153],
      UNTIL: [150, 153],
      VARIANT: [150, 153],
      WEND: [150, 153],
      WHILE: [150, 153],
      WITH: [150, 153],
      WITHEVENTS: [150, 153],
      XOR: [150, 153],
      IMP: [150, 153],
      IDENTIFIER: [150, 153],
      LPAREN: [150, 153],
      MINUS: [150, 153],
      PLUS: [150, 153],
    },
    subscripts_group_def_59: {
      ',': [151],
    },
    subscripts: {
      DOUBLELITERAL: [152],
      INTEGERLITERAL: [152],
      STRINGLITERAL: [152],
      NOTHING: [152],
      NULL: [152],
      TRUE: [152],
      FALSE: [152],
      DATELITERAL: [152],
      ALIAS: [152],
      AND: [152],
      ATTRIBUTE: [152],
      AS: [152],
      BEGIN: [152],
      BOOLEAN: [152],
      BYVAL: [152],
      BYREF: [152],
      BYTE: [152],
      CALL: [152],
      CASE: [152],
      CONST: [152],
      DATE: [152],
      DECLARE: [152],
      DEFBOOL: [152],
      DEFBYTE: [152],
      DEFDATE: [152],
      DEFDBL: [152],
      DEFDEC: [152],
      DEFCUR: [152],
      DEFINT: [152],
      DEFLNG: [152],
      DEFOBJ: [152],
      DEFSNG: [152],
      DEFSTR: [152],
      DEFVAR: [152],
      DIM: [152],
      DO: [152],
      DOUBLE: [152],
      EACH: [152],
      ELSE: [152],
      ELSEIF: [152],
      END_ENUM: [152],
      END_FUNCTION: [152],
      END_IF: [152],
      END_PROPERTY: [152],
      END_SELECT: [152],
      END_SUB: [152],
      END_TYPE: [152],
      END_WITH: [152],
      END: [152],
      ENUM: [152],
      EQV: [152],
      ERASE: [152],
      EVENT: [152],
      EXIT_DO: [152],
      EXIT_FOR: [152],
      EXIT_FUNCTION: [152],
      EXIT_PROPERTY: [152],
      EXIT_SUB: [152],
      FRIEND: [152],
      FOR: [152],
      FUNCTION: [152],
      GET: [152],
      GLOBAL: [152],
      GOSUB: [152],
      GOTO: [152],
      IF: [152],
      IMPLEMENTS: [152],
      IN: [152],
      ISNOT: [152],
      IS: [152],
      INTEGER: [152],
      LONG: [152],
      LOOP: [152],
      LEN: [152],
      LET: [152],
      LIB: [152],
      LIKE: [152],
      LSET: [152],
      MACRO_CONST: [152],
      MACRO_IF: [152],
      MACRO_ELSEIF: [152],
      MACRO_ELSE: [152],
      MACRO_END_IF: [152],
      MOD: [152],
      NEXT: [152],
      NEW: [152],
      NOT: [152],
      ON_ERROR: [152],
      ON_LOCAL_ERROR: [152],
      ON: [152],
      OPTIONAL: [152],
      OPTION_BASE: [152],
      OPTION_EXPLICIT: [152],
      OPTION_COMPARE: [152],
      OPTION_PRIVATE_MODULE: [152],
      OR: [152],
      PARAMARRAY: [152],
      PRESERVE: [152],
      PRIVATE: [152],
      PROPERTY_GET: [152],
      PROPERTY_LET: [152],
      PROPERTY_SET: [152],
      PTRSAFE: [152],
      PUBLIC: [152],
      RAISEEVENT: [152],
      REDIM: [152],
      RESET: [152],
      RESUME: [152],
      RETURN: [152],
      SELECT: [152],
      SET: [152],
      SINGLE: [152],
      STATIC: [152],
      STEP: [152],
      STOP: [152],
      STRING: [152],
      SUB: [152],
      THEN: [152],
      TO: [152],
      TYPEOF: [152],
      UNTIL: [152],
      VARIANT: [152],
      WEND: [152],
      WHILE: [152],
      WITH: [152],
      WITHEVENTS: [152],
      XOR: [152],
      IMP: [152],
      IDENTIFIER: [152],
      LPAREN: [152],
      MINUS: [152],
      PLUS: [152],
      SPACE_DOT: [152],
    },
    argList_group_def_63: {
      ',': [154],
    },
    argList_group_def_64: {
      OPTIONAL: [155],
      PARAMARRAY: [155],
      ALIAS: [155],
      AND: [155],
      ATTRIBUTE: [155],
      AS: [155],
      BEGIN: [155],
      BOOLEAN: [155],
      BYVAL: [155],
      BYREF: [155],
      BYTE: [155],
      CALL: [155],
      CASE: [155],
      CONST: [155],
      DATE: [155],
      DECLARE: [155],
      DEFBOOL: [155],
      DEFBYTE: [155],
      DEFDATE: [155],
      DEFDBL: [155],
      DEFDEC: [155],
      DEFCUR: [155],
      DEFINT: [155],
      DEFLNG: [155],
      DEFOBJ: [155],
      DEFSNG: [155],
      DEFSTR: [155],
      DEFVAR: [155],
      DIM: [155],
      DO: [155],
      DOUBLE: [155],
      EACH: [155],
      ELSE: [155],
      ELSEIF: [155],
      END_ENUM: [155],
      END_FUNCTION: [155],
      END_IF: [155],
      END_PROPERTY: [155],
      END_SELECT: [155],
      END_SUB: [155],
      END_TYPE: [155],
      END_WITH: [155],
      END: [155],
      ENUM: [155],
      EQV: [155],
      ERASE: [155],
      EVENT: [155],
      EXIT_DO: [155],
      EXIT_FOR: [155],
      EXIT_FUNCTION: [155],
      EXIT_PROPERTY: [155],
      EXIT_SUB: [155],
      FALSE: [155],
      FRIEND: [155],
      FOR: [155],
      FUNCTION: [155],
      GET: [155],
      GLOBAL: [155],
      GOSUB: [155],
      GOTO: [155],
      IF: [155],
      IMPLEMENTS: [155],
      IN: [155],
      ISNOT: [155],
      IS: [155],
      INTEGER: [155],
      LONG: [155],
      LOOP: [155],
      LEN: [155],
      LET: [155],
      LIB: [155],
      LIKE: [155],
      LSET: [155],
      MACRO_CONST: [155],
      MACRO_IF: [155],
      MACRO_ELSEIF: [155],
      MACRO_ELSE: [155],
      MACRO_END_IF: [155],
      MOD: [155],
      NEXT: [155],
      NEW: [155],
      NOT: [155],
      NOTHING: [155],
      NULL: [155],
      ON_ERROR: [155],
      ON_LOCAL_ERROR: [155],
      ON: [155],
      OPTION_BASE: [155],
      OPTION_EXPLICIT: [155],
      OPTION_COMPARE: [155],
      OPTION_PRIVATE_MODULE: [155],
      OR: [155],
      PRESERVE: [155],
      PRIVATE: [155],
      PROPERTY_GET: [155],
      PROPERTY_LET: [155],
      PROPERTY_SET: [155],
      PTRSAFE: [155],
      PUBLIC: [155],
      RAISEEVENT: [155],
      REDIM: [155],
      RESET: [155],
      RESUME: [155],
      RETURN: [155],
      SELECT: [155],
      SET: [155],
      SINGLE: [155],
      STATIC: [155],
      STEP: [155],
      STOP: [155],
      STRING: [155],
      SUB: [155],
      THEN: [155],
      TO: [155],
      TRUE: [155],
      TYPEOF: [155],
      UNTIL: [155],
      VARIANT: [155],
      WEND: [155],
      WHILE: [155],
      WITH: [155],
      WITHEVENTS: [155],
      XOR: [155],
      IMP: [155],
      IDENTIFIER: [155],
    },
    argList: {
      LPAREN: [156],
    },
    valueStmt_p_end: {
      DOUBLELITERAL: [157],
      INTEGERLITERAL: [157],
      STRINGLITERAL: [157],
      NOTHING: [157, 158, 159],
      NULL: [157, 158, 159],
      TRUE: [157, 158, 159],
      FALSE: [157, 158, 159],
      DATELITERAL: [157],
      SPACE_DOT: [158],
      ALIAS: [158, 159],
      AND: [158, 159],
      ATTRIBUTE: [158, 159],
      AS: [158, 159],
      BEGIN: [158, 159],
      BOOLEAN: [158, 159],
      BYVAL: [158, 159],
      BYREF: [158, 159],
      BYTE: [158, 159],
      CALL: [158, 159],
      CASE: [158, 159],
      CONST: [158, 159],
      DATE: [158, 159],
      DECLARE: [158, 159],
      DEFBOOL: [158, 159],
      DEFBYTE: [158, 159],
      DEFDATE: [158, 159],
      DEFDBL: [158, 159],
      DEFDEC: [158, 159],
      DEFCUR: [158, 159],
      DEFINT: [158, 159],
      DEFLNG: [158, 159],
      DEFOBJ: [158, 159],
      DEFSNG: [158, 159],
      DEFSTR: [158, 159],
      DEFVAR: [158, 159],
      DIM: [158, 159],
      DO: [158, 159],
      DOUBLE: [158, 159],
      EACH: [158, 159],
      ELSE: [158, 159],
      ELSEIF: [158, 159],
      END_ENUM: [158, 159],
      END_FUNCTION: [158, 159],
      END_IF: [158, 159],
      END_PROPERTY: [158, 159],
      END_SELECT: [158, 159],
      END_SUB: [158, 159],
      END_TYPE: [158, 159],
      END_WITH: [158, 159],
      END: [158, 159],
      ENUM: [158, 159],
      EQV: [158, 159],
      ERASE: [158, 159],
      EVENT: [158, 159],
      EXIT_DO: [158, 159],
      EXIT_FOR: [158, 159],
      EXIT_FUNCTION: [158, 159],
      EXIT_PROPERTY: [158, 159],
      EXIT_SUB: [158, 159],
      FRIEND: [158, 159],
      FOR: [158, 159],
      FUNCTION: [158, 159],
      GET: [158, 159],
      GLOBAL: [158, 159],
      GOSUB: [158, 159],
      GOTO: [158, 159],
      IF: [158, 159],
      IMPLEMENTS: [158, 159],
      IN: [158, 159],
      ISNOT: [158, 159],
      IS: [158, 159],
      INTEGER: [158, 159],
      LONG: [158, 159],
      LOOP: [158, 159],
      LEN: [158, 159],
      LET: [158, 159],
      LIB: [158, 159],
      LIKE: [158, 159],
      LSET: [158, 159],
      MACRO_CONST: [158, 159],
      MACRO_IF: [158, 159],
      MACRO_ELSEIF: [158, 159],
      MACRO_ELSE: [158, 159],
      MACRO_END_IF: [158, 159],
      MOD: [158, 159],
      NEXT: [158, 159],
      NEW: [158, 159, 160],
      NOT: [158, 159],
      ON_ERROR: [158, 159],
      ON_LOCAL_ERROR: [158, 159],
      ON: [158, 159],
      OPTIONAL: [158, 159],
      OPTION_BASE: [158, 159],
      OPTION_EXPLICIT: [158, 159],
      OPTION_COMPARE: [158, 159],
      OPTION_PRIVATE_MODULE: [158, 159],
      OR: [158, 159],
      PARAMARRAY: [158, 159],
      PRESERVE: [158, 159],
      PRIVATE: [158, 159],
      PROPERTY_GET: [158, 159],
      PROPERTY_LET: [158, 159],
      PROPERTY_SET: [158, 159],
      PTRSAFE: [158, 159],
      PUBLIC: [158, 159],
      RAISEEVENT: [158, 159],
      REDIM: [158, 159],
      RESET: [158, 159],
      RESUME: [158, 159],
      RETURN: [158, 159],
      SELECT: [158, 159],
      SET: [158, 159],
      SINGLE: [158, 159],
      STATIC: [158, 159],
      STEP: [158, 159],
      STOP: [158, 159],
      STRING: [158, 159],
      SUB: [158, 159],
      THEN: [158, 159],
      TO: [158, 159],
      TYPEOF: [158, 159],
      UNTIL: [158, 159],
      VARIANT: [158, 159],
      WEND: [158, 159],
      WHILE: [158, 159],
      WITH: [158, 159],
      WITHEVENTS: [158, 159],
      XOR: [158, 159],
      IMP: [158, 159],
      IDENTIFIER: [158, 159],
      LPAREN: [161],
    },
    implicitCallStmt_InStmt: {
      ALIAS: [162, 163, 164],
      AND: [162, 163, 164],
      ATTRIBUTE: [162, 163, 164],
      AS: [162, 163, 164],
      BEGIN: [162, 163, 164],
      BOOLEAN: [162, 163, 164],
      BYVAL: [162, 163, 164],
      BYREF: [162, 163, 164],
      BYTE: [162, 163, 164],
      CALL: [162, 163, 164],
      CASE: [162, 163, 164],
      CONST: [162, 163, 164],
      DATE: [162, 163, 164],
      DECLARE: [162, 163, 164],
      DEFBOOL: [162, 163, 164],
      DEFBYTE: [162, 163, 164],
      DEFDATE: [162, 163, 164],
      DEFDBL: [162, 163, 164],
      DEFDEC: [162, 163, 164],
      DEFCUR: [162, 163, 164],
      DEFINT: [162, 163, 164],
      DEFLNG: [162, 163, 164],
      DEFOBJ: [162, 163, 164],
      DEFSNG: [162, 163, 164],
      DEFSTR: [162, 163, 164],
      DEFVAR: [162, 163, 164],
      DIM: [162, 163, 164],
      DO: [162, 163, 164],
      DOUBLE: [162, 163, 164],
      EACH: [162, 163, 164],
      ELSE: [162, 163, 164],
      ELSEIF: [162, 163, 164],
      END_ENUM: [162, 163, 164],
      END_FUNCTION: [162, 163, 164],
      END_IF: [162, 163, 164],
      END_PROPERTY: [162, 163, 164],
      END_SELECT: [162, 163, 164],
      END_SUB: [162, 163, 164],
      END_TYPE: [162, 163, 164],
      END_WITH: [162, 163, 164],
      END: [162, 163, 164],
      ENUM: [162, 163, 164],
      EQV: [162, 163, 164],
      ERASE: [162, 163, 164],
      EVENT: [162, 163, 164],
      EXIT_DO: [162, 163, 164],
      EXIT_FOR: [162, 163, 164],
      EXIT_FUNCTION: [162, 163, 164],
      EXIT_PROPERTY: [162, 163, 164],
      EXIT_SUB: [162, 163, 164],
      FALSE: [162, 163, 164],
      FRIEND: [162, 163, 164],
      FOR: [162, 163, 164],
      FUNCTION: [162, 163, 164],
      GET: [162, 163, 164],
      GLOBAL: [162, 163, 164],
      GOSUB: [162, 163, 164],
      GOTO: [162, 163, 164],
      IF: [162, 163, 164],
      IMPLEMENTS: [162, 163, 164],
      IN: [162, 163, 164],
      ISNOT: [162, 163, 164],
      IS: [162, 163, 164],
      INTEGER: [162, 163, 164],
      LONG: [162, 163, 164],
      LOOP: [162, 163, 164],
      LEN: [162, 163, 164],
      LET: [162, 163, 164],
      LIB: [162, 163, 164],
      LIKE: [162, 163, 164],
      LSET: [162, 163, 164],
      MACRO_CONST: [162, 163, 164],
      MACRO_IF: [162, 163, 164],
      MACRO_ELSEIF: [162, 163, 164],
      MACRO_ELSE: [162, 163, 164],
      MACRO_END_IF: [162, 163, 164],
      MOD: [162, 163, 164],
      NEXT: [162, 163, 164],
      NEW: [162, 163, 164],
      NOT: [162, 163, 164],
      NOTHING: [162, 163, 164],
      NULL: [162, 163, 164],
      ON_ERROR: [162, 163, 164],
      ON_LOCAL_ERROR: [162, 163, 164],
      ON: [162, 163, 164],
      OPTIONAL: [162, 163, 164],
      OPTION_BASE: [162, 163, 164],
      OPTION_EXPLICIT: [162, 163, 164],
      OPTION_COMPARE: [162, 163, 164],
      OPTION_PRIVATE_MODULE: [162, 163, 164],
      OR: [162, 163, 164],
      PARAMARRAY: [162, 163, 164],
      PRESERVE: [162, 163, 164],
      PRIVATE: [162, 163, 164],
      PROPERTY_GET: [162, 163, 164],
      PROPERTY_LET: [162, 163, 164],
      PROPERTY_SET: [162, 163, 164],
      PTRSAFE: [162, 163, 164],
      PUBLIC: [162, 163, 164],
      RAISEEVENT: [162, 163, 164],
      REDIM: [162, 163, 164],
      RESET: [162, 163, 164],
      RESUME: [162, 163, 164],
      RETURN: [162, 163, 164],
      SELECT: [162, 163, 164],
      SET: [162, 163, 164],
      SINGLE: [162, 163, 164],
      STATIC: [162, 163, 164],
      STEP: [162, 163, 164],
      STOP: [162, 163, 164],
      STRING: [162, 163, 164],
      SUB: [162, 163, 164],
      THEN: [162, 163, 164],
      TO: [162, 163, 164],
      TRUE: [162, 163, 164],
      TYPEOF: [162, 163, 164],
      UNTIL: [162, 163, 164],
      VARIANT: [162, 163, 164],
      WEND: [162, 163, 164],
      WHILE: [162, 163, 164],
      WITH: [162, 163, 164],
      WITHEVENTS: [162, 163, 164],
      XOR: [162, 163, 164],
      IMP: [162, 163, 164],
      IDENTIFIER: [162, 163, 164],
      SPACE_DOT: [162],
    },
    iCS_S_MembersCall_group_def_67: {
      ALIAS: [165],
      AND: [165],
      ATTRIBUTE: [165],
      AS: [165],
      BEGIN: [165],
      BOOLEAN: [165],
      BYVAL: [165],
      BYREF: [165],
      BYTE: [165],
      CALL: [165],
      CASE: [165],
      CONST: [165],
      DATE: [165],
      DECLARE: [165],
      DEFBOOL: [165],
      DEFBYTE: [165],
      DEFDATE: [165],
      DEFDBL: [165],
      DEFDEC: [165],
      DEFCUR: [165],
      DEFINT: [165],
      DEFLNG: [165],
      DEFOBJ: [165],
      DEFSNG: [165],
      DEFSTR: [165],
      DEFVAR: [165],
      DIM: [165],
      DO: [165],
      DOUBLE: [165],
      EACH: [165],
      ELSE: [165],
      ELSEIF: [165],
      END_ENUM: [165],
      END_FUNCTION: [165],
      END_IF: [165],
      END_PROPERTY: [165],
      END_SELECT: [165],
      END_SUB: [165],
      END_TYPE: [165],
      END_WITH: [165],
      END: [165],
      ENUM: [165],
      EQV: [165],
      ERASE: [165],
      EVENT: [165],
      EXIT_DO: [165],
      EXIT_FOR: [165],
      EXIT_FUNCTION: [165],
      EXIT_PROPERTY: [165],
      EXIT_SUB: [165],
      FALSE: [165],
      FRIEND: [165],
      FOR: [165],
      FUNCTION: [165],
      GET: [165],
      GLOBAL: [165],
      GOSUB: [165],
      GOTO: [165],
      IF: [165],
      IMPLEMENTS: [165],
      IN: [165],
      ISNOT: [165],
      IS: [165],
      INTEGER: [165],
      LONG: [165],
      LOOP: [165],
      LEN: [165],
      LET: [165],
      LIB: [165],
      LIKE: [165],
      LSET: [165],
      MACRO_CONST: [165],
      MACRO_IF: [165],
      MACRO_ELSEIF: [165],
      MACRO_ELSE: [165],
      MACRO_END_IF: [165],
      MOD: [165],
      NEXT: [165],
      NEW: [165],
      NOT: [165],
      NOTHING: [165],
      NULL: [165],
      ON_ERROR: [165],
      ON_LOCAL_ERROR: [165],
      ON: [165],
      OPTIONAL: [165],
      OPTION_BASE: [165],
      OPTION_EXPLICIT: [165],
      OPTION_COMPARE: [165],
      OPTION_PRIVATE_MODULE: [165],
      OR: [165],
      PARAMARRAY: [165],
      PRESERVE: [165],
      PRIVATE: [165],
      PROPERTY_GET: [165],
      PROPERTY_LET: [165],
      PROPERTY_SET: [165],
      PTRSAFE: [165],
      PUBLIC: [165],
      RAISEEVENT: [165],
      REDIM: [165],
      RESET: [165],
      RESUME: [165],
      RETURN: [165],
      SELECT: [165],
      SET: [165],
      SINGLE: [165],
      STATIC: [165],
      STEP: [165],
      STOP: [165],
      STRING: [165],
      SUB: [165],
      THEN: [165],
      TO: [165],
      TRUE: [165],
      TYPEOF: [165],
      UNTIL: [165],
      VARIANT: [165],
      WEND: [165],
      WHILE: [165],
      WITH: [165],
      WITHEVENTS: [165],
      XOR: [165],
      IMP: [165],
      IDENTIFIER: [165],
    },
    iCS_S_MembersCall_group_66: {
      ALIAS: [166, 168],
      AND: [166, 168],
      ATTRIBUTE: [166, 168],
      AS: [166, 168],
      BEGIN: [166, 168],
      BOOLEAN: [166, 168],
      BYVAL: [166, 168],
      BYREF: [166, 168],
      BYTE: [166, 168],
      CALL: [166, 168],
      CASE: [166, 168],
      CONST: [166, 168],
      DATE: [166, 168],
      DECLARE: [166, 168],
      DEFBOOL: [166, 168],
      DEFBYTE: [166, 168],
      DEFDATE: [166, 168],
      DEFDBL: [166, 168],
      DEFDEC: [166, 168],
      DEFCUR: [166, 168],
      DEFINT: [166, 168],
      DEFLNG: [166, 168],
      DEFOBJ: [166, 168],
      DEFSNG: [166, 168],
      DEFSTR: [166, 168],
      DEFVAR: [166, 168],
      DIM: [166, 168],
      DO: [166, 168],
      DOUBLE: [166, 168],
      EACH: [166, 168],
      ELSE: [166, 168],
      ELSEIF: [166, 168],
      END_ENUM: [166, 168],
      END_FUNCTION: [166, 168],
      END_IF: [166, 168],
      END_PROPERTY: [166, 168],
      END_SELECT: [166, 168],
      END_SUB: [166, 168],
      END_TYPE: [166, 168],
      END_WITH: [166, 168],
      END: [166, 168],
      ENUM: [166, 168],
      EQV: [166, 168],
      ERASE: [166, 168],
      EVENT: [166, 168],
      EXIT_DO: [166, 168],
      EXIT_FOR: [166, 168],
      EXIT_FUNCTION: [166, 168],
      EXIT_PROPERTY: [166, 168],
      EXIT_SUB: [166, 168],
      FALSE: [166, 168],
      FRIEND: [166, 168],
      FOR: [166, 168],
      FUNCTION: [166, 168],
      GET: [166, 168],
      GLOBAL: [166, 168],
      GOSUB: [166, 168],
      GOTO: [166, 168],
      IF: [166, 168],
      IMPLEMENTS: [166, 168],
      IN: [166, 168],
      ISNOT: [166, 168],
      IS: [166, 168],
      INTEGER: [166, 168],
      LONG: [166, 168],
      LOOP: [166, 168],
      LEN: [166, 168],
      LET: [166, 168],
      LIB: [166, 168],
      LIKE: [166, 168],
      LSET: [166, 168],
      MACRO_CONST: [166, 168],
      MACRO_IF: [166, 168],
      MACRO_ELSEIF: [166, 168],
      MACRO_ELSE: [166, 168],
      MACRO_END_IF: [166, 168],
      MOD: [166, 168],
      NEXT: [166, 168],
      NEW: [166, 168],
      NOT: [166, 168],
      NOTHING: [166, 168],
      NULL: [166, 168],
      ON_ERROR: [166, 168],
      ON_LOCAL_ERROR: [166, 168],
      ON: [166, 168],
      OPTIONAL: [166, 168],
      OPTION_BASE: [166, 168],
      OPTION_EXPLICIT: [166, 168],
      OPTION_COMPARE: [166, 168],
      OPTION_PRIVATE_MODULE: [166, 168],
      OR: [166, 168],
      PARAMARRAY: [166, 168],
      PRESERVE: [166, 168],
      PRIVATE: [166, 168],
      PROPERTY_GET: [166, 168],
      PROPERTY_LET: [166, 168],
      PROPERTY_SET: [166, 168],
      PTRSAFE: [166, 168],
      PUBLIC: [166, 168],
      RAISEEVENT: [166, 168],
      REDIM: [166, 168],
      RESET: [166, 168],
      RESUME: [166, 168],
      RETURN: [166, 168],
      SELECT: [166, 168],
      SET: [166, 168],
      SINGLE: [166, 168],
      STATIC: [166, 168],
      STEP: [166, 168],
      STOP: [166, 168],
      STRING: [166, 168],
      SUB: [166, 168],
      THEN: [166, 168],
      TO: [166, 168],
      TRUE: [166, 168],
      TYPEOF: [166, 168],
      UNTIL: [166, 168],
      VARIANT: [166, 168],
      WEND: [166, 168],
      WHILE: [166, 168],
      WITH: [166, 168],
      WITHEVENTS: [166, 168],
      XOR: [166, 168],
      IMP: [166, 168],
      IDENTIFIER: [166, 168],
    },
    iCS_S_MembersCall_group_def_68: {
      ALIAS: [167],
      AND: [167],
      ATTRIBUTE: [167],
      AS: [167],
      BEGIN: [167],
      BOOLEAN: [167],
      BYVAL: [167],
      BYREF: [167],
      BYTE: [167],
      CALL: [167],
      CASE: [167],
      CONST: [167],
      DATE: [167],
      DECLARE: [167],
      DEFBOOL: [167],
      DEFBYTE: [167],
      DEFDATE: [167],
      DEFDBL: [167],
      DEFDEC: [167],
      DEFCUR: [167],
      DEFINT: [167],
      DEFLNG: [167],
      DEFOBJ: [167],
      DEFSNG: [167],
      DEFSTR: [167],
      DEFVAR: [167],
      DIM: [167],
      DO: [167],
      DOUBLE: [167],
      EACH: [167],
      ELSE: [167],
      ELSEIF: [167],
      END_ENUM: [167],
      END_FUNCTION: [167],
      END_IF: [167],
      END_PROPERTY: [167],
      END_SELECT: [167],
      END_SUB: [167],
      END_TYPE: [167],
      END_WITH: [167],
      END: [167],
      ENUM: [167],
      EQV: [167],
      ERASE: [167],
      EVENT: [167],
      EXIT_DO: [167],
      EXIT_FOR: [167],
      EXIT_FUNCTION: [167],
      EXIT_PROPERTY: [167],
      EXIT_SUB: [167],
      FALSE: [167],
      FRIEND: [167],
      FOR: [167],
      FUNCTION: [167],
      GET: [167],
      GLOBAL: [167],
      GOSUB: [167],
      GOTO: [167],
      IF: [167],
      IMPLEMENTS: [167],
      IN: [167],
      ISNOT: [167],
      IS: [167],
      INTEGER: [167],
      LONG: [167],
      LOOP: [167],
      LEN: [167],
      LET: [167],
      LIB: [167],
      LIKE: [167],
      LSET: [167],
      MACRO_CONST: [167],
      MACRO_IF: [167],
      MACRO_ELSEIF: [167],
      MACRO_ELSE: [167],
      MACRO_END_IF: [167],
      MOD: [167],
      NEXT: [167],
      NEW: [167],
      NOT: [167],
      NOTHING: [167],
      NULL: [167],
      ON_ERROR: [167],
      ON_LOCAL_ERROR: [167],
      ON: [167],
      OPTIONAL: [167],
      OPTION_BASE: [167],
      OPTION_EXPLICIT: [167],
      OPTION_COMPARE: [167],
      OPTION_PRIVATE_MODULE: [167],
      OR: [167],
      PARAMARRAY: [167],
      PRESERVE: [167],
      PRIVATE: [167],
      PROPERTY_GET: [167],
      PROPERTY_LET: [167],
      PROPERTY_SET: [167],
      PTRSAFE: [167],
      PUBLIC: [167],
      RAISEEVENT: [167],
      REDIM: [167],
      RESET: [167],
      RESUME: [167],
      RETURN: [167],
      SELECT: [167],
      SET: [167],
      SINGLE: [167],
      STATIC: [167],
      STEP: [167],
      STOP: [167],
      STRING: [167],
      SUB: [167],
      THEN: [167],
      TO: [167],
      TRUE: [167],
      TYPEOF: [167],
      UNTIL: [167],
      VARIANT: [167],
      WEND: [167],
      WHILE: [167],
      WITH: [167],
      WITHEVENTS: [167],
      XOR: [167],
      IMP: [167],
      IDENTIFIER: [167],
    },
    iCS_S_MembersCall_group_def_69: {
      ALIAS: [169],
      AND: [169],
      ATTRIBUTE: [169],
      AS: [169],
      BEGIN: [169],
      BOOLEAN: [169],
      BYVAL: [169],
      BYREF: [169],
      BYTE: [169],
      CALL: [169],
      CASE: [169],
      CONST: [169],
      DATE: [169],
      DECLARE: [169],
      DEFBOOL: [169],
      DEFBYTE: [169],
      DEFDATE: [169],
      DEFDBL: [169],
      DEFDEC: [169],
      DEFCUR: [169],
      DEFINT: [169],
      DEFLNG: [169],
      DEFOBJ: [169],
      DEFSNG: [169],
      DEFSTR: [169],
      DEFVAR: [169],
      DIM: [169],
      DO: [169],
      DOUBLE: [169],
      EACH: [169],
      ELSE: [169],
      ELSEIF: [169],
      END_ENUM: [169],
      END_FUNCTION: [169],
      END_IF: [169],
      END_PROPERTY: [169],
      END_SELECT: [169],
      END_SUB: [169],
      END_TYPE: [169],
      END_WITH: [169],
      END: [169],
      ENUM: [169],
      EQV: [169],
      ERASE: [169],
      EVENT: [169],
      EXIT_DO: [169],
      EXIT_FOR: [169],
      EXIT_FUNCTION: [169],
      EXIT_PROPERTY: [169],
      EXIT_SUB: [169],
      FALSE: [169],
      FRIEND: [169],
      FOR: [169],
      FUNCTION: [169],
      GET: [169],
      GLOBAL: [169],
      GOSUB: [169],
      GOTO: [169],
      IF: [169],
      IMPLEMENTS: [169],
      IN: [169],
      ISNOT: [169],
      IS: [169],
      INTEGER: [169],
      LONG: [169],
      LOOP: [169],
      LEN: [169],
      LET: [169],
      LIB: [169],
      LIKE: [169],
      LSET: [169],
      MACRO_CONST: [169],
      MACRO_IF: [169],
      MACRO_ELSEIF: [169],
      MACRO_ELSE: [169],
      MACRO_END_IF: [169],
      MOD: [169],
      NEXT: [169],
      NEW: [169],
      NOT: [169],
      NOTHING: [169],
      NULL: [169],
      ON_ERROR: [169],
      ON_LOCAL_ERROR: [169],
      ON: [169],
      OPTIONAL: [169],
      OPTION_BASE: [169],
      OPTION_EXPLICIT: [169],
      OPTION_COMPARE: [169],
      OPTION_PRIVATE_MODULE: [169],
      OR: [169],
      PARAMARRAY: [169],
      PRESERVE: [169],
      PRIVATE: [169],
      PROPERTY_GET: [169],
      PROPERTY_LET: [169],
      PROPERTY_SET: [169],
      PTRSAFE: [169],
      PUBLIC: [169],
      RAISEEVENT: [169],
      REDIM: [169],
      RESET: [169],
      RESUME: [169],
      RETURN: [169],
      SELECT: [169],
      SET: [169],
      SINGLE: [169],
      STATIC: [169],
      STEP: [169],
      STOP: [169],
      STRING: [169],
      SUB: [169],
      THEN: [169],
      TO: [169],
      TRUE: [169],
      TYPEOF: [169],
      UNTIL: [169],
      VARIANT: [169],
      WEND: [169],
      WHILE: [169],
      WITH: [169],
      WITHEVENTS: [169],
      XOR: [169],
      IMP: [169],
      IDENTIFIER: [169],
    },
    iCS_S_MembersCall_group_65: {
      ALIAS: [170],
      AND: [170],
      ATTRIBUTE: [170],
      AS: [170],
      BEGIN: [170],
      BOOLEAN: [170],
      BYVAL: [170],
      BYREF: [170],
      BYTE: [170],
      CALL: [170],
      CASE: [170],
      CONST: [170],
      DATE: [170],
      DECLARE: [170],
      DEFBOOL: [170],
      DEFBYTE: [170],
      DEFDATE: [170],
      DEFDBL: [170],
      DEFDEC: [170],
      DEFCUR: [170],
      DEFINT: [170],
      DEFLNG: [170],
      DEFOBJ: [170],
      DEFSNG: [170],
      DEFSTR: [170],
      DEFVAR: [170],
      DIM: [170],
      DO: [170],
      DOUBLE: [170],
      EACH: [170],
      ELSE: [170],
      ELSEIF: [170],
      END_ENUM: [170],
      END_FUNCTION: [170],
      END_IF: [170],
      END_PROPERTY: [170],
      END_SELECT: [170],
      END_SUB: [170],
      END_TYPE: [170],
      END_WITH: [170],
      END: [170],
      ENUM: [170],
      EQV: [170],
      ERASE: [170],
      EVENT: [170],
      EXIT_DO: [170],
      EXIT_FOR: [170],
      EXIT_FUNCTION: [170],
      EXIT_PROPERTY: [170],
      EXIT_SUB: [170],
      FALSE: [170],
      FRIEND: [170],
      FOR: [170],
      FUNCTION: [170],
      GET: [170],
      GLOBAL: [170],
      GOSUB: [170],
      GOTO: [170],
      IF: [170],
      IMPLEMENTS: [170],
      IN: [170],
      ISNOT: [170],
      IS: [170],
      INTEGER: [170],
      LONG: [170],
      LOOP: [170],
      LEN: [170],
      LET: [170],
      LIB: [170],
      LIKE: [170],
      LSET: [170],
      MACRO_CONST: [170],
      MACRO_IF: [170],
      MACRO_ELSEIF: [170],
      MACRO_ELSE: [170],
      MACRO_END_IF: [170],
      MOD: [170],
      NEXT: [170],
      NEW: [170],
      NOT: [170],
      NOTHING: [170],
      NULL: [170],
      ON_ERROR: [170],
      ON_LOCAL_ERROR: [170],
      ON: [170],
      OPTIONAL: [170],
      OPTION_BASE: [170],
      OPTION_EXPLICIT: [170],
      OPTION_COMPARE: [170],
      OPTION_PRIVATE_MODULE: [170],
      OR: [170],
      PARAMARRAY: [170],
      PRESERVE: [170],
      PRIVATE: [170],
      PROPERTY_GET: [170],
      PROPERTY_LET: [170],
      PROPERTY_SET: [170],
      PTRSAFE: [170],
      PUBLIC: [170],
      RAISEEVENT: [170],
      REDIM: [170],
      RESET: [170],
      RESUME: [170],
      RETURN: [170],
      SELECT: [170],
      SET: [170],
      SINGLE: [170],
      STATIC: [170],
      STEP: [170],
      STOP: [170],
      STRING: [170],
      SUB: [170],
      THEN: [170],
      TO: [170],
      TRUE: [170],
      TYPEOF: [170],
      UNTIL: [170],
      VARIANT: [170],
      WEND: [170],
      WHILE: [170],
      WITH: [170],
      WITHEVENTS: [170],
      XOR: [170],
      IMP: [170],
      IDENTIFIER: [170],
      SPACE_DOT: [172],
    },
    iCS_S_MembersCall_group_def_70: {
      SPACE_DOT: [171],
    },
    iCS_S_MembersCall: {
      ALIAS: [173],
      AND: [173],
      ATTRIBUTE: [173],
      AS: [173],
      BEGIN: [173],
      BOOLEAN: [173],
      BYVAL: [173],
      BYREF: [173],
      BYTE: [173],
      CALL: [173],
      CASE: [173],
      CONST: [173],
      DATE: [173],
      DECLARE: [173],
      DEFBOOL: [173],
      DEFBYTE: [173],
      DEFDATE: [173],
      DEFDBL: [173],
      DEFDEC: [173],
      DEFCUR: [173],
      DEFINT: [173],
      DEFLNG: [173],
      DEFOBJ: [173],
      DEFSNG: [173],
      DEFSTR: [173],
      DEFVAR: [173],
      DIM: [173],
      DO: [173],
      DOUBLE: [173],
      EACH: [173],
      ELSE: [173],
      ELSEIF: [173],
      END_ENUM: [173],
      END_FUNCTION: [173],
      END_IF: [173],
      END_PROPERTY: [173],
      END_SELECT: [173],
      END_SUB: [173],
      END_TYPE: [173],
      END_WITH: [173],
      END: [173],
      ENUM: [173],
      EQV: [173],
      ERASE: [173],
      EVENT: [173],
      EXIT_DO: [173],
      EXIT_FOR: [173],
      EXIT_FUNCTION: [173],
      EXIT_PROPERTY: [173],
      EXIT_SUB: [173],
      FALSE: [173],
      FRIEND: [173],
      FOR: [173],
      FUNCTION: [173],
      GET: [173],
      GLOBAL: [173],
      GOSUB: [173],
      GOTO: [173],
      IF: [173],
      IMPLEMENTS: [173],
      IN: [173],
      ISNOT: [173],
      IS: [173],
      INTEGER: [173],
      LONG: [173],
      LOOP: [173],
      LEN: [173],
      LET: [173],
      LIB: [173],
      LIKE: [173],
      LSET: [173],
      MACRO_CONST: [173],
      MACRO_IF: [173],
      MACRO_ELSEIF: [173],
      MACRO_ELSE: [173],
      MACRO_END_IF: [173],
      MOD: [173],
      NEXT: [173],
      NEW: [173],
      NOT: [173],
      NOTHING: [173],
      NULL: [173],
      ON_ERROR: [173],
      ON_LOCAL_ERROR: [173],
      ON: [173],
      OPTIONAL: [173],
      OPTION_BASE: [173],
      OPTION_EXPLICIT: [173],
      OPTION_COMPARE: [173],
      OPTION_PRIVATE_MODULE: [173],
      OR: [173],
      PARAMARRAY: [173],
      PRESERVE: [173],
      PRIVATE: [173],
      PROPERTY_GET: [173],
      PROPERTY_LET: [173],
      PROPERTY_SET: [173],
      PTRSAFE: [173],
      PUBLIC: [173],
      RAISEEVENT: [173],
      REDIM: [173],
      RESET: [173],
      RESUME: [173],
      RETURN: [173],
      SELECT: [173],
      SET: [173],
      SINGLE: [173],
      STATIC: [173],
      STEP: [173],
      STOP: [173],
      STRING: [173],
      SUB: [173],
      THEN: [173],
      TO: [173],
      TRUE: [173],
      TYPEOF: [173],
      UNTIL: [173],
      VARIANT: [173],
      WEND: [173],
      WHILE: [173],
      WITH: [173],
      WITHEVENTS: [173],
      XOR: [173],
      IMP: [173],
      IDENTIFIER: [173],
      SPACE_DOT: [173],
    },
    iCS_S_MemberCall_group_72: {
      ALIAS: [174, 175],
      AND: [174, 175],
      ATTRIBUTE: [174, 175],
      AS: [174, 175],
      BEGIN: [174, 175],
      BOOLEAN: [174, 175],
      BYVAL: [174, 175],
      BYREF: [174, 175],
      BYTE: [174, 175],
      CALL: [174, 175],
      CASE: [174, 175],
      CONST: [174, 175],
      DATE: [174, 175],
      DECLARE: [174, 175],
      DEFBOOL: [174, 175],
      DEFBYTE: [174, 175],
      DEFDATE: [174, 175],
      DEFDBL: [174, 175],
      DEFDEC: [174, 175],
      DEFCUR: [174, 175],
      DEFINT: [174, 175],
      DEFLNG: [174, 175],
      DEFOBJ: [174, 175],
      DEFSNG: [174, 175],
      DEFSTR: [174, 175],
      DEFVAR: [174, 175],
      DIM: [174, 175],
      DO: [174, 175],
      DOUBLE: [174, 175],
      EACH: [174, 175],
      ELSE: [174, 175],
      ELSEIF: [174, 175],
      END_ENUM: [174, 175],
      END_FUNCTION: [174, 175],
      END_IF: [174, 175],
      END_PROPERTY: [174, 175],
      END_SELECT: [174, 175],
      END_SUB: [174, 175],
      END_TYPE: [174, 175],
      END_WITH: [174, 175],
      END: [174, 175],
      ENUM: [174, 175],
      EQV: [174, 175],
      ERASE: [174, 175],
      EVENT: [174, 175],
      EXIT_DO: [174, 175],
      EXIT_FOR: [174, 175],
      EXIT_FUNCTION: [174, 175],
      EXIT_PROPERTY: [174, 175],
      EXIT_SUB: [174, 175],
      FALSE: [174, 175],
      FRIEND: [174, 175],
      FOR: [174, 175],
      FUNCTION: [174, 175],
      GET: [174, 175],
      GLOBAL: [174, 175],
      GOSUB: [174, 175],
      GOTO: [174, 175],
      IF: [174, 175],
      IMPLEMENTS: [174, 175],
      IN: [174, 175],
      ISNOT: [174, 175],
      IS: [174, 175],
      INTEGER: [174, 175],
      LONG: [174, 175],
      LOOP: [174, 175],
      LEN: [174, 175],
      LET: [174, 175],
      LIB: [174, 175],
      LIKE: [174, 175],
      LSET: [174, 175],
      MACRO_CONST: [174, 175],
      MACRO_IF: [174, 175],
      MACRO_ELSEIF: [174, 175],
      MACRO_ELSE: [174, 175],
      MACRO_END_IF: [174, 175],
      MOD: [174, 175],
      NEXT: [174, 175],
      NEW: [174, 175],
      NOT: [174, 175],
      NOTHING: [174, 175],
      NULL: [174, 175],
      ON_ERROR: [174, 175],
      ON_LOCAL_ERROR: [174, 175],
      ON: [174, 175],
      OPTIONAL: [174, 175],
      OPTION_BASE: [174, 175],
      OPTION_EXPLICIT: [174, 175],
      OPTION_COMPARE: [174, 175],
      OPTION_PRIVATE_MODULE: [174, 175],
      OR: [174, 175],
      PARAMARRAY: [174, 175],
      PRESERVE: [174, 175],
      PRIVATE: [174, 175],
      PROPERTY_GET: [174, 175],
      PROPERTY_LET: [174, 175],
      PROPERTY_SET: [174, 175],
      PTRSAFE: [174, 175],
      PUBLIC: [174, 175],
      RAISEEVENT: [174, 175],
      REDIM: [174, 175],
      RESET: [174, 175],
      RESUME: [174, 175],
      RETURN: [174, 175],
      SELECT: [174, 175],
      SET: [174, 175],
      SINGLE: [174, 175],
      STATIC: [174, 175],
      STEP: [174, 175],
      STOP: [174, 175],
      STRING: [174, 175],
      SUB: [174, 175],
      THEN: [174, 175],
      TO: [174, 175],
      TRUE: [174, 175],
      TYPEOF: [174, 175],
      UNTIL: [174, 175],
      VARIANT: [174, 175],
      WEND: [174, 175],
      WHILE: [174, 175],
      WITH: [174, 175],
      WITHEVENTS: [174, 175],
      XOR: [174, 175],
      IMP: [174, 175],
      IDENTIFIER: [174, 175],
    },
    iCS_S_MemberCall: {
      '.': [176],
    },
    iCS_S_SpaceMemberCall_group_73: {
      ALIAS: [177, 178],
      AND: [177, 178],
      ATTRIBUTE: [177, 178],
      AS: [177, 178],
      BEGIN: [177, 178],
      BOOLEAN: [177, 178],
      BYVAL: [177, 178],
      BYREF: [177, 178],
      BYTE: [177, 178],
      CALL: [177, 178],
      CASE: [177, 178],
      CONST: [177, 178],
      DATE: [177, 178],
      DECLARE: [177, 178],
      DEFBOOL: [177, 178],
      DEFBYTE: [177, 178],
      DEFDATE: [177, 178],
      DEFDBL: [177, 178],
      DEFDEC: [177, 178],
      DEFCUR: [177, 178],
      DEFINT: [177, 178],
      DEFLNG: [177, 178],
      DEFOBJ: [177, 178],
      DEFSNG: [177, 178],
      DEFSTR: [177, 178],
      DEFVAR: [177, 178],
      DIM: [177, 178],
      DO: [177, 178],
      DOUBLE: [177, 178],
      EACH: [177, 178],
      ELSE: [177, 178],
      ELSEIF: [177, 178],
      END_ENUM: [177, 178],
      END_FUNCTION: [177, 178],
      END_IF: [177, 178],
      END_PROPERTY: [177, 178],
      END_SELECT: [177, 178],
      END_SUB: [177, 178],
      END_TYPE: [177, 178],
      END_WITH: [177, 178],
      END: [177, 178],
      ENUM: [177, 178],
      EQV: [177, 178],
      ERASE: [177, 178],
      EVENT: [177, 178],
      EXIT_DO: [177, 178],
      EXIT_FOR: [177, 178],
      EXIT_FUNCTION: [177, 178],
      EXIT_PROPERTY: [177, 178],
      EXIT_SUB: [177, 178],
      FALSE: [177, 178],
      FRIEND: [177, 178],
      FOR: [177, 178],
      FUNCTION: [177, 178],
      GET: [177, 178],
      GLOBAL: [177, 178],
      GOSUB: [177, 178],
      GOTO: [177, 178],
      IF: [177, 178],
      IMPLEMENTS: [177, 178],
      IN: [177, 178],
      ISNOT: [177, 178],
      IS: [177, 178],
      INTEGER: [177, 178],
      LONG: [177, 178],
      LOOP: [177, 178],
      LEN: [177, 178],
      LET: [177, 178],
      LIB: [177, 178],
      LIKE: [177, 178],
      LSET: [177, 178],
      MACRO_CONST: [177, 178],
      MACRO_IF: [177, 178],
      MACRO_ELSEIF: [177, 178],
      MACRO_ELSE: [177, 178],
      MACRO_END_IF: [177, 178],
      MOD: [177, 178],
      NEXT: [177, 178],
      NEW: [177, 178],
      NOT: [177, 178],
      NOTHING: [177, 178],
      NULL: [177, 178],
      ON_ERROR: [177, 178],
      ON_LOCAL_ERROR: [177, 178],
      ON: [177, 178],
      OPTIONAL: [177, 178],
      OPTION_BASE: [177, 178],
      OPTION_EXPLICIT: [177, 178],
      OPTION_COMPARE: [177, 178],
      OPTION_PRIVATE_MODULE: [177, 178],
      OR: [177, 178],
      PARAMARRAY: [177, 178],
      PRESERVE: [177, 178],
      PRIVATE: [177, 178],
      PROPERTY_GET: [177, 178],
      PROPERTY_LET: [177, 178],
      PROPERTY_SET: [177, 178],
      PTRSAFE: [177, 178],
      PUBLIC: [177, 178],
      RAISEEVENT: [177, 178],
      REDIM: [177, 178],
      RESET: [177, 178],
      RESUME: [177, 178],
      RETURN: [177, 178],
      SELECT: [177, 178],
      SET: [177, 178],
      SINGLE: [177, 178],
      STATIC: [177, 178],
      STEP: [177, 178],
      STOP: [177, 178],
      STRING: [177, 178],
      SUB: [177, 178],
      THEN: [177, 178],
      TO: [177, 178],
      TRUE: [177, 178],
      TYPEOF: [177, 178],
      UNTIL: [177, 178],
      VARIANT: [177, 178],
      WEND: [177, 178],
      WHILE: [177, 178],
      WITH: [177, 178],
      WITHEVENTS: [177, 178],
      XOR: [177, 178],
      IMP: [177, 178],
      IDENTIFIER: [177, 178],
    },
    iCS_S_SpaceMemberCall: {
      SPACE_DOT: [179],
    },
    iCS_S_ProcedureOrArrayCall: {
      ALIAS: [180],
      AND: [180],
      ATTRIBUTE: [180],
      AS: [180],
      BEGIN: [180],
      BOOLEAN: [180],
      BYVAL: [180],
      BYREF: [180],
      BYTE: [180],
      CALL: [180],
      CASE: [180],
      CONST: [180],
      DATE: [180],
      DECLARE: [180],
      DEFBOOL: [180],
      DEFBYTE: [180],
      DEFDATE: [180],
      DEFDBL: [180],
      DEFDEC: [180],
      DEFCUR: [180],
      DEFINT: [180],
      DEFLNG: [180],
      DEFOBJ: [180],
      DEFSNG: [180],
      DEFSTR: [180],
      DEFVAR: [180],
      DIM: [180],
      DO: [180],
      DOUBLE: [180],
      EACH: [180],
      ELSE: [180],
      ELSEIF: [180],
      END_ENUM: [180],
      END_FUNCTION: [180],
      END_IF: [180],
      END_PROPERTY: [180],
      END_SELECT: [180],
      END_SUB: [180],
      END_TYPE: [180],
      END_WITH: [180],
      END: [180],
      ENUM: [180],
      EQV: [180],
      ERASE: [180],
      EVENT: [180],
      EXIT_DO: [180],
      EXIT_FOR: [180],
      EXIT_FUNCTION: [180],
      EXIT_PROPERTY: [180],
      EXIT_SUB: [180],
      FALSE: [180],
      FRIEND: [180],
      FOR: [180],
      FUNCTION: [180],
      GET: [180],
      GLOBAL: [180],
      GOSUB: [180],
      GOTO: [180],
      IF: [180],
      IMPLEMENTS: [180],
      IN: [180],
      ISNOT: [180],
      IS: [180],
      INTEGER: [180],
      LONG: [180],
      LOOP: [180],
      LEN: [180],
      LET: [180],
      LIB: [180],
      LIKE: [180],
      LSET: [180],
      MACRO_CONST: [180],
      MACRO_IF: [180],
      MACRO_ELSEIF: [180],
      MACRO_ELSE: [180],
      MACRO_END_IF: [180],
      MOD: [180],
      NEXT: [180],
      NEW: [180],
      NOT: [180],
      NOTHING: [180],
      NULL: [180],
      ON_ERROR: [180],
      ON_LOCAL_ERROR: [180],
      ON: [180],
      OPTIONAL: [180],
      OPTION_BASE: [180],
      OPTION_EXPLICIT: [180],
      OPTION_COMPARE: [180],
      OPTION_PRIVATE_MODULE: [180],
      OR: [180],
      PARAMARRAY: [180],
      PRESERVE: [180],
      PRIVATE: [180],
      PROPERTY_GET: [180],
      PROPERTY_LET: [180],
      PROPERTY_SET: [180],
      PTRSAFE: [180],
      PUBLIC: [180],
      RAISEEVENT: [180],
      REDIM: [180],
      RESET: [180],
      RESUME: [180],
      RETURN: [180],
      SELECT: [180],
      SET: [180],
      SINGLE: [180],
      STATIC: [180],
      STEP: [180],
      STOP: [180],
      STRING: [180],
      SUB: [180],
      THEN: [180],
      TO: [180],
      TRUE: [180],
      TYPEOF: [180],
      UNTIL: [180],
      VARIANT: [180],
      WEND: [180],
      WHILE: [180],
      WITH: [180],
      WITHEVENTS: [180],
      XOR: [180],
      IMP: [180],
      IDENTIFIER: [180],
    },
    iCS_S_VariableOrProcedureCall: {
      ALIAS: [181],
      AND: [181],
      ATTRIBUTE: [181],
      AS: [181],
      BEGIN: [181],
      BOOLEAN: [181],
      BYVAL: [181],
      BYREF: [181],
      BYTE: [181],
      CALL: [181],
      CASE: [181],
      CONST: [181],
      DATE: [181],
      DECLARE: [181],
      DEFBOOL: [181],
      DEFBYTE: [181],
      DEFDATE: [181],
      DEFDBL: [181],
      DEFDEC: [181],
      DEFCUR: [181],
      DEFINT: [181],
      DEFLNG: [181],
      DEFOBJ: [181],
      DEFSNG: [181],
      DEFSTR: [181],
      DEFVAR: [181],
      DIM: [181],
      DO: [181],
      DOUBLE: [181],
      EACH: [181],
      ELSE: [181],
      ELSEIF: [181],
      END_ENUM: [181],
      END_FUNCTION: [181],
      END_IF: [181],
      END_PROPERTY: [181],
      END_SELECT: [181],
      END_SUB: [181],
      END_TYPE: [181],
      END_WITH: [181],
      END: [181],
      ENUM: [181],
      EQV: [181],
      ERASE: [181],
      EVENT: [181],
      EXIT_DO: [181],
      EXIT_FOR: [181],
      EXIT_FUNCTION: [181],
      EXIT_PROPERTY: [181],
      EXIT_SUB: [181],
      FALSE: [181],
      FRIEND: [181],
      FOR: [181],
      FUNCTION: [181],
      GET: [181],
      GLOBAL: [181],
      GOSUB: [181],
      GOTO: [181],
      IF: [181],
      IMPLEMENTS: [181],
      IN: [181],
      ISNOT: [181],
      IS: [181],
      INTEGER: [181],
      LONG: [181],
      LOOP: [181],
      LEN: [181],
      LET: [181],
      LIB: [181],
      LIKE: [181],
      LSET: [181],
      MACRO_CONST: [181],
      MACRO_IF: [181],
      MACRO_ELSEIF: [181],
      MACRO_ELSE: [181],
      MACRO_END_IF: [181],
      MOD: [181],
      NEXT: [181],
      NEW: [181],
      NOT: [181],
      NOTHING: [181],
      NULL: [181],
      ON_ERROR: [181],
      ON_LOCAL_ERROR: [181],
      ON: [181],
      OPTIONAL: [181],
      OPTION_BASE: [181],
      OPTION_EXPLICIT: [181],
      OPTION_COMPARE: [181],
      OPTION_PRIVATE_MODULE: [181],
      OR: [181],
      PARAMARRAY: [181],
      PRESERVE: [181],
      PRIVATE: [181],
      PROPERTY_GET: [181],
      PROPERTY_LET: [181],
      PROPERTY_SET: [181],
      PTRSAFE: [181],
      PUBLIC: [181],
      RAISEEVENT: [181],
      REDIM: [181],
      RESET: [181],
      RESUME: [181],
      RETURN: [181],
      SELECT: [181],
      SET: [181],
      SINGLE: [181],
      STATIC: [181],
      STEP: [181],
      STOP: [181],
      STRING: [181],
      SUB: [181],
      THEN: [181],
      TO: [181],
      TRUE: [181],
      TYPEOF: [181],
      UNTIL: [181],
      VARIANT: [181],
      WEND: [181],
      WHILE: [181],
      WITH: [181],
      WITHEVENTS: [181],
      XOR: [181],
      IMP: [181],
      IDENTIFIER: [181],
    },
    dictionaryCallStmt: {
      '!': [182],
    },
    literal: {
      DOUBLELITERAL: [183],
      INTEGERLITERAL: [184],
      STRINGLITERAL: [185],
      NOTHING: [186],
      NULL: [187],
      TRUE: [188],
      FALSE: [189],
      DATELITERAL: [190],
    },
    typeHint: {
      '&': [191],
      '%': [192],
      '#': [193],
      '!': [194],
      '@': [195],
      $: [196],
    },
    arg_group_def_77: {
      BYVAL: [197],
    },
    arg_group_76: {
      BYVAL: [198],
      BYREF: [200],
    },
    arg_group_def_78: {
      BYREF: [199],
    },
    arg_group_def_80: {
      LPAREN: [201],
    },
    arg: {
      OPTIONAL: [202],
      BYVAL: [202],
      BYREF: [202],
      PARAMARRAY: [202],
      ALIAS: [202],
      AND: [202],
      ATTRIBUTE: [202],
      AS: [202],
      BEGIN: [202],
      BOOLEAN: [202],
      BYTE: [202],
      CALL: [202],
      CASE: [202],
      CONST: [202],
      DATE: [202],
      DECLARE: [202],
      DEFBOOL: [202],
      DEFBYTE: [202],
      DEFDATE: [202],
      DEFDBL: [202],
      DEFDEC: [202],
      DEFCUR: [202],
      DEFINT: [202],
      DEFLNG: [202],
      DEFOBJ: [202],
      DEFSNG: [202],
      DEFSTR: [202],
      DEFVAR: [202],
      DIM: [202],
      DO: [202],
      DOUBLE: [202],
      EACH: [202],
      ELSE: [202],
      ELSEIF: [202],
      END_ENUM: [202],
      END_FUNCTION: [202],
      END_IF: [202],
      END_PROPERTY: [202],
      END_SELECT: [202],
      END_SUB: [202],
      END_TYPE: [202],
      END_WITH: [202],
      END: [202],
      ENUM: [202],
      EQV: [202],
      ERASE: [202],
      EVENT: [202],
      EXIT_DO: [202],
      EXIT_FOR: [202],
      EXIT_FUNCTION: [202],
      EXIT_PROPERTY: [202],
      EXIT_SUB: [202],
      FALSE: [202],
      FRIEND: [202],
      FOR: [202],
      FUNCTION: [202],
      GET: [202],
      GLOBAL: [202],
      GOSUB: [202],
      GOTO: [202],
      IF: [202],
      IMPLEMENTS: [202],
      IN: [202],
      ISNOT: [202],
      IS: [202],
      INTEGER: [202],
      LONG: [202],
      LOOP: [202],
      LEN: [202],
      LET: [202],
      LIB: [202],
      LIKE: [202],
      LSET: [202],
      MACRO_CONST: [202],
      MACRO_IF: [202],
      MACRO_ELSEIF: [202],
      MACRO_ELSE: [202],
      MACRO_END_IF: [202],
      MOD: [202],
      NEXT: [202],
      NEW: [202],
      NOT: [202],
      NOTHING: [202],
      NULL: [202],
      ON_ERROR: [202],
      ON_LOCAL_ERROR: [202],
      ON: [202],
      OPTION_BASE: [202],
      OPTION_EXPLICIT: [202],
      OPTION_COMPARE: [202],
      OPTION_PRIVATE_MODULE: [202],
      OR: [202],
      PRESERVE: [202],
      PRIVATE: [202],
      PROPERTY_GET: [202],
      PROPERTY_LET: [202],
      PROPERTY_SET: [202],
      PTRSAFE: [202],
      PUBLIC: [202],
      RAISEEVENT: [202],
      REDIM: [202],
      RESET: [202],
      RESUME: [202],
      RETURN: [202],
      SELECT: [202],
      SET: [202],
      SINGLE: [202],
      STATIC: [202],
      STEP: [202],
      STOP: [202],
      STRING: [202],
      SUB: [202],
      THEN: [202],
      TO: [202],
      TRUE: [202],
      TYPEOF: [202],
      UNTIL: [202],
      VARIANT: [202],
      WEND: [202],
      WHILE: [202],
      WITH: [202],
      WITHEVENTS: [202],
      XOR: [202],
      IMP: [202],
      IDENTIFIER: [202],
    },
    argDefaultValue: {
      EQ: [203],
    },
    asTypeClause: {
      AS: [204],
    },
    type__group_def_82: {
      BOOLEAN: [205],
      BYTE: [205],
      DOUBLE: [205],
      INTEGER: [205],
      LONG: [205],
      SINGLE: [205],
      VARIANT: [205],
      STRING: [205],
      DATE: [205],
    },
    type__group_81: {
      BOOLEAN: [206, 208],
      BYTE: [206, 208],
      DOUBLE: [206, 208],
      INTEGER: [206, 208],
      LONG: [206, 208],
      SINGLE: [206, 208],
      VARIANT: [206, 208],
      STRING: [206, 208],
      DATE: [206, 208],
      ALIAS: [208],
      AND: [208],
      ATTRIBUTE: [208],
      AS: [208],
      BEGIN: [208],
      BYVAL: [208],
      BYREF: [208],
      CALL: [208],
      CASE: [208],
      CONST: [208],
      DECLARE: [208],
      DEFBOOL: [208],
      DEFBYTE: [208],
      DEFDATE: [208],
      DEFDBL: [208],
      DEFDEC: [208],
      DEFCUR: [208],
      DEFINT: [208],
      DEFLNG: [208],
      DEFOBJ: [208],
      DEFSNG: [208],
      DEFSTR: [208],
      DEFVAR: [208],
      DIM: [208],
      DO: [208],
      EACH: [208],
      ELSE: [208],
      ELSEIF: [208],
      END_ENUM: [208],
      END_FUNCTION: [208],
      END_IF: [208],
      END_PROPERTY: [208],
      END_SELECT: [208],
      END_SUB: [208],
      END_TYPE: [208],
      END_WITH: [208],
      END: [208],
      ENUM: [208],
      EQV: [208],
      ERASE: [208],
      EVENT: [208],
      EXIT_DO: [208],
      EXIT_FOR: [208],
      EXIT_FUNCTION: [208],
      EXIT_PROPERTY: [208],
      EXIT_SUB: [208],
      FALSE: [208],
      FRIEND: [208],
      FOR: [208],
      FUNCTION: [208],
      GET: [208],
      GLOBAL: [208],
      GOSUB: [208],
      GOTO: [208],
      IF: [208],
      IMPLEMENTS: [208],
      IN: [208],
      ISNOT: [208],
      IS: [208],
      LOOP: [208],
      LEN: [208],
      LET: [208],
      LIB: [208],
      LIKE: [208],
      LSET: [208],
      MACRO_CONST: [208],
      MACRO_IF: [208],
      MACRO_ELSEIF: [208],
      MACRO_ELSE: [208],
      MACRO_END_IF: [208],
      MOD: [208],
      NEXT: [208],
      NEW: [208],
      NOT: [208],
      NOTHING: [208],
      NULL: [208],
      ON_ERROR: [208],
      ON_LOCAL_ERROR: [208],
      ON: [208],
      OPTIONAL: [208],
      OPTION_BASE: [208],
      OPTION_EXPLICIT: [208],
      OPTION_COMPARE: [208],
      OPTION_PRIVATE_MODULE: [208],
      OR: [208],
      PARAMARRAY: [208],
      PRESERVE: [208],
      PRIVATE: [208],
      PROPERTY_GET: [208],
      PROPERTY_LET: [208],
      PROPERTY_SET: [208],
      PTRSAFE: [208],
      PUBLIC: [208],
      RAISEEVENT: [208],
      REDIM: [208],
      RESET: [208],
      RESUME: [208],
      RETURN: [208],
      SELECT: [208],
      SET: [208],
      STATIC: [208],
      STEP: [208],
      STOP: [208],
      SUB: [208],
      THEN: [208],
      TO: [208],
      TRUE: [208],
      TYPEOF: [208],
      UNTIL: [208],
      WEND: [208],
      WHILE: [208],
      WITH: [208],
      WITHEVENTS: [208],
      XOR: [208],
      IMP: [208],
      IDENTIFIER: [208],
    },
    type__group_def_83: {
      ALIAS: [207],
      AND: [207],
      ATTRIBUTE: [207],
      AS: [207],
      BEGIN: [207],
      BOOLEAN: [207],
      BYVAL: [207],
      BYREF: [207],
      BYTE: [207],
      CALL: [207],
      CASE: [207],
      CONST: [207],
      DATE: [207],
      DECLARE: [207],
      DEFBOOL: [207],
      DEFBYTE: [207],
      DEFDATE: [207],
      DEFDBL: [207],
      DEFDEC: [207],
      DEFCUR: [207],
      DEFINT: [207],
      DEFLNG: [207],
      DEFOBJ: [207],
      DEFSNG: [207],
      DEFSTR: [207],
      DEFVAR: [207],
      DIM: [207],
      DO: [207],
      DOUBLE: [207],
      EACH: [207],
      ELSE: [207],
      ELSEIF: [207],
      END_ENUM: [207],
      END_FUNCTION: [207],
      END_IF: [207],
      END_PROPERTY: [207],
      END_SELECT: [207],
      END_SUB: [207],
      END_TYPE: [207],
      END_WITH: [207],
      END: [207],
      ENUM: [207],
      EQV: [207],
      ERASE: [207],
      EVENT: [207],
      EXIT_DO: [207],
      EXIT_FOR: [207],
      EXIT_FUNCTION: [207],
      EXIT_PROPERTY: [207],
      EXIT_SUB: [207],
      FALSE: [207],
      FRIEND: [207],
      FOR: [207],
      FUNCTION: [207],
      GET: [207],
      GLOBAL: [207],
      GOSUB: [207],
      GOTO: [207],
      IF: [207],
      IMPLEMENTS: [207],
      IN: [207],
      ISNOT: [207],
      IS: [207],
      INTEGER: [207],
      LONG: [207],
      LOOP: [207],
      LEN: [207],
      LET: [207],
      LIB: [207],
      LIKE: [207],
      LSET: [207],
      MACRO_CONST: [207],
      MACRO_IF: [207],
      MACRO_ELSEIF: [207],
      MACRO_ELSE: [207],
      MACRO_END_IF: [207],
      MOD: [207],
      NEXT: [207],
      NEW: [207],
      NOT: [207],
      NOTHING: [207],
      NULL: [207],
      ON_ERROR: [207],
      ON_LOCAL_ERROR: [207],
      ON: [207],
      OPTIONAL: [207],
      OPTION_BASE: [207],
      OPTION_EXPLICIT: [207],
      OPTION_COMPARE: [207],
      OPTION_PRIVATE_MODULE: [207],
      OR: [207],
      PARAMARRAY: [207],
      PRESERVE: [207],
      PRIVATE: [207],
      PROPERTY_GET: [207],
      PROPERTY_LET: [207],
      PROPERTY_SET: [207],
      PTRSAFE: [207],
      PUBLIC: [207],
      RAISEEVENT: [207],
      REDIM: [207],
      RESET: [207],
      RESUME: [207],
      RETURN: [207],
      SELECT: [207],
      SET: [207],
      SINGLE: [207],
      STATIC: [207],
      STEP: [207],
      STOP: [207],
      STRING: [207],
      SUB: [207],
      THEN: [207],
      TO: [207],
      TRUE: [207],
      TYPEOF: [207],
      UNTIL: [207],
      VARIANT: [207],
      WEND: [207],
      WHILE: [207],
      WITH: [207],
      WITHEVENTS: [207],
      XOR: [207],
      IMP: [207],
      IDENTIFIER: [207],
    },
    type_: {
      BOOLEAN: [209],
      BYTE: [209],
      DOUBLE: [209],
      INTEGER: [209],
      LONG: [209],
      SINGLE: [209],
      VARIANT: [209],
      STRING: [209],
      DATE: [209],
      ALIAS: [209],
      AND: [209],
      ATTRIBUTE: [209],
      AS: [209],
      BEGIN: [209],
      BYVAL: [209],
      BYREF: [209],
      CALL: [209],
      CASE: [209],
      CONST: [209],
      DECLARE: [209],
      DEFBOOL: [209],
      DEFBYTE: [209],
      DEFDATE: [209],
      DEFDBL: [209],
      DEFDEC: [209],
      DEFCUR: [209],
      DEFINT: [209],
      DEFLNG: [209],
      DEFOBJ: [209],
      DEFSNG: [209],
      DEFSTR: [209],
      DEFVAR: [209],
      DIM: [209],
      DO: [209],
      EACH: [209],
      ELSE: [209],
      ELSEIF: [209],
      END_ENUM: [209],
      END_FUNCTION: [209],
      END_IF: [209],
      END_PROPERTY: [209],
      END_SELECT: [209],
      END_SUB: [209],
      END_TYPE: [209],
      END_WITH: [209],
      END: [209],
      ENUM: [209],
      EQV: [209],
      ERASE: [209],
      EVENT: [209],
      EXIT_DO: [209],
      EXIT_FOR: [209],
      EXIT_FUNCTION: [209],
      EXIT_PROPERTY: [209],
      EXIT_SUB: [209],
      FALSE: [209],
      FRIEND: [209],
      FOR: [209],
      FUNCTION: [209],
      GET: [209],
      GLOBAL: [209],
      GOSUB: [209],
      GOTO: [209],
      IF: [209],
      IMPLEMENTS: [209],
      IN: [209],
      ISNOT: [209],
      IS: [209],
      LOOP: [209],
      LEN: [209],
      LET: [209],
      LIB: [209],
      LIKE: [209],
      LSET: [209],
      MACRO_CONST: [209],
      MACRO_IF: [209],
      MACRO_ELSEIF: [209],
      MACRO_ELSE: [209],
      MACRO_END_IF: [209],
      MOD: [209],
      NEXT: [209],
      NEW: [209],
      NOT: [209],
      NOTHING: [209],
      NULL: [209],
      ON_ERROR: [209],
      ON_LOCAL_ERROR: [209],
      ON: [209],
      OPTIONAL: [209],
      OPTION_BASE: [209],
      OPTION_EXPLICIT: [209],
      OPTION_COMPARE: [209],
      OPTION_PRIVATE_MODULE: [209],
      OR: [209],
      PARAMARRAY: [209],
      PRESERVE: [209],
      PRIVATE: [209],
      PROPERTY_GET: [209],
      PROPERTY_LET: [209],
      PROPERTY_SET: [209],
      PTRSAFE: [209],
      PUBLIC: [209],
      RAISEEVENT: [209],
      REDIM: [209],
      RESET: [209],
      RESUME: [209],
      RETURN: [209],
      SELECT: [209],
      SET: [209],
      STATIC: [209],
      STEP: [209],
      STOP: [209],
      SUB: [209],
      THEN: [209],
      TO: [209],
      TRUE: [209],
      TYPEOF: [209],
      UNTIL: [209],
      WEND: [209],
      WHILE: [209],
      WITH: [209],
      WITHEVENTS: [209],
      XOR: [209],
      IMP: [209],
      IDENTIFIER: [209],
    },
    complexType_group_def_87: {
      '.': [210],
    },
    complexType_group_86: {
      '.': [211],
      '!': [213],
    },
    complexType_group_def_88: {
      '!': [212],
    },
    complexType_group_def_89: {
      '.': [214],
      '!': [214],
    },
    complexType: {
      ALIAS: [215],
      AND: [215],
      ATTRIBUTE: [215],
      AS: [215],
      BEGIN: [215],
      BOOLEAN: [215],
      BYVAL: [215],
      BYREF: [215],
      BYTE: [215],
      CALL: [215],
      CASE: [215],
      CONST: [215],
      DATE: [215],
      DECLARE: [215],
      DEFBOOL: [215],
      DEFBYTE: [215],
      DEFDATE: [215],
      DEFDBL: [215],
      DEFDEC: [215],
      DEFCUR: [215],
      DEFINT: [215],
      DEFLNG: [215],
      DEFOBJ: [215],
      DEFSNG: [215],
      DEFSTR: [215],
      DEFVAR: [215],
      DIM: [215],
      DO: [215],
      DOUBLE: [215],
      EACH: [215],
      ELSE: [215],
      ELSEIF: [215],
      END_ENUM: [215],
      END_FUNCTION: [215],
      END_IF: [215],
      END_PROPERTY: [215],
      END_SELECT: [215],
      END_SUB: [215],
      END_TYPE: [215],
      END_WITH: [215],
      END: [215],
      ENUM: [215],
      EQV: [215],
      ERASE: [215],
      EVENT: [215],
      EXIT_DO: [215],
      EXIT_FOR: [215],
      EXIT_FUNCTION: [215],
      EXIT_PROPERTY: [215],
      EXIT_SUB: [215],
      FALSE: [215],
      FRIEND: [215],
      FOR: [215],
      FUNCTION: [215],
      GET: [215],
      GLOBAL: [215],
      GOSUB: [215],
      GOTO: [215],
      IF: [215],
      IMPLEMENTS: [215],
      IN: [215],
      ISNOT: [215],
      IS: [215],
      INTEGER: [215],
      LONG: [215],
      LOOP: [215],
      LEN: [215],
      LET: [215],
      LIB: [215],
      LIKE: [215],
      LSET: [215],
      MACRO_CONST: [215],
      MACRO_IF: [215],
      MACRO_ELSEIF: [215],
      MACRO_ELSE: [215],
      MACRO_END_IF: [215],
      MOD: [215],
      NEXT: [215],
      NEW: [215],
      NOT: [215],
      NOTHING: [215],
      NULL: [215],
      ON_ERROR: [215],
      ON_LOCAL_ERROR: [215],
      ON: [215],
      OPTIONAL: [215],
      OPTION_BASE: [215],
      OPTION_EXPLICIT: [215],
      OPTION_COMPARE: [215],
      OPTION_PRIVATE_MODULE: [215],
      OR: [215],
      PARAMARRAY: [215],
      PRESERVE: [215],
      PRIVATE: [215],
      PROPERTY_GET: [215],
      PROPERTY_LET: [215],
      PROPERTY_SET: [215],
      PTRSAFE: [215],
      PUBLIC: [215],
      RAISEEVENT: [215],
      REDIM: [215],
      RESET: [215],
      RESUME: [215],
      RETURN: [215],
      SELECT: [215],
      SET: [215],
      SINGLE: [215],
      STATIC: [215],
      STEP: [215],
      STOP: [215],
      STRING: [215],
      SUB: [215],
      THEN: [215],
      TO: [215],
      TRUE: [215],
      TYPEOF: [215],
      UNTIL: [215],
      VARIANT: [215],
      WEND: [215],
      WHILE: [215],
      WITH: [215],
      WITHEVENTS: [215],
      XOR: [215],
      IMP: [215],
      IDENTIFIER: [215],
    },
    baseType: {
      BOOLEAN: [216],
      BYTE: [217],
      DOUBLE: [218],
      INTEGER: [219],
      LONG: [220],
      SINGLE: [221],
      VARIANT: [222],
      STRING: [223],
      DATE: [224],
    },
    fieldLength: {
      MULT: [225, 226],
    },
    ambiguousIdentifier: {
      ALIAS: [227],
      AND: [228],
      ATTRIBUTE: [229],
      AS: [230],
      BEGIN: [231],
      BOOLEAN: [232],
      BYVAL: [233],
      BYREF: [234],
      BYTE: [235],
      CALL: [236],
      CASE: [237],
      CONST: [238],
      DATE: [239],
      DECLARE: [240],
      DEFBOOL: [241],
      DEFBYTE: [242],
      DEFDATE: [243],
      DEFDBL: [244],
      DEFDEC: [245],
      DEFCUR: [246],
      DEFINT: [247],
      DEFLNG: [248],
      DEFOBJ: [249],
      DEFSNG: [250],
      DEFSTR: [251],
      DEFVAR: [252],
      DIM: [253],
      DO: [254],
      DOUBLE: [255],
      EACH: [256],
      ELSE: [257],
      ELSEIF: [258],
      END_ENUM: [259],
      END_FUNCTION: [260],
      END_IF: [261],
      END_PROPERTY: [262],
      END_SELECT: [263],
      END_SUB: [264],
      END_TYPE: [265],
      END_WITH: [266],
      END: [267],
      ENUM: [268],
      EQV: [269],
      ERASE: [270],
      EVENT: [271],
      EXIT_DO: [272],
      EXIT_FOR: [273],
      EXIT_FUNCTION: [274],
      EXIT_PROPERTY: [275],
      EXIT_SUB: [276],
      FALSE: [277],
      FRIEND: [278],
      FOR: [279],
      FUNCTION: [280],
      GET: [281],
      GLOBAL: [282],
      GOSUB: [283],
      GOTO: [284],
      IF: [285],
      IMPLEMENTS: [286],
      IN: [287],
      ISNOT: [288],
      IS: [289],
      INTEGER: [290],
      LONG: [291],
      LOOP: [292],
      LEN: [293],
      LET: [294],
      LIB: [295],
      LIKE: [296],
      LSET: [297],
      MACRO_CONST: [298],
      MACRO_IF: [299],
      MACRO_ELSEIF: [300],
      MACRO_ELSE: [301],
      MACRO_END_IF: [302],
      MOD: [303],
      NEXT: [304],
      NEW: [305],
      NOT: [306],
      NOTHING: [307],
      NULL: [308],
      ON_ERROR: [309],
      ON_LOCAL_ERROR: [310],
      ON: [311],
      OPTIONAL: [312],
      OPTION_BASE: [313],
      OPTION_EXPLICIT: [314],
      OPTION_COMPARE: [315],
      OPTION_PRIVATE_MODULE: [316],
      OR: [317],
      PARAMARRAY: [318],
      PRESERVE: [319],
      PRIVATE: [320],
      PROPERTY_GET: [321],
      PROPERTY_LET: [322],
      PROPERTY_SET: [323],
      PTRSAFE: [324],
      PUBLIC: [325],
      RAISEEVENT: [326],
      REDIM: [327],
      RESET: [328],
      RESUME: [329],
      RETURN: [330],
      SELECT: [331],
      SET: [332],
      SINGLE: [333],
      STATIC: [334],
      STEP: [335],
      STOP: [336],
      STRING: [337],
      SUB: [338],
      THEN: [339],
      TO: [340],
      TRUE: [341],
      TYPEOF: [342],
      UNTIL: [343],
      VARIANT: [344],
      WEND: [345],
      WHILE: [346],
      WITH: [347],
      WITHEVENTS: [348],
      XOR: [349],
      IMP: [350],
      IDENTIFIER: [352],
    },
    certainIdentifier: {
      IDENTIFIER: [351],
    },
    valueStmt: {
      DOUBLELITERAL: [353],
      INTEGERLITERAL: [353],
      STRINGLITERAL: [353],
      NOTHING: [353],
      NULL: [353],
      TRUE: [353],
      FALSE: [353],
      DATELITERAL: [353],
      SPACE_DOT: [353],
      ALIAS: [353],
      AND: [353],
      ATTRIBUTE: [353],
      AS: [353],
      BEGIN: [353],
      BOOLEAN: [353],
      BYVAL: [353],
      BYREF: [353],
      BYTE: [353],
      CALL: [353],
      CASE: [353],
      CONST: [353],
      DATE: [353],
      DECLARE: [353],
      DEFBOOL: [353],
      DEFBYTE: [353],
      DEFDATE: [353],
      DEFDBL: [353],
      DEFDEC: [353],
      DEFCUR: [353],
      DEFINT: [353],
      DEFLNG: [353],
      DEFOBJ: [353],
      DEFSNG: [353],
      DEFSTR: [353],
      DEFVAR: [353],
      DIM: [353],
      DO: [353],
      DOUBLE: [353],
      EACH: [353],
      ELSE: [353],
      ELSEIF: [353],
      END_ENUM: [353],
      END_FUNCTION: [353],
      END_IF: [353],
      END_PROPERTY: [353],
      END_SELECT: [353],
      END_SUB: [353],
      END_TYPE: [353],
      END_WITH: [353],
      END: [353],
      ENUM: [353],
      EQV: [353],
      ERASE: [353],
      EVENT: [353],
      EXIT_DO: [353],
      EXIT_FOR: [353],
      EXIT_FUNCTION: [353],
      EXIT_PROPERTY: [353],
      EXIT_SUB: [353],
      FRIEND: [353],
      FOR: [353],
      FUNCTION: [353],
      GET: [353],
      GLOBAL: [353],
      GOSUB: [353],
      GOTO: [353],
      IF: [353],
      IMPLEMENTS: [353],
      IN: [353],
      ISNOT: [353],
      IS: [353],
      INTEGER: [353],
      LONG: [353],
      LOOP: [353],
      LEN: [353],
      LET: [353],
      LIB: [353],
      LIKE: [353],
      LSET: [353],
      MACRO_CONST: [353],
      MACRO_IF: [353],
      MACRO_ELSEIF: [353],
      MACRO_ELSE: [353],
      MACRO_END_IF: [353],
      MOD: [353],
      NEXT: [353],
      NEW: [353],
      NOT: [353, 354],
      ON_ERROR: [353],
      ON_LOCAL_ERROR: [353],
      ON: [353],
      OPTIONAL: [353],
      OPTION_BASE: [353],
      OPTION_EXPLICIT: [353],
      OPTION_COMPARE: [353],
      OPTION_PRIVATE_MODULE: [353],
      OR: [353],
      PARAMARRAY: [353],
      PRESERVE: [353],
      PRIVATE: [353],
      PROPERTY_GET: [353],
      PROPERTY_LET: [353],
      PROPERTY_SET: [353],
      PTRSAFE: [353],
      PUBLIC: [353],
      RAISEEVENT: [353],
      REDIM: [353],
      RESET: [353],
      RESUME: [353],
      RETURN: [353],
      SELECT: [353],
      SET: [353],
      SINGLE: [353],
      STATIC: [353],
      STEP: [353],
      STOP: [353],
      STRING: [353],
      SUB: [353],
      THEN: [353],
      TO: [353],
      TYPEOF: [353],
      UNTIL: [353],
      VARIANT: [353],
      WEND: [353],
      WHILE: [353],
      WITH: [353],
      WITHEVENTS: [353],
      XOR: [353],
      IMP: [353],
      IDENTIFIER: [353],
      LPAREN: [353],
      MINUS: [353],
      PLUS: [353],
    },
    '(valueStmt_p_2)1_': {
      IS: [355, 382],
      ISNOT: [357, 382],
      GEQ: [358, 382],
      LEQ: [359, 382],
      GT: [360, 382],
      LT: [361, 382],
      NEQ: [362, 382],
      EQ: [363, 382],
      NEWLINE: [382],
      COMMENT: [382],
      REMCOMMENT: [382],
      COLON: [382],
      ELSE: [382],
      STEP: [382],
      THEN: [382],
      ',': [382],
      TO: [382],
      RPAREN: [382],
      '!': [382],
      LPAREN: [382],
      POW: [382],
      MULT: [382],
      DIV: [382],
      IDIV: [382],
      MOD: [382],
      PLUS: [382],
      MINUS: [382],
      AMPERSAND: [382],
      XOR: [382],
      OR: [382],
      AND: [382],
    },
    valueStmt_p_2: {
      DOUBLELITERAL: [356],
      INTEGERLITERAL: [356],
      STRINGLITERAL: [356],
      NOTHING: [356],
      NULL: [356],
      TRUE: [356],
      FALSE: [356],
      DATELITERAL: [356],
      SPACE_DOT: [356],
      ALIAS: [356],
      AND: [356],
      ATTRIBUTE: [356],
      AS: [356],
      BEGIN: [356],
      BOOLEAN: [356],
      BYVAL: [356],
      BYREF: [356],
      BYTE: [356],
      CALL: [356],
      CASE: [356],
      CONST: [356],
      DATE: [356],
      DECLARE: [356],
      DEFBOOL: [356],
      DEFBYTE: [356],
      DEFDATE: [356],
      DEFDBL: [356],
      DEFDEC: [356],
      DEFCUR: [356],
      DEFINT: [356],
      DEFLNG: [356],
      DEFOBJ: [356],
      DEFSNG: [356],
      DEFSTR: [356],
      DEFVAR: [356],
      DIM: [356],
      DO: [356],
      DOUBLE: [356],
      EACH: [356],
      ELSE: [356],
      ELSEIF: [356],
      END_ENUM: [356],
      END_FUNCTION: [356],
      END_IF: [356],
      END_PROPERTY: [356],
      END_SELECT: [356],
      END_SUB: [356],
      END_TYPE: [356],
      END_WITH: [356],
      END: [356],
      ENUM: [356],
      EQV: [356],
      ERASE: [356],
      EVENT: [356],
      EXIT_DO: [356],
      EXIT_FOR: [356],
      EXIT_FUNCTION: [356],
      EXIT_PROPERTY: [356],
      EXIT_SUB: [356],
      FRIEND: [356],
      FOR: [356],
      FUNCTION: [356],
      GET: [356],
      GLOBAL: [356],
      GOSUB: [356],
      GOTO: [356],
      IF: [356],
      IMPLEMENTS: [356],
      IN: [356],
      ISNOT: [356],
      IS: [356],
      INTEGER: [356],
      LONG: [356],
      LOOP: [356],
      LEN: [356],
      LET: [356],
      LIB: [356],
      LIKE: [356],
      LSET: [356],
      MACRO_CONST: [356],
      MACRO_IF: [356],
      MACRO_ELSEIF: [356],
      MACRO_ELSE: [356],
      MACRO_END_IF: [356],
      MOD: [356],
      NEXT: [356],
      NEW: [356],
      NOT: [356],
      ON_ERROR: [356],
      ON_LOCAL_ERROR: [356],
      ON: [356],
      OPTIONAL: [356],
      OPTION_BASE: [356],
      OPTION_EXPLICIT: [356],
      OPTION_COMPARE: [356],
      OPTION_PRIVATE_MODULE: [356],
      OR: [356],
      PARAMARRAY: [356],
      PRESERVE: [356],
      PRIVATE: [356],
      PROPERTY_GET: [356],
      PROPERTY_LET: [356],
      PROPERTY_SET: [356],
      PTRSAFE: [356],
      PUBLIC: [356],
      RAISEEVENT: [356],
      REDIM: [356],
      RESET: [356],
      RESUME: [356],
      RETURN: [356],
      SELECT: [356],
      SET: [356],
      SINGLE: [356],
      STATIC: [356],
      STEP: [356],
      STOP: [356],
      STRING: [356],
      SUB: [356],
      THEN: [356],
      TO: [356],
      TYPEOF: [356],
      UNTIL: [356],
      VARIANT: [356],
      WEND: [356],
      WHILE: [356],
      WITH: [356],
      WITHEVENTS: [356],
      XOR: [356],
      IMP: [356],
      IDENTIFIER: [356],
      LPAREN: [356],
      MINUS: [356],
      PLUS: [356],
    },
    '(valueStmt_p_3)1_': {
      XOR: [364, 383],
      OR: [366, 383],
      AND: [367, 383],
      IS: [383],
      ISNOT: [383],
      GEQ: [383],
      LEQ: [383],
      GT: [383],
      LT: [383],
      NEQ: [383],
      EQ: [383],
      NEWLINE: [383],
      COMMENT: [383],
      REMCOMMENT: [383],
      COLON: [383],
      ELSE: [383],
      STEP: [383],
      THEN: [383],
      ',': [383],
      TO: [383],
      RPAREN: [383],
      '!': [383],
      LPAREN: [383],
      POW: [383],
      MULT: [383],
      DIV: [383],
      IDIV: [383],
      MOD: [383],
      PLUS: [383],
      MINUS: [383],
      AMPERSAND: [383],
    },
    valueStmt_p_3: {
      DOUBLELITERAL: [365],
      INTEGERLITERAL: [365],
      STRINGLITERAL: [365],
      NOTHING: [365],
      NULL: [365],
      TRUE: [365],
      FALSE: [365],
      DATELITERAL: [365],
      SPACE_DOT: [365],
      ALIAS: [365],
      AND: [365],
      ATTRIBUTE: [365],
      AS: [365],
      BEGIN: [365],
      BOOLEAN: [365],
      BYVAL: [365],
      BYREF: [365],
      BYTE: [365],
      CALL: [365],
      CASE: [365],
      CONST: [365],
      DATE: [365],
      DECLARE: [365],
      DEFBOOL: [365],
      DEFBYTE: [365],
      DEFDATE: [365],
      DEFDBL: [365],
      DEFDEC: [365],
      DEFCUR: [365],
      DEFINT: [365],
      DEFLNG: [365],
      DEFOBJ: [365],
      DEFSNG: [365],
      DEFSTR: [365],
      DEFVAR: [365],
      DIM: [365],
      DO: [365],
      DOUBLE: [365],
      EACH: [365],
      ELSE: [365],
      ELSEIF: [365],
      END_ENUM: [365],
      END_FUNCTION: [365],
      END_IF: [365],
      END_PROPERTY: [365],
      END_SELECT: [365],
      END_SUB: [365],
      END_TYPE: [365],
      END_WITH: [365],
      END: [365],
      ENUM: [365],
      EQV: [365],
      ERASE: [365],
      EVENT: [365],
      EXIT_DO: [365],
      EXIT_FOR: [365],
      EXIT_FUNCTION: [365],
      EXIT_PROPERTY: [365],
      EXIT_SUB: [365],
      FRIEND: [365],
      FOR: [365],
      FUNCTION: [365],
      GET: [365],
      GLOBAL: [365],
      GOSUB: [365],
      GOTO: [365],
      IF: [365],
      IMPLEMENTS: [365],
      IN: [365],
      ISNOT: [365],
      IS: [365],
      INTEGER: [365],
      LONG: [365],
      LOOP: [365],
      LEN: [365],
      LET: [365],
      LIB: [365],
      LIKE: [365],
      LSET: [365],
      MACRO_CONST: [365],
      MACRO_IF: [365],
      MACRO_ELSEIF: [365],
      MACRO_ELSE: [365],
      MACRO_END_IF: [365],
      MOD: [365],
      NEXT: [365],
      NEW: [365],
      NOT: [365],
      ON_ERROR: [365],
      ON_LOCAL_ERROR: [365],
      ON: [365],
      OPTIONAL: [365],
      OPTION_BASE: [365],
      OPTION_EXPLICIT: [365],
      OPTION_COMPARE: [365],
      OPTION_PRIVATE_MODULE: [365],
      OR: [365],
      PARAMARRAY: [365],
      PRESERVE: [365],
      PRIVATE: [365],
      PROPERTY_GET: [365],
      PROPERTY_LET: [365],
      PROPERTY_SET: [365],
      PTRSAFE: [365],
      PUBLIC: [365],
      RAISEEVENT: [365],
      REDIM: [365],
      RESET: [365],
      RESUME: [365],
      RETURN: [365],
      SELECT: [365],
      SET: [365],
      SINGLE: [365],
      STATIC: [365],
      STEP: [365],
      STOP: [365],
      STRING: [365],
      SUB: [365],
      THEN: [365],
      TO: [365],
      TYPEOF: [365],
      UNTIL: [365],
      VARIANT: [365],
      WEND: [365],
      WHILE: [365],
      WITH: [365],
      WITHEVENTS: [365],
      XOR: [365],
      IMP: [365],
      IDENTIFIER: [365],
      LPAREN: [365],
      MINUS: [365],
      PLUS: [365],
    },
    '(valueStmt_p_4)1_': {
      PLUS: [368, 384],
      MINUS: [370, 384],
      AMPERSAND: [371, 384],
      XOR: [384],
      OR: [384],
      AND: [384],
      IS: [384],
      ISNOT: [384],
      GEQ: [384],
      LEQ: [384],
      GT: [384],
      LT: [384],
      NEQ: [384],
      EQ: [384],
      NEWLINE: [384],
      COMMENT: [384],
      REMCOMMENT: [384],
      COLON: [384],
      ELSE: [384],
      STEP: [384],
      THEN: [384],
      ',': [384],
      TO: [384],
      RPAREN: [384],
      '!': [384],
      LPAREN: [384],
      POW: [384],
      MULT: [384],
      DIV: [384],
      IDIV: [384],
      MOD: [384],
    },
    valueStmt_p_4: {
      DOUBLELITERAL: [369],
      INTEGERLITERAL: [369],
      STRINGLITERAL: [369],
      NOTHING: [369],
      NULL: [369],
      TRUE: [369],
      FALSE: [369],
      DATELITERAL: [369],
      SPACE_DOT: [369],
      ALIAS: [369],
      AND: [369],
      ATTRIBUTE: [369],
      AS: [369],
      BEGIN: [369],
      BOOLEAN: [369],
      BYVAL: [369],
      BYREF: [369],
      BYTE: [369],
      CALL: [369],
      CASE: [369],
      CONST: [369],
      DATE: [369],
      DECLARE: [369],
      DEFBOOL: [369],
      DEFBYTE: [369],
      DEFDATE: [369],
      DEFDBL: [369],
      DEFDEC: [369],
      DEFCUR: [369],
      DEFINT: [369],
      DEFLNG: [369],
      DEFOBJ: [369],
      DEFSNG: [369],
      DEFSTR: [369],
      DEFVAR: [369],
      DIM: [369],
      DO: [369],
      DOUBLE: [369],
      EACH: [369],
      ELSE: [369],
      ELSEIF: [369],
      END_ENUM: [369],
      END_FUNCTION: [369],
      END_IF: [369],
      END_PROPERTY: [369],
      END_SELECT: [369],
      END_SUB: [369],
      END_TYPE: [369],
      END_WITH: [369],
      END: [369],
      ENUM: [369],
      EQV: [369],
      ERASE: [369],
      EVENT: [369],
      EXIT_DO: [369],
      EXIT_FOR: [369],
      EXIT_FUNCTION: [369],
      EXIT_PROPERTY: [369],
      EXIT_SUB: [369],
      FRIEND: [369],
      FOR: [369],
      FUNCTION: [369],
      GET: [369],
      GLOBAL: [369],
      GOSUB: [369],
      GOTO: [369],
      IF: [369],
      IMPLEMENTS: [369],
      IN: [369],
      ISNOT: [369],
      IS: [369],
      INTEGER: [369],
      LONG: [369],
      LOOP: [369],
      LEN: [369],
      LET: [369],
      LIB: [369],
      LIKE: [369],
      LSET: [369],
      MACRO_CONST: [369],
      MACRO_IF: [369],
      MACRO_ELSEIF: [369],
      MACRO_ELSE: [369],
      MACRO_END_IF: [369],
      MOD: [369],
      NEXT: [369],
      NEW: [369],
      NOT: [369],
      ON_ERROR: [369],
      ON_LOCAL_ERROR: [369],
      ON: [369],
      OPTIONAL: [369],
      OPTION_BASE: [369],
      OPTION_EXPLICIT: [369],
      OPTION_COMPARE: [369],
      OPTION_PRIVATE_MODULE: [369],
      OR: [369],
      PARAMARRAY: [369],
      PRESERVE: [369],
      PRIVATE: [369],
      PROPERTY_GET: [369],
      PROPERTY_LET: [369],
      PROPERTY_SET: [369],
      PTRSAFE: [369],
      PUBLIC: [369],
      RAISEEVENT: [369],
      REDIM: [369],
      RESET: [369],
      RESUME: [369],
      RETURN: [369],
      SELECT: [369],
      SET: [369],
      SINGLE: [369],
      STATIC: [369],
      STEP: [369],
      STOP: [369],
      STRING: [369],
      SUB: [369],
      THEN: [369],
      TO: [369],
      TYPEOF: [369],
      UNTIL: [369],
      VARIANT: [369],
      WEND: [369],
      WHILE: [369],
      WITH: [369],
      WITHEVENTS: [369],
      XOR: [369],
      IMP: [369],
      IDENTIFIER: [369],
      LPAREN: [369],
      MINUS: [369],
      PLUS: [369],
    },
    '(valueStmt_p_5)1_': {
      MULT: [372, 385],
      DIV: [374, 385],
      IDIV: [375, 385],
      MOD: [376, 385],
      PLUS: [385],
      MINUS: [385],
      AMPERSAND: [385],
      XOR: [385],
      OR: [385],
      AND: [385],
      IS: [385],
      ISNOT: [385],
      GEQ: [385],
      LEQ: [385],
      GT: [385],
      LT: [385],
      NEQ: [385],
      EQ: [385],
      NEWLINE: [385],
      COMMENT: [385],
      REMCOMMENT: [385],
      COLON: [385],
      ELSE: [385],
      STEP: [385],
      THEN: [385],
      ',': [385],
      TO: [385],
      RPAREN: [385],
      '!': [385],
      LPAREN: [385],
      POW: [385],
    },
    valueStmt_p_5: {
      DOUBLELITERAL: [373],
      INTEGERLITERAL: [373],
      STRINGLITERAL: [373],
      NOTHING: [373],
      NULL: [373],
      TRUE: [373],
      FALSE: [373],
      DATELITERAL: [373],
      SPACE_DOT: [373],
      ALIAS: [373],
      AND: [373],
      ATTRIBUTE: [373],
      AS: [373],
      BEGIN: [373],
      BOOLEAN: [373],
      BYVAL: [373],
      BYREF: [373],
      BYTE: [373],
      CALL: [373],
      CASE: [373],
      CONST: [373],
      DATE: [373],
      DECLARE: [373],
      DEFBOOL: [373],
      DEFBYTE: [373],
      DEFDATE: [373],
      DEFDBL: [373],
      DEFDEC: [373],
      DEFCUR: [373],
      DEFINT: [373],
      DEFLNG: [373],
      DEFOBJ: [373],
      DEFSNG: [373],
      DEFSTR: [373],
      DEFVAR: [373],
      DIM: [373],
      DO: [373],
      DOUBLE: [373],
      EACH: [373],
      ELSE: [373],
      ELSEIF: [373],
      END_ENUM: [373],
      END_FUNCTION: [373],
      END_IF: [373],
      END_PROPERTY: [373],
      END_SELECT: [373],
      END_SUB: [373],
      END_TYPE: [373],
      END_WITH: [373],
      END: [373],
      ENUM: [373],
      EQV: [373],
      ERASE: [373],
      EVENT: [373],
      EXIT_DO: [373],
      EXIT_FOR: [373],
      EXIT_FUNCTION: [373],
      EXIT_PROPERTY: [373],
      EXIT_SUB: [373],
      FRIEND: [373],
      FOR: [373],
      FUNCTION: [373],
      GET: [373],
      GLOBAL: [373],
      GOSUB: [373],
      GOTO: [373],
      IF: [373],
      IMPLEMENTS: [373],
      IN: [373],
      ISNOT: [373],
      IS: [373],
      INTEGER: [373],
      LONG: [373],
      LOOP: [373],
      LEN: [373],
      LET: [373],
      LIB: [373],
      LIKE: [373],
      LSET: [373],
      MACRO_CONST: [373],
      MACRO_IF: [373],
      MACRO_ELSEIF: [373],
      MACRO_ELSE: [373],
      MACRO_END_IF: [373],
      MOD: [373],
      NEXT: [373],
      NEW: [373],
      NOT: [373],
      ON_ERROR: [373],
      ON_LOCAL_ERROR: [373],
      ON: [373],
      OPTIONAL: [373],
      OPTION_BASE: [373],
      OPTION_EXPLICIT: [373],
      OPTION_COMPARE: [373],
      OPTION_PRIVATE_MODULE: [373],
      OR: [373],
      PARAMARRAY: [373],
      PRESERVE: [373],
      PRIVATE: [373],
      PROPERTY_GET: [373],
      PROPERTY_LET: [373],
      PROPERTY_SET: [373],
      PTRSAFE: [373],
      PUBLIC: [373],
      RAISEEVENT: [373],
      REDIM: [373],
      RESET: [373],
      RESUME: [373],
      RETURN: [373],
      SELECT: [373],
      SET: [373],
      SINGLE: [373],
      STATIC: [373],
      STEP: [373],
      STOP: [373],
      STRING: [373],
      SUB: [373],
      THEN: [373],
      TO: [373],
      TYPEOF: [373],
      UNTIL: [373],
      VARIANT: [373],
      WEND: [373],
      WHILE: [373],
      WITH: [373],
      WITHEVENTS: [373],
      XOR: [373],
      IMP: [373],
      IDENTIFIER: [373],
      LPAREN: [373],
      MINUS: [373],
      PLUS: [373],
    },
    '(valueStmt_p_6)1_': {
      POW: [377, 386],
      MULT: [386],
      DIV: [386],
      IDIV: [386],
      MOD: [386],
      PLUS: [386],
      MINUS: [386],
      AMPERSAND: [386],
      XOR: [386],
      OR: [386],
      AND: [386],
      IS: [386],
      ISNOT: [386],
      GEQ: [386],
      LEQ: [386],
      GT: [386],
      LT: [386],
      NEQ: [386],
      EQ: [386],
      NEWLINE: [386],
      COMMENT: [386],
      REMCOMMENT: [386],
      COLON: [386],
      ELSE: [386],
      STEP: [386],
      THEN: [386],
      ',': [386],
      TO: [386],
      RPAREN: [386],
      '!': [386],
      LPAREN: [386],
    },
    valueStmt_p_6: {
      DOUBLELITERAL: [378],
      INTEGERLITERAL: [378],
      STRINGLITERAL: [378],
      NOTHING: [378],
      NULL: [378],
      TRUE: [378],
      FALSE: [378],
      DATELITERAL: [378],
      SPACE_DOT: [378],
      ALIAS: [378],
      AND: [378],
      ATTRIBUTE: [378],
      AS: [378],
      BEGIN: [378],
      BOOLEAN: [378],
      BYVAL: [378],
      BYREF: [378],
      BYTE: [378],
      CALL: [378],
      CASE: [378],
      CONST: [378],
      DATE: [378],
      DECLARE: [378],
      DEFBOOL: [378],
      DEFBYTE: [378],
      DEFDATE: [378],
      DEFDBL: [378],
      DEFDEC: [378],
      DEFCUR: [378],
      DEFINT: [378],
      DEFLNG: [378],
      DEFOBJ: [378],
      DEFSNG: [378],
      DEFSTR: [378],
      DEFVAR: [378],
      DIM: [378],
      DO: [378],
      DOUBLE: [378],
      EACH: [378],
      ELSE: [378],
      ELSEIF: [378],
      END_ENUM: [378],
      END_FUNCTION: [378],
      END_IF: [378],
      END_PROPERTY: [378],
      END_SELECT: [378],
      END_SUB: [378],
      END_TYPE: [378],
      END_WITH: [378],
      END: [378],
      ENUM: [378],
      EQV: [378],
      ERASE: [378],
      EVENT: [378],
      EXIT_DO: [378],
      EXIT_FOR: [378],
      EXIT_FUNCTION: [378],
      EXIT_PROPERTY: [378],
      EXIT_SUB: [378],
      FRIEND: [378],
      FOR: [378],
      FUNCTION: [378],
      GET: [378],
      GLOBAL: [378],
      GOSUB: [378],
      GOTO: [378],
      IF: [378],
      IMPLEMENTS: [378],
      IN: [378],
      ISNOT: [378],
      IS: [378],
      INTEGER: [378],
      LONG: [378],
      LOOP: [378],
      LEN: [378],
      LET: [378],
      LIB: [378],
      LIKE: [378],
      LSET: [378],
      MACRO_CONST: [378],
      MACRO_IF: [378],
      MACRO_ELSEIF: [378],
      MACRO_ELSE: [378],
      MACRO_END_IF: [378],
      MOD: [378],
      NEXT: [378],
      NEW: [378],
      NOT: [378],
      ON_ERROR: [378],
      ON_LOCAL_ERROR: [378],
      ON: [378],
      OPTIONAL: [378],
      OPTION_BASE: [378],
      OPTION_EXPLICIT: [378],
      OPTION_COMPARE: [378],
      OPTION_PRIVATE_MODULE: [378],
      OR: [378],
      PARAMARRAY: [378],
      PRESERVE: [378],
      PRIVATE: [378],
      PROPERTY_GET: [378],
      PROPERTY_LET: [378],
      PROPERTY_SET: [378],
      PTRSAFE: [378],
      PUBLIC: [378],
      RAISEEVENT: [378],
      REDIM: [378],
      RESET: [378],
      RESUME: [378],
      RETURN: [378],
      SELECT: [378],
      SET: [378],
      SINGLE: [378],
      STATIC: [378],
      STEP: [378],
      STOP: [378],
      STRING: [378],
      SUB: [378],
      THEN: [378],
      TO: [378],
      TYPEOF: [378],
      UNTIL: [378],
      VARIANT: [378],
      WEND: [378],
      WHILE: [378],
      WITH: [378],
      WITHEVENTS: [378],
      XOR: [378],
      IMP: [378],
      IDENTIFIER: [378],
      LPAREN: [378],
      MINUS: [378],
      PLUS: [378],
    },
    valueStmt_p_7: {
      DOUBLELITERAL: [379],
      INTEGERLITERAL: [379],
      STRINGLITERAL: [379],
      NOTHING: [379],
      NULL: [379],
      TRUE: [379],
      FALSE: [379],
      DATELITERAL: [379],
      SPACE_DOT: [379],
      ALIAS: [379],
      AND: [379],
      ATTRIBUTE: [379],
      AS: [379],
      BEGIN: [379],
      BOOLEAN: [379],
      BYVAL: [379],
      BYREF: [379],
      BYTE: [379],
      CALL: [379],
      CASE: [379],
      CONST: [379],
      DATE: [379],
      DECLARE: [379],
      DEFBOOL: [379],
      DEFBYTE: [379],
      DEFDATE: [379],
      DEFDBL: [379],
      DEFDEC: [379],
      DEFCUR: [379],
      DEFINT: [379],
      DEFLNG: [379],
      DEFOBJ: [379],
      DEFSNG: [379],
      DEFSTR: [379],
      DEFVAR: [379],
      DIM: [379],
      DO: [379],
      DOUBLE: [379],
      EACH: [379],
      ELSE: [379],
      ELSEIF: [379],
      END_ENUM: [379],
      END_FUNCTION: [379],
      END_IF: [379],
      END_PROPERTY: [379],
      END_SELECT: [379],
      END_SUB: [379],
      END_TYPE: [379],
      END_WITH: [379],
      END: [379],
      ENUM: [379],
      EQV: [379],
      ERASE: [379],
      EVENT: [379],
      EXIT_DO: [379],
      EXIT_FOR: [379],
      EXIT_FUNCTION: [379],
      EXIT_PROPERTY: [379],
      EXIT_SUB: [379],
      FRIEND: [379],
      FOR: [379],
      FUNCTION: [379],
      GET: [379],
      GLOBAL: [379],
      GOSUB: [379],
      GOTO: [379],
      IF: [379],
      IMPLEMENTS: [379],
      IN: [379],
      ISNOT: [379],
      IS: [379],
      INTEGER: [379],
      LONG: [379],
      LOOP: [379],
      LEN: [379],
      LET: [379],
      LIB: [379],
      LIKE: [379],
      LSET: [379],
      MACRO_CONST: [379],
      MACRO_IF: [379],
      MACRO_ELSEIF: [379],
      MACRO_ELSE: [379],
      MACRO_END_IF: [379],
      MOD: [379],
      NEXT: [379],
      NEW: [379],
      NOT: [379],
      ON_ERROR: [379],
      ON_LOCAL_ERROR: [379],
      ON: [379],
      OPTIONAL: [379],
      OPTION_BASE: [379],
      OPTION_EXPLICIT: [379],
      OPTION_COMPARE: [379],
      OPTION_PRIVATE_MODULE: [379],
      OR: [379],
      PARAMARRAY: [379],
      PRESERVE: [379],
      PRIVATE: [379],
      PROPERTY_GET: [379],
      PROPERTY_LET: [379],
      PROPERTY_SET: [379],
      PTRSAFE: [379],
      PUBLIC: [379],
      RAISEEVENT: [379],
      REDIM: [379],
      RESET: [379],
      RESUME: [379],
      RETURN: [379],
      SELECT: [379],
      SET: [379],
      SINGLE: [379],
      STATIC: [379],
      STEP: [379],
      STOP: [379],
      STRING: [379],
      SUB: [379],
      THEN: [379],
      TO: [379],
      TYPEOF: [379],
      UNTIL: [379],
      VARIANT: [379],
      WEND: [379],
      WHILE: [379],
      WITH: [379],
      WITHEVENTS: [379],
      XOR: [379],
      IMP: [379],
      IDENTIFIER: [379],
      LPAREN: [379],
      MINUS: [380],
      PLUS: [381],
    },
  };
  var parse = function (input, options = {}) {
    prepareLLParse();
    let recoveryTokens = [];
    const terminalNodes = [];
    let error;
    var {
      getProductionIsWrap,
      productions,
      getProductionSymbol,
      getProductionRhs,
      getProductionLabel,
    } = parser;
    var {
      globalMatch = true,
      onErrorRecovery,
      lexerOptions = {},
      transformNode,
      parseTree = true,
      startSymbol = getProductionSymbol(productions[0]),
    } = options;
    startSymbol = lexer.mapSymbol(startSymbol);

    if (transformNode !== false && !transformNode) {
      transformNode = defaultTransformAstNode;
    }

    lexer.options = lexerOptions;
    symbolStack = [startSymbol];
    lexer.resetInput(input);
    let token = undefined;
    let next = null;
    let topSymbol;
    let errorNode;

    function peekSymbolStack(n = 1) {
      let index = symbolStack.length - n;
      let currentSymbolItem = symbolStack[index];

      while (
        currentSymbolItem &&
        typeof currentSymbolItem === 'object' &&
        currentSymbolItem.type === 'rule'
      ) {
        index--;
        currentSymbolItem = symbolStack[index];
      }

      return symbolStack[index];
    }

    function popSymbolStack() {
      while (true) {
        const t = symbolStack.pop();

        if (!t || typeof t !== 'object' || t.type !== 'rule') {
          break;
        }
      }

      let l = symbolStack.length - 1;
      let current = symbolStack[l];

      while (
        current &&
        typeof current === 'object' &&
        current.type === 'rule'
      ) {
        symbolStack.pop();
        current = symbolStack[--l];
      }
    }

    let getExpected = function () {
      const s = topSymbol;

      if (typeof s === 'string' && !isSymbol(s)) {
        return [lexer.mapReverseSymbol(s)];
      } // get expected tokens from state machine

      return findExpectedTokenFromStateMachine(findSymbolIndex()).map((s) =>
        lexer.mapReverseSymbol(s),
      );
    };

    function makeRuleIndexFlag(ruleIndex, ruleUnit) {
      return {
        type: 'rule',
        ruleUnit,
        tokensLength: lexer.getTokensLength(),
        ruleIndex,
      };
    }

    function findSymbolIndex() {
      let i = -1;
      let top = symbolStack.length - 1;
      let ruleIndex = -1;

      while (top >= 0 && symbolStack[top] !== topSymbol) {
        top--;
      }

      let current = symbolStack[top];

      while (
        current &&
        (typeof current !== 'object' || current.type !== 'rule')
      ) {
        if (typeof current === 'string') {
          i++;
        }

        top--;
        current = symbolStack[top];
      }

      if (current && typeof current === 'object' && current.type === 'rule') {
        ruleIndex = current.ruleIndex;
      }

      return {
        childReverseIndex: i,
        ruleIndex,
        topSymbol,
      };
    }

    let production;

    while (1) {
      topSymbol = peekSymbolStack();

      if (!topSymbol) {
        break;
      }

      topSymbol = reduceLLAction(
        parseTree,
        topSymbol,
        popSymbolStack,
        peekSymbolStack,
      );

      if (typeof topSymbol === 'string') {
        if (!token) {
          token = lexer.lex();
          pushRecoveryTokens(recoveryTokens, token);
        }

        const normalizedSymbol = normalizeSymbol(topSymbol);
        next = null;

        if (isSymbol(normalizedSymbol)) {
          next = predictProductionIndexLLK(globalMatch, findSymbolIndex());
        } else if (
          normalizedSymbol === token.t ||
          normalizedSymbol === `$ANY`
        ) {
          if (!isZeroOrMoreSymbol(topSymbol)) {
            popSymbolStack();
          }

          const terminalNode = new AstTokenNode(token);
          terminalNodes.push(terminalNode);
          const parent = peekStack(astStack);
          parent.addChild(terminalNode);
          token = lexer.lex();
          pushRecoveryTokens(recoveryTokens, token);
          continue;
        } else if (
          isZeroOrMoreSymbol(topSymbol) ||
          isOptionalSymbol(topSymbol)
        ) {
          next = {
            ruleIndex: VIRTUAL_OPTIONAL_RULE_INDEX,
          };
        }

        if (next && next.unit) {
          if (!isZeroOrMoreSymbol(topSymbol)) {
            popSymbolStack();
          }

          const { ruleIndex, unit } = next;
          production = productions[ruleIndex];

          if (
            productionSkipAstNodeSet !== null &&
            productionSkipAstNodeSet !== void 0 &&
            productionSkipAstNodeSet.has(ruleIndex)
          ) {
            const newRhs = getLabeledRhsForAddNodeFlag(production, [
              ...getProductionRhs(production),
              makeRuleIndexFlag(ruleIndex, unit),
            ]);
            symbolStack.push.apply(symbolStack, newRhs.reverse());
          } else {
            const label = getOriginalSymbol(getProductionLabel(production));
            const isWrap = getProductionIsWrap(production);

            if (parseTree) {
              const newAst = new AstSymbolNode({
                internalRuleIndex: ruleIndex,
                id: ++globalSymbolNodeId,
                symbol: getOriginalSymbol(normalizeSymbol(topSymbol)),
                label,
                isWrap,
                children: [],
              });
              peekStack(astStack).addChild(newAst);
              astStack.push(newAst);
            }

            const newRhs = [
              ...getProductionRhs(production),
              makeRuleIndexFlag(ruleIndex, unit),
              productionEndFlag,
            ].reverse();
            symbolStack.push(...newRhs);
          }
        } else if (
          next &&
          (isZeroOrMoreSymbol(topSymbol) || isOptionalSymbol(topSymbol))
        ) {
          popSymbolStack();
        } else {
          let breakToEnd;
          ({ error, errorNode, token, breakToEnd } = takeCareLLError(
            parseTree,
            getExpected,
            onErrorRecovery,
            topSymbol,
            () =>
              !!predictProductionIndexNextLLK(globalMatch, findSymbolIndex()),
            transformNode,
            recoveryTokens,
            {
              error,
              errorNode,
              token,
            },
          ));

          if (breakToEnd) {
            break;
          }
        }
      }

      topSymbol = takeCareLLAction(popSymbolStack, peekSymbolStack);

      if (!symbolStack.length) {
        break;
      }
    }

    ({ error, errorNode } = checkLLEndError(parseTree, getExpected, {
      error,
      errorNode,
    }));
    const ast = parseTree ? getAstRootNode(astStack, transformNode) : null;
    endLLParse();
    return {
      ast,
      tokens: lexer.tokens,
      recoveryTokens,
      errorNode,
      error,
      terminalNodes,
    };
  };
  var predictProductionIndexLLK = function (
    // expensive
    globalMatch,
    { childReverseIndex, ruleIndex, topSymbol },
    fn,
  ) {
    let unit;
    let lastUnit;
    let endState;
    let symbolEndState;

    if (ruleIndex === -1) {
      lastUnit = unit = getUnitBySymbol(topSymbol);
    } else {
      let parentSymbolItem = getParentSymbolItem();

      if (!parentSymbolItem) {
        throw new Error('no parent symbol');
      }

      const parentUnit = parentSymbolItem.ruleUnit;
      const { units } = parentUnit;
      unit = units[units.length - 1 - childReverseIndex];
      lastUnit = units[units.length - 1];
    }

    const childSymbol = unit.type;

    if (!isSymbol(unit.type)) {
      return null;
    }

    const { unitType } = unit;
    lexer.stash();

    if (fn) {
      fn();
    }

    const getSkipCheckStates = (unit) => {
      const u = unit;
      let states = u.checkStates;

      if (!states) {
        const skipStartState = new State(
          'startOfSkip$' + childSymbol,
          null,
          VIRTUAL_OPTIONAL_RULE_INDEX,
        );
        skipStartState.pushTransition(unit.end);
        const symbolUnit = new SymbolStateUnit(childSymbol, -2);
        symbolUnit.end.pushTransition(unit.end);
        u.checkStates = states = {
          state: skipStartState,
          unit: symbolUnit,
        };
      }

      return [states.state, ...states.unit.start.getAlternativeStartStates()];
    };

    let nextUnits;
    let startState;

    function returnNext(ruleIndex) {
      lexer.stashPop();

      if (ruleIndex === undefined) {
        return null;
      }

      if (ruleIndex === VIRTUAL_OPTIONAL_RULE_INDEX) {
        return {
          ruleIndex,
        };
      }

      const nextUnit = nextUnits[ruleIndex];
      return {
        ruleIndex,
        unit: nextUnit,
      };
    }

    if (unit.lazy) {
      let states = getSkipCheckStates(unit);
      endState = lastUnit.end;
      symbolEndState = unit.end;
      const ruleIndexes = findBestAlternation(
        false,
        childSymbol,
        states,
        globalMatch ? null : endState,
        symbolEndState,
      );

      if (!ruleIndexes.length) {
        return returnNext();
      } else if (ruleIndexes[0] === VIRTUAL_OPTIONAL_RULE_INDEX) {
        // skip this symbol first
        return returnNext(VIRTUAL_OPTIONAL_RULE_INDEX);
      } else {
        startState = unit.start.transitions[0].to;

        if (startState.classType !== 'SymbolState') {
          throw new Error('expect SymbolState!');
        }

        nextUnits = startState.getUnits();
        return returnNext(Array.from(ruleIndexes.values())[0]);
      }
    }

    const canSkipped = unitType === 'zeroOrMore' || unitType === 'optional';
    let startStates = [];

    if (canSkipped) {
      startState = unit.start.transitions[0].to;

      if (startState.classType !== 'SymbolState') {
        throw new Error('expect SymbolState!');
      }

      nextUnits = startState.getUnits();
      startStates = getSkipCheckStates(unit);
      endState = lastUnit.end;
      symbolEndState = unit.end;
    } else {
      const alternatives = productionsBySymbol[childSymbol];
      startState = unit.start;

      if (startState.classType !== 'SymbolState') {
        throw new Error('expect SymbolState!');
      }

      nextUnits = startState.getUnits();

      if (alternatives.ruleIndexes.length <= 1) {
        const ruleIndex = alternatives.ruleIndexes[0];

        if (ruleIndex === undefined) {
          throw new Error('no predict!');
        }

        return returnNext(ruleIndex);
      }

      startStates = startState.getAlternativeStartStates();

      if (startStates.length === 1) {
        return returnNext(startStates[0].ruleIndex);
      }

      endState = lastUnit.end;
      symbolEndState = unit.end;
    }

    const ruleIndexes = findBestAlternation(
      false,
      childSymbol,
      startStates,
      globalMatch ? null : endState,
      symbolEndState,
    );

    if (ruleIndexes[0] === VIRTUAL_OPTIONAL_RULE_INDEX) {
      ruleIndexes.shift();

      if (!ruleIndexes.length) {
        return returnNext(VIRTUAL_OPTIONAL_RULE_INDEX);
      }
    }

    if (ruleIndexes.length) {
      return returnNext(ruleIndexes[0]);
    }

    return returnNext();
  };
  var predictProductionIndexNextLLK = function (globalMatch, arg) {
    return predictProductionIndexLLK(globalMatch, arg, () => lexer.lex());
  };
  var RootSymbolUnit = class RootSymbolUnit {
    units = [];
    start = null;
    end = null;
    lazy = false;
    unitType = 'rootSymbol';

    constructor(type, ruleIndex) {
      this.type = type;
      this.ruleIndex = ruleIndex;
    }
  };
  var State = class State {
    classType = 'State';
    transitions = [];

    constructor(type, unit, ruleIndex) {
      this.type = type;
      this.unit = unit;
      this.ruleIndex = ruleIndex;
      this.transitions = [];
    }

    getTransitionsToMatch() {
      return this.transitions;
    }

    pushTransition(endState, condition) {
      this.transitions.push(new Transition(endState, condition));
    }
  };
  var StateUnit = class StateUnit {
    units = undefined;
    unitType = 'token';
    lazy = false;

    constructor(type, ruleIndex) {
      this.type = type;
      this.ruleIndex = ruleIndex;
      this.start = new State(`startOf${type}`, this, ruleIndex);
      this.end = new State(`endOf${type}`, this, ruleIndex);
    }
  };
  var SymbolState = class SymbolState {
    classType = 'SymbolState';
    startStates = {};
    units = {};
    _afterTransitions = [];
    indexedTransitions = {};

    constructor(symbol, type, unit, ruleIndex) {
      this.symbol = symbol;
      this.type = type;
      this.unit = unit;
      this.ruleIndex = ruleIndex;
    }

    get transitions() {
      let transitions = this.alltransitions;
      const { indexedTransitions } = this;

      if (!transitions) {
        const { symbol, unit, startStates, units } = this;
        this.alltransitions = transitions = [];
        const myProductions = productionsBySymbol[symbol];

        if (!myProductions) {
          throw new Error('unexpected productionsBySymbol: ' + symbol);
        }

        for (const i of myProductions.ruleIndexes) {
          const p = myProductions.productions[i];
          const rhs = parser.getProductionRhs(p);
          const rootSymbolUnit = buildRhsSM(symbol, rhs, i);
          units[i] = rootSymbolUnit;
          startStates[i] = rootSymbolUnit.start;
          const t = new Transition(rootSymbolUnit.start);
          transitions.push(t);
          indexedTransitions[i] = t;
          rootSymbolUnit.end.pushTransition(unit.end);
        }

        this.alltransitions = transitions = [
          ...transitions,
          ...this._afterTransitions,
        ];
      }

      return transitions;
    }

    getTransitionsToMatch() {
      const { indexedTransitions, _afterTransitions } = this;
      const transitions = this.getNextRuleIndexes().map(
        (i) => indexedTransitions[i],
      );
      const ret = _afterTransitions.length
        ? transitions.concat(_afterTransitions)
        : transitions; // console.log(`optimize ${this.symbol} getTransitionsToMatch: from ${this.transitions.length} to ${ret.length}`);

      return ret;
    }

    getTransitions() {
      return this.transitions;
    }

    getUnits() {
      this.getTransitions();
      return this.units;
    }

    getNextRuleIndexes() {
      this.getTransitions();
      const t = lexer.getCurrentToken().t;
      const predictTable = parserPredictTable[this.symbol];
      const nextRuleIndexes = predictTable[t] || [];
      const ret = [];
      const { productions, getProductionPredict } = parser;

      for (const ruleIndex of nextRuleIndexes) {
        const production = productions[ruleIndex];
        const predict = getProductionPredict(production);

        if (!predict || predict.call(parser) !== false) {
          ret.push(ruleIndex);
        }
      }

      return ret;
    }

    getAlternativeStartStates() {
      const nextRuleIndexes = this.getNextRuleIndexes();
      let startStates = nextRuleIndexes.map(
        (ruleIndex) => this.startStates[ruleIndex],
      ); // console.log(`optimize ${this.symbol} getAlternativeStartStates: from ${Object.keys(this.startStates).length} to ${startStates.length}`);

      return startStates;
    }

    pushTransition(endState, condition) {
      this._afterTransitions.push(new Transition(endState, condition));
    }
  };
  var SymbolStateUnit = class SymbolStateUnit {
    unitType = 'symbol';
    lazy = false;

    constructor(type, ruleIndex) {
      this.type = type;
      this.ruleIndex = ruleIndex;
      this.end = new State(`endOf${type}`, this, ruleIndex);
      this.start = new SymbolState(type, `startOf${type}`, this, ruleIndex);
    }
  };
  var Transition = class Transition {
    constructor(to, condition) {
      this.to = to;
      this.condition = condition;
    }

    perform() {
      if (this.condition) {
        const ret = this.condition();

        if (ret === true) {
          return {
            count: 0,
          };
        }

        return ret;
      }

      return {
        count: 0,
      };
    }
  };
  var buildRhsSM = function (symbol, rhs, ruleIndex) {
    function getUnit(rr) {
      if (isSymbol(rr)) {
        return new SymbolStateUnit(rr, ruleIndex);
      }

      const unit = new StateUnit(rr, ruleIndex);
      unit.start.pushTransition(unit.end, createTokenMatcher(rr));
      return unit;
    }

    const units = [];

    for (const r of rhs) {
      if (typeof r !== 'string') {
        continue;
      }

      let finalUnit;

      if (isOptionalSymbol(r)) {
        const rr = normalizeSymbol(r);
        const unit = getUnit(rr);
        finalUnit = new StateUnit(rr, ruleIndex);
        finalUnit.unitType = 'optional';

        if (isLazySymbol(r)) {
          finalUnit.lazy = true;
        }

        finalUnit.start.pushTransition(unit.start);
        finalUnit.start.pushTransition(finalUnit.end);
        unit.end.pushTransition(finalUnit.end);
      } else if (isZeroOrMoreSymbol(r)) {
        const rr = normalizeSymbol(r);
        const unit = getUnit(rr);
        finalUnit = new StateUnit(rr, ruleIndex);
        finalUnit.unitType = 'zeroOrMore';

        if (isLazySymbol(r)) {
          finalUnit.lazy = true;
        }

        finalUnit.start.pushTransition(unit.start);
        unit.start.pushTransition(finalUnit.end);
        unit.end.pushTransition(unit.start);
      } else {
        finalUnit = getUnit(r);
      }

      units.push(finalUnit);
    }

    return concatUnits(symbol, units, ruleIndex);
  };
  var concatUnits = function (type, us, ruleIndex) {
    const l = us.length;

    for (let i = 0; i < l - 1; i++) {
      const first = us[i];
      const s = us[i + 1];
      first.end.pushTransition(s.start);
    }

    const ret = new RootSymbolUnit(type, ruleIndex);

    if (us[0] && us[l - 1]) {
      ret.start = us[0].start;
      ret.end = us[l - 1].end;
    } else {
      ret.start = new State(`startOf${type}`, ret, ruleIndex);
      ret.end = new State(`endOf${type}`, ret, ruleIndex);
      ret.start.pushTransition(ret.end);
    }

    ret.units = us;
    return ret;
  };
  var findExpectedTokenFromStateMachine = function (
    { childReverseIndex },
    stack = new Set(),
  ) {
    const ret = new Set();
    const { ruleUnit: parentUnit } = getParentSymbolItem();
    const { units } = parentUnit;
    let unit = units[units.length - 1 - childReverseIndex];
    const states = [unit.start];

    while (states.length) {
      const state = states.pop();

      if (stack.has(state)) {
        continue;
      }

      stack.add(state);

      for (const t of state.transitions) {
        var _t$condition;

        if (
          (_t$condition = t.condition) !== null &&
          _t$condition !== void 0 &&
          _t$condition.token
        ) {
          ret.add(t.condition.token);
          continue;
        }

        if (t.to) {
          states.push(t.to);
        }
      }
    }

    return Array.from(ret);
  };
  var getParentSymbolItem = function () {
    let parentSymbolItem;

    for (let i = symbolStack.length - 1; i >= 0; i--) {
      const s = symbolStack[i];

      if ((s === null || s === void 0 ? void 0 : s.type) === 'rule') {
        parentSymbolItem = s;
        break;
      }
    }

    return parentSymbolItem;
  };
  var getUnitBySymbol = function (symbol) {
    if (!smUnitBySymbol[symbol]) {
      smUnitBySymbol[symbol] = new SymbolStateUnit(symbol, -1);
    }

    return smUnitBySymbol[symbol];
  };
  var isSymbol = function (s) {
    return !!productionsBySymbol[s];
  };
  var findBestAlternation = function (
    strict,
    _forSymbol,
    states,
    endState,
    symbolEndState,
  ) {
    // const start = Date.now();
    let reachableStates = [];

    for (const state of states) {
      reachableStates.push({
        state,
        ruleIndexes: [state.ruleIndex],
      });
    }

    let consumedTokensLength = new Map(); //const times = [];

    let count = 0;
    const finishedTokens = new Set();

    while (1) {
      //const start = Date.now();
      reachableStates = getNextReachableStateItems(
        reachableStates,
        consumedTokensLength,
        endState,
        count,
        symbolEndState,
        finishedTokens,
      );

      if (
        reachableStates.length === 1 &&
        !finishedTokens.has(VIRTUAL_OPTIONAL_RULE_INDEX)
      ) {
        if (
          !finishedTokens.size ||
          (finishedTokens.size === 1 &&
            consumedTokensLength.get(Array.from(finishedTokens.keys())[0]) ===
              0)
        ) {
          const rule = reachableStates[0].ruleIndexes[0];
          finishedTokens.add(rule);
          consumedTokensLength.set(rule, count + 1);
          break;
        }
      } //times.push(Date.now() - start);

      if (reachableStates.length) {
        ++count;
        lexer.lex();
      } else {
        break;
      }
    }

    let arr = Array.from(finishedTokens.keys());

    if (!strict && !arr.length) {
      // deep go to error branch
      arr = Array.from(consumedTokensLength.keys());
    }

    if (arr.length > 1) {
      const getOrder = (a) => {
        return consumedTokensLength.get(a) || count;
      };

      if (consumedTokensLength.has(VIRTUAL_OPTIONAL_RULE_INDEX)) {
        consumedTokensLength.set(VIRTUAL_OPTIONAL_RULE_INDEX, 0xffff);
      }

      arr = arr.sort((a, b) => {
        const ret = getOrder(b) - getOrder(a);

        if (ret === 0) {
          return a - b;
        }

        return ret;
      });
    } // const time=0
    // const time = Date.now() - start;
    // console.log(_forSymbol + ' findBestAlternation: ' + time);
    // for (const a of arr) {
    //   if (a === VIRTUAL_OPTIONAL_RULE_INDEX) {
    //     console.log(_forSymbol, ': skip');
    //   } else {
    //     console.log(_forSymbol, parser.productions[a][1])
    //   }
    // }
    // console.log('');

    return arr;
  };
  var getNextReachableStateItems = function (
    reachableStates,
    consumedTokensLength,
    endState,
    count,
    symbolEndState,
    finishedTokens,
  ) {
    // function last<T>(arr: T[], n = 1) {
    //   return arr[arr.length - n];
    // }
    let stack = [];
    let newReachableStates = [];
    const encounteredMap = new Map();

    for (let i = 0; i < reachableStates.length; i++) {
      const currentState = reachableStates[i];

      if (!currentState) {
        continue;
      }

      stack.push(currentState);
      let stateItem;
      let state;
      let currentRuleIndexes = currentState.ruleIndexes;
      let encountered = encounteredMap.get(currentRuleIndexes[0]);

      if (!encountered) {
        encountered = new Set();
        encounteredMap.set(currentRuleIndexes[0], encountered);
      }

      while (stack.length) {
        stateItem = stack.shift();

        if (!stateItem) {
          continue;
        }

        state = stateItem.state;

        if (state === symbolEndState) {
          const rootIndex = stateItem.ruleIndexes[0];
          consumedTokensLength.set(rootIndex, count);
        }

        if (
          state === endState ||
          (!state.transitions.length &&
            lexer.getCurrentToken().token === Lexer.STATIC.EOF_TOKEN)
        ) {
          const rootIndex = stateItem.ruleIndexes[0];
          finishedTokens.add(rootIndex);
          continue;
        }

        if (encountered.has(state)) {
          continue;
        }

        encountered.add(state);
        currentRuleIndexes = stateItem.ruleIndexes;
        let finded;

        for (const t of state.getTransitionsToMatch()) {
          const find = t.perform();
          finded = finded || !!find;

          if (find) {
            let ruleIndexes = currentRuleIndexes; // const toRuleIndex = t.to.ruleIndex;
            // if (last(currentRuleIndexes) !== toRuleIndex) {
            //   ruleIndexes = [...ruleIndexes, toRuleIndex];
            // }

            if (find.count) {
              newReachableStates.push({
                state: t.to,
                ruleIndexes,
              });
            } else {
              stack.push({
                state: t.to,
                ruleIndexes,
              });
            }
          }
        }
      }
    }

    newReachableStates = newReachableStates.filter((n) => !!n);
    let current = newReachableStates[0];

    if (current && finishedTokens.size === 0) {
      let i = 1;

      for (i = 1; i < newReachableStates.length; i++) {
        let next = newReachableStates[i];

        if (next) {
          if (current.ruleIndexes[0] !== next.ruleIndexes[0]) {
            break;
          }

          current = next;
        }
      }

      if (current && i === newReachableStates.length) {
        const ruleIndex = current.ruleIndexes[0];
        finishedTokens.add(ruleIndex);
        consumedTokensLength.set(ruleIndex, count);
        return [];
      }
    }

    return newReachableStates;
  };
  var createTokenMatcher = (token) => {
    const fn = () => {
      const currentToken = lexer.getCurrentToken();
      return currentToken.t === token
        ? {
            count: 1,
          }
        : false;
    };

    fn.token = token;
    return fn;
  };
  var initLLK = function () {
    const { productions } = parser;

    for (let i = 0; i < productions.length; i++) {
      const p = productions[i];
      const symbol = parser.getProductionSymbol(p);
      const item = (productionsBySymbol[symbol] = productionsBySymbol[
        symbol
      ] || {
        ruleIndexes: [],
        productions: [],
      });
      item.productions[i] = p;
      item.ruleIndexes.push(i);
    }
  };
  initLLK();
  parser.parse = parse;
  var productionRuleIndexMap = {
    0: 1,
    1: 1,
    2: 2,
    3: 2,
    4: 2,
    5: 3,
    6: 3,
    7: 3,
    8: 3,
    9: 3,
    10: 4,
    11: 4,
    12: 5,
    13: 5,
    14: 5,
    15: 6,
    16: 6,
    17: 6,
    18: 6,
    19: 7,
    20: 7,
    21: 8,
    22: 8,
    23: 8,
    24: 8,
    25: 8,
    26: 9,
    27: 9,
    28: 9,
    29: 9,
    30: 10,
    31: 11,
    32: 12,
    33: 13,
    34: 14,
    35: 15,
    36: 15,
    37: 16,
    38: 16,
    39: 16,
    40: 16,
    41: 16,
    42: 16,
    43: 16,
    44: 16,
    45: 16,
    46: 16,
    47: 16,
    48: 16,
    49: 16,
    50: 16,
    51: 16,
    52: 16,
    53: 16,
    54: 16,
    55: 17,
    56: 18,
    57: 19,
    58: 19,
    59: 19,
    60: 19,
    61: 19,
    62: 20,
    63: 20,
    64: 20,
    65: 21,
    66: 21,
    67: 22,
    68: 23,
    69: 24,
    70: 25,
    71: 26,
    72: 27,
    73: 28,
    74: 29,
    75: 29,
    76: 30,
    77: 30,
    78: 30,
    79: 30,
    80: 30,
    81: 30,
    82: 30,
    83: 31,
    84: 31,
    85: 32,
    86: 33,
    87: 34,
    88: 35,
    89: 36,
    90: 36,
    91: 36,
    92: 36,
    93: 36,
    94: 37,
    95: 38,
    96: 39,
    97: 39,
    98: 40,
    99: 40,
    100: 41,
    101: 42,
    102: 42,
    103: 42,
    104: 42,
    105: 42,
    106: 42,
    107: 43,
    108: 43,
    109: 43,
    110: 43,
    111: 43,
    112: 43,
    113: 43,
    114: 44,
    115: 45,
    116: 45,
    117: 46,
    118: 46,
    119: 46,
    120: 46,
    121: 46,
    122: 46,
    123: 46,
    124: 47,
    125: 48,
    126: 48,
    127: 49,
    128: 50,
    129: 51,
    130: 51,
    131: 52,
    132: 53,
    133: 53,
    134: 53,
    135: 53,
    136: 53,
    137: 53,
    138: 53,
    139: 54,
    140: 54,
    141: 54,
    142: 54,
    143: 54,
    144: 55,
    145: 55,
    146: 56,
    147: 56,
    148: 57,
    149: 58,
    150: 58,
    151: 59,
    152: 59,
    153: 60,
    154: 61,
    155: 61,
    156: 61,
    157: 62,
    158: 62,
    159: 62,
    160: 62,
    161: 63,
    162: 86,
    163: 86,
    164: 86,
    165: 87,
    166: 87,
    167: 87,
    168: 87,
    169: 87,
    170: 87,
    171: 87,
    172: 87,
    173: 87,
    174: 88,
    175: 88,
    176: 88,
    177: 89,
    178: 89,
    179: 89,
    180: 90,
    181: 91,
    182: 92,
    183: 93,
    184: 93,
    185: 93,
    186: 93,
    187: 93,
    188: 93,
    189: 93,
    190: 93,
    191: 94,
    192: 94,
    193: 94,
    194: 94,
    195: 94,
    196: 94,
    197: 95,
    198: 95,
    199: 95,
    200: 95,
    201: 95,
    202: 95,
    203: 96,
    204: 97,
    205: 98,
    206: 98,
    207: 98,
    208: 98,
    209: 98,
    210: 99,
    211: 99,
    212: 99,
    213: 99,
    214: 99,
    215: 99,
    216: 100,
    217: 100,
    218: 100,
    219: 100,
    220: 100,
    221: 100,
    222: 100,
    223: 100,
    224: 100,
    225: 101,
    226: 101,
    227: 102,
    228: 103,
    229: 104,
    230: 105,
    231: 106,
    232: 107,
    233: 108,
    234: 109,
    235: 110,
    236: 111,
    237: 112,
    238: 113,
    239: 114,
    240: 115,
    241: 116,
    242: 117,
    243: 118,
    244: 119,
    245: 120,
    246: 121,
    247: 122,
    248: 123,
    249: 124,
    250: 125,
    251: 126,
    252: 127,
    253: 128,
    254: 129,
    255: 130,
    256: 131,
    257: 132,
    258: 133,
    259: 134,
    260: 135,
    261: 136,
    262: 137,
    263: 138,
    264: 139,
    265: 140,
    266: 141,
    267: 142,
    268: 143,
    269: 144,
    270: 145,
    271: 146,
    272: 147,
    273: 148,
    274: 149,
    275: 150,
    276: 151,
    277: 152,
    278: 153,
    279: 154,
    280: 155,
    281: 156,
    282: 157,
    283: 158,
    284: 159,
    285: 160,
    286: 161,
    287: 162,
    288: 163,
    289: 164,
    290: 165,
    291: 166,
    292: 167,
    293: 168,
    294: 169,
    295: 170,
    296: 171,
    297: 172,
    298: 173,
    299: 174,
    300: 175,
    301: 176,
    302: 177,
    303: 178,
    304: 179,
    305: 180,
    306: 181,
    307: 182,
    308: 183,
    309: 184,
    310: 185,
    311: 186,
    312: 187,
    313: 188,
    314: 189,
    315: 190,
    316: 191,
    317: 192,
    318: 193,
    319: 194,
    320: 195,
    321: 196,
    322: 197,
    323: 198,
    324: 199,
    325: 200,
    326: 201,
    327: 202,
    328: 203,
    329: 204,
    330: 205,
    331: 206,
    332: 207,
    333: 208,
    334: 209,
    335: 210,
    336: 211,
    337: 212,
    338: 213,
    339: 214,
    340: 215,
    341: 216,
    342: 217,
    343: 218,
    344: 219,
    345: 220,
    346: 221,
    347: 222,
    348: 223,
    349: 224,
    350: 225,
    351: 226,
    352: 227,
    353: 85,
    354: 85,
    355: 64,
    356: 64,
    357: 65,
    358: 66,
    359: 67,
    360: 68,
    361: 69,
    362: 70,
    363: 71,
    364: 72,
    365: 72,
    366: 73,
    367: 74,
    368: 75,
    369: 75,
    370: 76,
    371: 77,
    372: 78,
    373: 78,
    374: 79,
    375: 80,
    376: 81,
    377: 82,
    378: 82,
    379: 83,
    380: 83,
    381: 84,
  };
  return parser;
})();

export default vbaParser;
