/*
    Generated by kison.
  */
var cal = (function(undefined) {
  /* Generated by kison */
  var parser = {};
  /*jslint quotmark: false*/
  function mix(to, from) {
    for (var f in from) {
      to[f] = from[f];
    }
  }
  function isArray(obj) {
    return "[object Array]" === Object.prototype.toString.call(obj);
  }
  function each(object, fn, context) {
    if (object) {
      var key,
        val,
        length,
        i = 0;

      context = context || null;

      if (!isArray(object)) {
        for (key in object) {
          // can not use hasOwnProperty
          if (fn.call(context, object[key], key, object) === false) {
            break;
          }
        }
      } else {
        length = object.length;
        for (val = object[0]; i < length; val = object[++i]) {
          if (fn.call(context, val, i, object) === false) {
            break;
          }
        }
      }
    }
  }
  function inArray(item, arr) {
    for (var i = 0, l = arr.length; i < l; i++) {
      if (arr[i] === item) {
        return true;
      }
    }
    return false;
  }
  var Lexer = function Lexer(cfg) {
    var self = this;

    /*
     lex rules.
     @type {Object[]}
     @example
     [
     {
     regexp:'\\w+',
     state:['xx'],
     token:'c',
     // this => lex
     action:function(){}
     }
     ]
     */
    self.rules = [];

    mix(self, cfg);

    /*
     Input languages
     @type {String}
     */

    self.resetInput(self.input);
  };
  Lexer.prototype = {
    resetInput: function(input) {
      mix(this, {
        input: input,
        matched: "",
        stateStack: [Lexer.STATIC.INITIAL],
        match: "",
        text: "",
        firstLine: 1,
        lineNumber: 1,
        lastLine: 1,
        firstColumn: 1,
        lastColumn: 1
      });
    },
    mapEndSymbol: function() {
      return this.mapSymbol(Lexer.STATIC.END_TAG);
    },
    getCurrentRules: function() {
      var self = this,
        currentState = self.stateStack[self.stateStack.length - 1],
        rules = [];
      //#JSCOVERAGE_IF
      if (self.mapState) {
        currentState = self.mapState(currentState);
      }
      each(self.rules, function(r) {
        var state = r.state || r[3];
        if (!state) {
          if (currentState === Lexer.STATIC.INITIAL) {
            rules.push(r);
          }
        } else if (inArray(currentState, state)) {
          rules.push(r);
        }
      });
      return rules;
    },
    pushState: function(state) {
      this.stateStack.push(state);
    },
    popState: function(num) {
      num = num || 1;
      var ret;
      while (num--) {
        ret = this.stateStack.pop();
      }
      return ret;
    },
    showDebugInfo: function() {
      var self = this,
        DEBUG_CONTEXT_LIMIT = Lexer.STATIC.DEBUG_CONTEXT_LIMIT,
        matched = self.matched,
        match = self.match,
        input = self.input;
      matched = matched.slice(0, matched.length - match.length);
      //#JSCOVERAGE_IF 0
      var past =
          (matched.length > DEBUG_CONTEXT_LIMIT ? "..." : "") +
          matched.slice(0 - DEBUG_CONTEXT_LIMIT).replace(/\n/g, " "),
        next = match + input;
      //#JSCOVERAGE_ENDIF
      next =
        next.slice(0, DEBUG_CONTEXT_LIMIT).replace(/\n/g, " ") +
        (next.length > DEBUG_CONTEXT_LIMIT ? "..." : "");
      return past + next + "\n" + new Array(past.length + 1).join("-") + "^";
    },
    mapSymbol: function mapSymbolForCodeGen(t) {
      return this.symbolMap[t];
    },
    mapReverseSymbol: function(rs) {
      var self = this,
        symbolMap = self.symbolMap,
        i,
        reverseSymbolMap = self.reverseSymbolMap;
      if (!reverseSymbolMap && symbolMap) {
        reverseSymbolMap = self.reverseSymbolMap = {};
        for (i in symbolMap) {
          reverseSymbolMap[symbolMap[i]] = i;
        }
      }
      //#JSCOVERAGE_IF
      if (reverseSymbolMap) {
        return reverseSymbolMap[rs];
      } else {
        return rs;
      }
    },
    lex: function() {
      var self = this,
        input = self.input,
        i,
        rule,
        m,
        ret,
        lines,
        rules = self.getCurrentRules();

      self.match = self.text = "";

      if (!input) {
        return self.mapEndSymbol();
      }

      for (i = 0; i < rules.length; i++) {
        rule = rules[i];
        //#JSCOVERAGE_IF 0
        var regexp = rule.regexp || rule[1],
          token = rule.token || rule[0],
          action = rule.action || rule[2] || undefined;
        //#JSCOVERAGE_ENDIF
        if ((m = input.match(regexp))) {
          lines = m[0].match(/\n.*/g);
          if (lines) {
            self.lineNumber += lines.length;
          }
          mix(self, {
            firstLine: self.lastLine,
            lastLine: self.lineNumber,
            firstColumn: self.lastColumn,
            lastColumn: lines
              ? lines[lines.length - 1].length - 1
              : self.lastColumn + m[0].length
          });
          var match;
          // for error report
          match = self.match = m[0];

          // all matches
          self.matches = m;
          // may change by user
          self.text = match;
          // matched content utils now
          self.matched += match;
          ret = action && action.call(self);
          if (ret === undefined) {
            ret = token;
          } else {
            ret = self.mapSymbol(ret);
          }
          input = input.slice(match.length);
          self.input = input;

          if (ret) {
            self.token = self.mapReverseSymbol(ret);
            return ret;
          } else {
            // ignore
            return self.lex();
          }
        }
      }
    }
  };
  Lexer.STATIC = {
    INITIAL: "I",
    DEBUG_CONTEXT_LIMIT: 20,
    END_TAG: "$EOF"
  };
  var lexer = new Lexer({
    rules: [
      [0, /^\s+/, 0],
      ["b", /^[0-9]+(\.[0-9]+)?\b/, 0],
      ["c", /^\+/, 0],
      ["d", /^-/, 0],
      ["e", /^\(/, 0],
      ["f", /^\)/, 0],
      ["g", /^\*/, 0],
      ["h", /^\//, 0],
      ["i", /^./, 0]
    ]
  });
  parser.lexer = lexer;
  lexer.symbolMap = {
    $EOF: "a",
    NUMBER: "b",
    "+": "c",
    "-": "d",
    "(": "e",
    ")": "f",
    "*": "g",
    "/": "h",
    ERROR_LA: "i",
    Exp: "j",
    AddExp: "k",
    MulExp: "l",
    AddExp1: "m",
    PrimExp: "n",
    MulExp1: "o"
  };
  parser.productions = [
    ["j", ["k"]],
    ["k", ["l", "m"]],
    [
      "m",
      [
        "c",
        function(astProcessor) {
          astProcessor.pushStack(lexer.text);
        },
        "l",
        function(astProcessor) {
          astProcessor.createOpNode("+");
        },
        "m"
      ]
    ],
    ["m", []],
    ["l", ["n", "o"]],
    [
      "o",
      [
        "g",
        function(astProcessor) {
          astProcessor.pushStack(lexer.text);
        },
        "n",
        function(astProcessor) {
          astProcessor.createOpNode("*");
        },
        "o"
      ]
    ],
    ["o", []],
    [
      "n",
      [
        "b",
        function(astProcessor, lexer) {
          astProcessor.pushStack(Number(lexer.text));
        }
      ]
    ],
    ["n", ["e", "k", "f"]]
  ];
  parser.table = {
    j: {
      b: 0,
      e: 0
    },
    k: {
      b: 1,
      e: 1
    },
    m: {
      c: 2,
      a: 3,
      f: 3
    },
    l: {
      b: 4,
      e: 4
    },
    o: {
      g: 5,
      c: 6,
      a: 6,
      f: 6
    },
    n: {
      b: 7,
      e: 8
    }
  };
  parser.parse = function parse(input, options) {
    function peekStack(stack, n) {
      n = n || 1;
      return stack[stack.length - n];
    }

    function getTableVal(row, col) {
      return table[row] && table[row][col];
    }

    function noop() {}

    function getProductionSymbol(p) {
      return p.symbol || p[0];
    }

    function getProductionRhs(p) {
      return p.rhs || p[1];
    }

    options = options || {};
    var {
      onErrorRecovery = ({ error }) => {
        throw new Error(error);
      },
      onAction = noop
    } = options;
    var self = this;
    var lexer = self.lexer;
    var table = self.table;
    var productions = self.productions;
    var symbolStack = [getProductionSymbol(productions[0])];
    lexer.resetInput(input);
    let token;
    let next;
    let currentToken;

    function getError() {
      const expected = getExpected();
      return (
        "syntax error at line " +
        lexer.lineNumber +
        ":\n" +
        lexer.showDebugInfo() +
        "\n" +
        (expected.length ? "expect " + expected.join(", ") : "")
      );
    }

    let topSymbol;

    function getExpected() {
      const ret = (table[topSymbol] && Object.keys(table[topSymbol])) || [];
      return ret.map(r => lexer.mapReverseSymbol(r));
    }

    while (1) {
      topSymbol = peekStack(symbolStack);
      currentToken = token = token || lexer.lex();

      if (topSymbol === token) {
        symbolStack.pop();
        token = null;
      } else if ((next = getTableVal(topSymbol, token)) !== undefined) {
        symbolStack.pop();
        const production = productions[next];
        symbolStack.push.apply(
          symbolStack,
          getProductionRhs(production)
            .concat()
            .reverse()
        );
      } else {
        if (token === lexer.mapEndSymbol()) {
          onErrorRecovery({
            lexer,
            error: getError(),
            expected: getExpected(),
            symbol: lexer.mapReverseSymbol(topSymbol),
            token: null
          });
          break;
        } else {
          const action = (
            onErrorRecovery({
              lexer,
              error: getError(),
              expected: getExpected(),
              symbol: lexer.mapReverseSymbol(topSymbol),
              token
            }) || {}
          ).action;
          if (!action || action === "del") {
            lexer.matched = lexer.matched.slice(0, -lexer.match.length);
            token = null;
          }
        }
      }

      if (!symbolStack.length) {
        break;
      }

      topSymbol = peekStack(symbolStack);

      while (topSymbol && typeof topSymbol !== "string") {
        onAction({
          lexer,
          action: topSymbol
        });
        symbolStack.pop();
        topSymbol = peekStack(symbolStack);
      }
    }

    if (currentToken !== lexer.mapEndSymbol()) {
      onErrorRecovery({
        lexer,
        error: getError(),
        symbol: null,
        token: currentToken
      });
    }
  };

  return parser;
})();

export default cal;
